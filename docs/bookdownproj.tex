% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[
]{book}
\usepackage{amsmath,amssymb}
\usepackage{lmodern}
\usepackage{ifxetex,ifluatex}
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\hypersetup{
  pdftitle={Simulation and Modeling to Understand the Change},
  pdfauthor={Alejandro Martínez-Mingo \& Manuele Leonelli},
  hidelinks,
  pdfcreator={LaTeX via pandoc}}
\urlstyle{same} % disable monospaced font for URLs
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{248,248,248}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.94,0.16,0.16}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.77,0.63,0.00}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.64,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.81,0.36,0.00}{\textbf{#1}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\usepackage{longtable,booktabs,array}
\usepackage{calc} % for calculating minipage widths
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\usepackage{graphicx}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
% Set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{5}
\usepackage{booktabs}
\ifluatex
  \usepackage{selnolig}  % disable illegal ligatures
\fi
\usepackage[]{natbib}
\bibliographystyle{apalike}

\title{Simulation and Modeling to Understand the Change}
\author{Alejandro Martínez-Mingo \& Manuele Leonelli}
\date{2022-01-07}

\begin{document}
\maketitle

{
\setcounter{tocdepth}{1}
\tableofcontents
}
\hypertarget{preface}{%
\chapter*{Preface}\label{preface}}
\addcontentsline{toc}{chapter}{Preface}

These are lecture notes for the module \emph{Simulation and Modelling to Understand Change} given in the School of Human Sciences and Technology at IE University, Madrid, Spain. Knowledge of basic elements of R programming as well as probability and statistics is assumed.

\hypertarget{intro}{%
\chapter{Introduction}\label{intro}}

The first introductory chapter gives an overview of simulation, what it is, what it can be used for, as well as some examples.

\hypertarget{what-is-simulation}{%
\section{What is simulation}\label{what-is-simulation}}

A \emph{simulation} is an imitation of the dynamics of a real-world process or system over time. Although simulation could potentially still be done ``by hand'', nowadays it almost always implicitly requires the use of a computer to create an artificial history of a system to draw inferences about its characteristics and workings.

The behavior of the system is studied by constructing a \emph{simulation model}, which usually takes the form of a set of assumptions about the workings of the system. Once developed, a simulation model can be used for a variety of tasks, including:

\begin{itemize}
\item
  Investigate the behaviour of the system under a wide array of scenarios. This is also often referred to as ``what-if'' analyses;
\item
  Changes to the system can be simulated before implementation to predict their impact in real-world;
\item
  During the design stage of a system, meaning while it is being built, simulation can be used to guide its construction.
\end{itemize}

Computer simulation has been used in a variety of domains, including manifacturing, health care, transport system, defense and management science, among many others.

\hypertarget{a-simple-simulation-model}{%
\subsection{A simple simulation model}\label{a-simple-simulation-model}}

Suppose we decided to open a donut shop and are unsure about how many employees to hire to sell donuts to costumers. The operations of our little shop is the real-world system whose behavior we want to understand. Given that the shop is not operating yet, only a simulation model can provide us with insights.

We could of course devise models of different complexities, but for now suppose that we are happy with a simple model where we have the following elements:

\begin{itemize}
\item
  costumers that arrive at our shop at a particular rate;
\item
  employees (of a number to be given as input) that take a specific time to serve costumers.
\end{itemize}

Implicitly, we are completely disregarding the number of donuts available in our shop and assuming that we have an infinite availability of these. Of course, in a more complex simulation model we may want to also include this element to give a more realistic description of the system.

\hypertarget{why-simulate}{%
\subsection{Why simulate?}\label{why-simulate}}

An alternative approach to computer simulation is direct experimentation. In the bagel shop setting, we could wait for the shop to open and observe its workings by having a different number of employees on different days. Considered against real experimentation, simulation has the following advantages:

\begin{itemize}
\item
  It is \emph{cheaper} to implement and does not require a disruption of the real-world system;
\item
  It is \emph{faster} to implement and time can be compressed or expanded to allow for a speed-up or a slow-down of the system of interest;
\item
  It can be \emph{replicated} multiple times and the workings of the systems can be observed a large number of times;
\item
  It is \emph{safe} since it does not require an actual disruption of the system;
\item
  It is \emph{ethical} and \emph{legal} since it can implement changes in policies that would be unethical or illegal to do in real-world.
\end{itemize}

Another alternative is to use a mathematical model representing the system. However, it is often infeasible, if not impossible, to come up with an exact mathematical model which can faithfully represent the system under study.

\hypertarget{types-of-simulations}{%
\section{Types of simulations}\label{types-of-simulations}}

Before starting the construction of a simulation model, we need to decide upon the principal characteristics of that model. There are various choices to be made, which depend upon the system we are trying to understand.

\hypertarget{stochastic-vs-deterministic-simulations}{%
\subsection{Stochastic vs deterministic simulations}\label{stochastic-vs-deterministic-simulations}}

A model is \emph{deterministic} if its behavior is entirely predictable. Given a set of inputs, the model will result in a unique set of outputs. A model is \emph{stochastic} if it has random variables as inputs, and consequently also its outputs are random.

Consider the donut shop example. In a deterministic model we would for instance assume that a new customer arrives every 5 minutes and an employee takes 2 minutes to serve a customer. In a stochastic model we would on the other hand assume that the arrival times and the serving time follows some random variables: for instance, normal distributions with some mean and variance parameters.

In this course we will only consider stochastic simulation, but for illustration we consider now an example of a deterministic simulation.

A social media influencer decides to open a new page and her target is to reach 10k followers in 10 weeks. Given her past experience, she assumes that each week she will get 1.5k new followers that had never followed the page and of her current followers she believes 10\% will stop following the page each week. However, 20\% of those that the left the page in the past will join again each week. Will she reach her target?

To answer this question we can construct a deterministic simulation. Let \(F_t\) the number of followers at week \(t\) and \(U_t\) the number of users that are unfollowing the profile at week \(t\). Then
\[
F_t = F_{t-1} + 1500 - L_{t} + R_{t}, \hspace{1cm} U_t= U_{t-1} + L_{t} - R_{t}
\]
where \(L_{t}=0.1\cdot F_{t-1}\) is the number of unfollowers from time \(t-1\) to time \(t\), and \(R_{t}=0.2\cdot U_{t-1}\) is the number of users that follow the page back from time \(t-1\) to time \(t\).

To compute the number of followers after ten weeks we can use the R code below. It does not matter if you do not understand it now, we will review R coding in the next chapters.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Ft }\OtherTok{\textless{}{-}}\NormalTok{ Ut }\OtherTok{\textless{}{-}}\NormalTok{ Lt }\OtherTok{\textless{}{-}}\NormalTok{ Rt }\OtherTok{\textless{}{-}} \FunctionTok{rep}\NormalTok{(}\DecValTok{0}\NormalTok{,}\DecValTok{11}\NormalTok{)}
\ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{2}\SpecialCharTok{:}\DecValTok{11}\NormalTok{)\{}
\NormalTok{  Lt[i] }\OtherTok{\textless{}{-}} \FloatTok{0.1}\SpecialCharTok{*}\NormalTok{Ft[i}\DecValTok{{-}1}\NormalTok{]}
\NormalTok{  Rt[i] }\OtherTok{\textless{}{-}} \FloatTok{0.2}\SpecialCharTok{*}\NormalTok{Ut[i}\DecValTok{{-}1}\NormalTok{]}
\NormalTok{  Ut[i] }\OtherTok{\textless{}{-}}\NormalTok{ Ut[i}\DecValTok{{-}1}\NormalTok{] }\SpecialCharTok{+}\NormalTok{ Lt[i] }\SpecialCharTok{{-}}\NormalTok{ Rt[i]}
\NormalTok{  Ft[i] }\OtherTok{\textless{}{-}}\NormalTok{ Ft[i}\DecValTok{{-}1}\NormalTok{] }\SpecialCharTok{+} \DecValTok{1500} \SpecialCharTok{{-}}\NormalTok{ Lt[i] }\SpecialCharTok{+}\NormalTok{ Rt[i]}
\NormalTok{\}}
\NormalTok{result }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{(}\StringTok{"Followers"} \OtherTok{=}\NormalTok{ Ft, }\StringTok{"Total Unfollowers"} \OtherTok{=}\NormalTok{ Ut,}
           \StringTok{"Weekly Unfollowers"} \OtherTok{=}\NormalTok{ Ut, }\StringTok{"Weekly Returns"} \OtherTok{=}\NormalTok{ Rt)}
\end{Highlighting}
\end{Shaded}

The dataframe \texttt{result} is reported in Table \ref{tab:insta}, showing that she will be able to hit her target of 10k followers since she will have 11619 followers. If we run again the simulation we will obtain the exact same results: there is no stochasticity/uncertainty about the outcome.

\begin{table}

\caption{\label{tab:insta}Dataframe `result` from the social media deterministic simulation}
\centering
\begin{tabular}[t]{rrrr}
\toprule
Followers & Total.Unfollowers & Weekly.Unfollowers & Weekly.Returns\\
\midrule
0.000 & 0.000 & 0.000 & 0.0000\\
1500.000 & 0.000 & 0.000 & 0.0000\\
2850.000 & 150.000 & 150.000 & 0.0000\\
4095.000 & 405.000 & 405.000 & 30.0000\\
5266.500 & 733.500 & 733.500 & 81.0000\\
\addlinespace
6386.550 & 1113.450 & 1113.450 & 146.7000\\
7470.585 & 1529.415 & 1529.415 & 222.6900\\
8529.409 & 1970.591 & 1970.591 & 305.8830\\
9570.587 & 2429.413 & 2429.413 & 394.1181\\
10599.411 & 2900.589 & 2900.589 & 485.8827\\
\addlinespace
11619.587 & 3380.413 & 3380.413 & 580.1179\\
\bottomrule
\end{tabular}
\end{table}

The above application could be transformed into a stochastic simulation by allowing the rate at which she gets new followers, unfollowers etc. to be random variables of which we do not know the exact value.

\hypertarget{static-vs-dynamic-simulations}{%
\subsection{Static vs dynamic simulations}\label{static-vs-dynamic-simulations}}

Simulation models that represent the system at a particular point in time only are called \emph{static}. This type of simulations are often called as \emph{Monte Carlo simulations} and will be the focus of later chapters.

\emph{Dynamic} simulation models represent systems as they evolve over time. The simulation of the donut shop during its working hours is an example of a dynamic model.

\hypertarget{discrete-vs-continuous-simulations}{%
\subsection{Discrete vs continuous simulations}\label{discrete-vs-continuous-simulations}}

Dynamic simulations can be further categorized into discrete or continuous.

\emph{Discrete} simulation models are such that the variables of interest change only at a discrete set of points in time. The number of people queuing in the donut shop is an example of a discrete simulation. The number of customers changes only when a new customer arrives or when a customer has been served. Figure 1.1 gives an illustration of the discrete nature of the number of customers queuing in the donut shop.

\begin{figure}

{\centering \includegraphics[width=0.8\linewidth]{bookdownproj_files/figure-latex/discrete-1} 

}

\caption{Example of a discrete dynamic simulation}\label{fig:discrete}
\end{figure}

Figure 1.1 further illustrates that for specific period of times the system does not change state, that is the number of customers queuing remains constant. It is therefore useless to inspect the system during those times where nothing changes. This prompts the way in which time is usually handled in dynamic discrete simulations, using the so-called \emph{next-event technique}. The model is only examined and updated when the system is due to change. These changes are usually called \emph{events}. Looking at Figure 1.1 at time zero there is an event: a customer arrives; at time nine another customer arrives; at time ten another customer arrives; at time twelve a customer is served; and so on. All these are examples of events.

\emph{Continuous} simulation models are such that the variables of interest change continuously over time. Suppose for instance a simulation model for a car journey was created where the interest is on the speed of the car throughout the journey. Then this would be a continuous simulation model. Figure 1.2 gives an illustration of this.

\begin{figure}

{\centering \includegraphics[width=0.8\linewidth]{bookdownproj_files/figure-latex/fig-cont-1} 

}

\caption{Example of a discrete dynamic simulation}\label{fig:fig-cont}
\end{figure}

In later chapters we will focus on discrete simulations, which are usually called \emph{discrete-event simulation}.

\hypertarget{elements-of-a-simulation-model}{%
\section{Elements of a simulation model}\label{elements-of-a-simulation-model}}

We next introduce some terminology which we will need in the following.

\hypertarget{objects-of-the-model}{%
\subsection{Objects of the model}\label{objects-of-the-model}}

There are two types of objects a simulation model is often made of:

\begin{itemize}
\item
  \emph{Entities}: individual elements of the system that are being simulated and whose behavior is being explicitly tracked. Each entity can be individually identified;
\item
  \emph{Resources}: also individual elements of the system but they are not modelled individually. They are treated as countable items whose behavior is not tracked.
\end{itemize}

Whether an element should be treated as an entity or as a resource is something that the modeller must decide and depends on the purpose of the simulation. Consider our simple donut shop. Clients will be most likely be resources since we are not really interested in what each of them do. Employees may either be considered as entities or resources: in the former case we want to track the amount of time each of them are working; in the latter the model would only be able to output an overview of how busy overall the employees are.

\hypertarget{organization-of-entities-and-resources}{%
\subsection{Organization of entities and resources}\label{organization-of-entities-and-resources}}

\begin{itemize}
\item
  \emph{Attributes}: properties of objects (that is entities and resources). This is often used to control the behavior of the object. In our donut shop an attribute may be the state of an employee: whether she is busy or available. In a more comprehensive simulation, an attribute might be the type of donut a customer will buy (for instance, chocolate, vanilla or jam).
\item
  \emph{State}: collection of variables necessary to describe the system at any time point. In our donut shop, in the simplest case the necessary variables are number of customers queuing and number of busy employees. This fully characterizes the system.
\item
  \emph{List}: collection of entites or resources ordered in some logical fashion. For instance, the customers waiting in our shop may be ordered in the so-called ``fist-come, first-served" scheme, that is customers will be served in the order they arrived in the shop.
\end{itemize}

\hypertarget{operations-of-the-objects}{%
\subsection{Operations of the objects}\label{operations-of-the-objects}}

During a simulation study, entities and resources will cooperate and therefore change state. The following terminology describe this as well as the flow of time:

\begin{itemize}
\item
  \emph{Event}: instant of time where the state of the system changes. In the donut shop suppose that there are currently two customers being served. An event is when a customer has finished being served: the number of busy employees decreases by one and there is one less customer queuing.
\item
  \emph{Activity}: a time period of specified length which is known when it begins (although its length may be random). The time an employee takes to serve a customer is an example of an activity: this may be specified in terms of a random distribution.
\item
  \emph{Delay}: duration of time of unspecified length, which is not known until it ends. This is not specified by the modeller ahead of time but is determined by the conditions of the system. Very often this is one of the desired output of a simulation. For instance, a delay is the waiting time of a customer in the queue of our donut shop.
\item
  \emph{Clock}: variable representing simulated time.
\end{itemize}

\hypertarget{the-donut-shop-example}{%
\section{The donut shop example}\label{the-donut-shop-example}}

Let's consider in more details the donut shop example and let's construct and implement our first simulation model. At this stage, you should not worry about the implementation details. These will be formalized in more details in later chapters.

Let's make some assumptions:

\begin{itemize}
\item
  the queue in the shop is possibly infinite: whenever a customer arrives she will stay in the queue independent of how many customers are already queuing and she will wait until she is served.
\item
  customers are served on a first-come, first-served basis.
\item
  there are two employees. On average they take the same time to serve a customer. Whenever an employee is free, a customer is allocated to that employee. If both employees are free, either of the two starts serving a customer.
\end{itemize}

The components of the simulation model are the following:

\begin{itemize}
\item
  \textbf{System state}: \(N_C(t)\) number of customers waiting to be served at time \(t\); \(N_E(t)\) number of employees busy at time \(t\).
\item
  \textbf{Resources}: customers and employees;
\item
  \textbf{Events}: arrival of a customer; service completion by an employee.
\item
  \textbf{Activities}: time between a customer arrival and the next; service time by an employee.
\item
  \textbf{Delay}: customers' waiting time in the queue until an employee is available.
\end{itemize}

From an abstract point of view we have now defined all components of our simulation model. Before implementing, we need to choose the length of the activities. This is usually done using common sense, intuition or historical data. Suppose for instance that the time between the arrival of customers is modeled as an Exponential distribution with parameter 1/3 (that is on average a customer arrives every three minutes) and the service time is modeled as a continuous Uniform distribution between 1 and 5 (on average a service takes three minutes).

With this information we can now implement the workings of our donut shop. It does not matter the specific code itself, we will learn about it in later chapters. At this stage it is only important to notice that we use the \texttt{simmer} package together with the functionalities of \texttt{magrittr}. We simulate our donut shop for two hours.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(simmer)}
\FunctionTok{library}\NormalTok{(magrittr)}
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{2021}\NormalTok{)}

\NormalTok{env }\OtherTok{\textless{}{-}}  \FunctionTok{simmer}\NormalTok{(}\StringTok{"donut shop"}\NormalTok{)}

\NormalTok{customer }\OtherTok{\textless{}{-}} \FunctionTok{trajectory}\NormalTok{(}\StringTok{"customer"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{seize}\NormalTok{(}\StringTok{"employee"}\NormalTok{, }\DecValTok{1}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{timeout}\NormalTok{(}\ControlFlowTok{function}\NormalTok{() }\FunctionTok{runif}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{1}\NormalTok{,}\DecValTok{5}\NormalTok{)) }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{release}\NormalTok{(}\StringTok{"employee"}\NormalTok{, }\DecValTok{1}\NormalTok{) }

\NormalTok{env }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{add\_resource}\NormalTok{(}\StringTok{"employee"}\NormalTok{, }\DecValTok{2}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{add\_generator}\NormalTok{(}\StringTok{"customer"}\NormalTok{, customer, }\ControlFlowTok{function}\NormalTok{() }\FunctionTok{rexp}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{1}\SpecialCharTok{/}\DecValTok{3}\NormalTok{))}

\NormalTok{env }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{run}\NormalTok{(}\AttributeTok{until=}\DecValTok{120}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

The above code creates a simulation of the donut shop for two hours. Next we report some graphical summaries that describe how the system worked.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(simmer.plot)}
\FunctionTok{library}\NormalTok{(gridExtra)}
\NormalTok{p1 }\OtherTok{\textless{}{-}} \FunctionTok{plot}\NormalTok{(}\FunctionTok{get\_mon\_resources}\NormalTok{(env), }\AttributeTok{metric =} \StringTok{"usage"}\NormalTok{, }\AttributeTok{items =} \StringTok{"server"}\NormalTok{,}\AttributeTok{step =}\NormalTok{ T)}
\NormalTok{p2 }\OtherTok{\textless{}{-}} \FunctionTok{plot}\NormalTok{(}\FunctionTok{get\_mon\_arrivals}\NormalTok{(env), }\AttributeTok{metric =} \StringTok{"waiting\_time"}\NormalTok{)}

\FunctionTok{grid.arrange}\NormalTok{(p1,p2,}\AttributeTok{ncol=}\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{figure}

{\centering \includegraphics{bookdownproj_files/figure-latex/donut-1} 

}

\caption{Graphical summaries from the simulation of the donut shop}\label{fig:donut}
\end{figure}

The left plot in Figure 1.3 reports the number of busy employees busy throughout the simulation. We can observe that often no employees were busy, but sometimes both of them are busy. The right plot in Figure 1.3 reports the waiting time of customers throughout the simulation. Most often customers do not wait in our shop and the largest waiting time is of about four minutes.

Some observations:

\begin{itemize}
\item
  this is the result of a single simulation where inputs are random and described by a random variable (for instance, Poisson and Uniform). If we were to run the simulation again we would observe different results.
\item
  given that we have built the simulation model, it is straightforward to change some of the inputs and observe the results under different conditions. For instance, we could investigate what would happen if we had only one employee. We could also investigate the use of different input parameters for the customer arrival times and the service times.
\end{itemize}

\hypertarget{simulating-a-little-health-center}{%
\section{Simulating a little health center}\label{simulating-a-little-health-center}}

Consider now a slightly more complex example where we want to simulate the workings of a little health center. Patients arrive at the health center and are first visited by a nurse. Once they are visited by the nurse they have an actual consultation with a doctor. Once they are finished with the doctor, they meet the administrative staff to schedule a follow-up appointment.

We make the following assumptions:

\begin{itemize}
\item
  as before we assume queues to be infinite and that patients do not leave the health center until they are served by the administrative staff;
\item
  at all steps patients are visited using a first-come, first-served basis
\item
  the health center has one nurse, two doctors and one administrative staff. The two doctors take on average the same time to visit a patient.
\end{itemize}

The components of the simulation model are the following:

\begin{itemize}
\item
  \textbf{System state}:

  \begin{itemize}
  \item
    \(Q_N(t)\): number of patients queuing to see the nurse;
  \item
    \(Q_D(t)\): number of patients queing to see a doctor;
  \item
    \(Q_A(t)\): number of patients queuing to see the staff;
  \item
    \(N_N(t)\): number of nurses available to visit patients;
  \item
    \(N_D(t)\): number of doctors available to visit patients;
  \item
    \(N_A(t)\): number of administrative staff available to visit patients.
  \end{itemize}
\item
  \textbf{Resources}: patients, nurses, doctors and administrative staff;
\item
  \textbf{Events}: arrival of a patient, completion of nurse's visit, completation of doctor's visit, completion of administrative staff's visit.
\item
  \textbf{Activities}: time between the arrival of a patient and the next, visit's times of nurses, doctors and admin staff.
\item
  \textbf{Delay}: customers' waiting time for nurses, doctors and administrative staff
\end{itemize}

We further assume the following activities:

\begin{itemize}
\item
  Nurse visit times follow a Normal distribution with mean 15 and variance 1;
\item
  Doctor visit times follow a Normal distribution with mean 20 and variance 1;
\item
  Administrative staff visit times follow a Normal distribution with mean 5 and variance 1;
\item
  Time between the arrival of patients is modeled as a Normal with mean 10 and variance 4.
\end{itemize}

The model above can be implemented using the following code (we run the simulation for four hours). Again do not worry about it now!

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{2021}\NormalTok{)}
\NormalTok{env }\OtherTok{\textless{}{-}} \FunctionTok{simmer}\NormalTok{(}\StringTok{"HealthCenter"}\NormalTok{)}

\NormalTok{patient }\OtherTok{\textless{}{-}} \FunctionTok{trajectory}\NormalTok{(}\StringTok{"patients\textquotesingle{} path"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{seize}\NormalTok{(}\StringTok{"nurse"}\NormalTok{, }\DecValTok{1}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{timeout}\NormalTok{(}\ControlFlowTok{function}\NormalTok{() }\FunctionTok{rnorm}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{15}\NormalTok{)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{release}\NormalTok{(}\StringTok{"nurse"}\NormalTok{, }\DecValTok{1}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{seize}\NormalTok{(}\StringTok{"doctor"}\NormalTok{, }\DecValTok{1}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{timeout}\NormalTok{(}\ControlFlowTok{function}\NormalTok{() }\FunctionTok{rnorm}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{20}\NormalTok{)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{release}\NormalTok{(}\StringTok{"doctor"}\NormalTok{, }\DecValTok{1}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{seize}\NormalTok{(}\StringTok{"administration"}\NormalTok{, }\DecValTok{1}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{timeout}\NormalTok{(}\ControlFlowTok{function}\NormalTok{() }\FunctionTok{rnorm}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{5}\NormalTok{)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{release}\NormalTok{(}\StringTok{"administration"}\NormalTok{, }\DecValTok{1}\NormalTok{)}

\NormalTok{env }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{add\_resource}\NormalTok{(}\StringTok{"nurse"}\NormalTok{, }\DecValTok{1}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{add\_resource}\NormalTok{(}\StringTok{"doctor"}\NormalTok{, }\DecValTok{2}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{add\_resource}\NormalTok{(}\StringTok{"administration"}\NormalTok{, }\DecValTok{1}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{add\_generator}\NormalTok{(}\StringTok{"patient"}\NormalTok{, patient, }\ControlFlowTok{function}\NormalTok{() }\FunctionTok{rnorm}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{10}\NormalTok{, }\DecValTok{2}\NormalTok{))}

\NormalTok{env }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{run}\NormalTok{(}\DecValTok{240}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Let's look at some summary statistics.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{plot}\NormalTok{(}\FunctionTok{get\_mon\_resources}\NormalTok{(env), }\AttributeTok{metric =} \StringTok{"utilization"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{figure}

{\centering \includegraphics{bookdownproj_files/figure-latex/unnamed-chunk-4-1} 

}

\caption{Utilization of the resources in the health center}\label{fig:unnamed-chunk-4}
\end{figure}

Figure 1.4 shows the utilization of the different resources in the system. Nurses are most busy, doctors are overall fairly available, whilst the administration is more than half of the time available.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{plot}\NormalTok{(}\FunctionTok{get\_mon\_resources}\NormalTok{(env), }\AttributeTok{metric =} \StringTok{"usage"}\NormalTok{, }\AttributeTok{item =} \StringTok{"server"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{figure}

{\centering \includegraphics{bookdownproj_files/figure-latex/unnamed-chunk-5-1} 

}

\caption{Usage of the resources in the health center}\label{fig:unnamed-chunk-5}
\end{figure}

Figure 1.5 confirms this. We see that the usage of nurses is almost 1, whilst for doctors and administrative staff we are below the number of doctors and staff available.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{plot}\NormalTok{(}\FunctionTok{get\_mon\_arrivals}\NormalTok{(env), }\AttributeTok{metric =} \StringTok{"flow\_time"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{figure}

{\centering \includegraphics{bookdownproj_files/figure-latex/unnamed-chunk-6-1} 

}

\caption{Time spent in the health center}\label{fig:unnamed-chunk-6}
\end{figure}

Last Figure 1.6 reports the average time spent by patients in the health center. We can see that as the simulation clock increases, patients spend more time in the health center. From the previous plots, we can deduce that in general patients wait for the nurse, who has been busy all the time during the simulation.

\hypertarget{whats-next}{%
\section{What's next}\label{whats-next}}

The previous examples should have given you an idea of what a simulation model is and what you will be able to implement by the end of the course. However, it will take some time before we get to actually simulate systems. There are various skills that you will need to learn or revise before being able to implement simulation in R yourself. Specifically:

\begin{itemize}
\item
  first we will review the basics of R programming;
\item
  we will then review basic elements of probability and statistics;
\item
  we will discuss how randomness is implemented in programming languages and in R;
\item
  at this stage you will be able to implement your first simple simulations. In particular we will start with static simulation, also called \emph{Monte Carlo} simulation
\item
  we will then look at dynamic simulations as in the previous examples.
\end{itemize}

\hypertarget{r-programming}{%
\chapter{R programming}\label{r-programming}}

R is a programming language most commonly used within the statistical and machine learning community. This chapter will review some of the elements of R programming that will be used in later chapters. Do not expect this chapter to be exhaustive or self-contained. It is intended to give a quick refresh of R for users that have at least some experience with this programming language. There are many topics and concepts which are fundamental but will not be reviewed in this chapter. However, you should aim to master the topics included in this chapter since they will appear again later on in these notes. There are many other resources if you want to have a more in-depth look into R programming.

\begin{itemize}
\item
  The books of Hadley Wickham are surely a great starting point and are all available \href{http://hadley.nz/}{here}.
\item
  If you are unsure on how to do something with R, Google it!!! The community of R users is so wide that surely someone else has already asked your same question.
\item
  The R help is extremely useful and comprehensive. If you want to know more about a function, suppose it is called function, you can type \texttt{?function}.
\end{itemize}

\hypertarget{why-r}{%
\section{Why R?}\label{why-r}}

As mentioned in the previous chapter, simulation is very often applied in many areas, for instance management science and engineering. Often a simulation is carried out using an Excel spreadsheet or using a specialised software whose only purpose is creating simulations. Historically, R has not been at the forefront of the implementation of simulation models, in particular of discrete-event simulations. Only recently, R packages implementing discrete-event simulation have appeared, most importantly the \texttt{simmer} R package that you will learn using in later chapters.

These notes are intended to provide a unique view of simulation with specific implementation in the R programming language. Some of the strenght of R are:

\begin{itemize}
\item
  it is free, open-source and available in all major operating systems;
\item
  the community of R users is huge, with many forums, sites and resources that give you practical support in developing your own code;
\item
  a massive set of add-on packages to increase the capabilities of the basic R environment;
\item
  functions to perform state-of-the-art statistical and machine-learning methods. Researchers sometimes create an associated R package to any article they publish so for others to use their methods;
\item
  the integrated development environment RStudio provides a user-friendly environment to make the R programming experience more pleasing;
\item
  powerful communication tools to create documents and presentations embedding R code and R output. As a matter of fact this very book is created in R!!!!
\end{itemize}

\hypertarget{section-bibliography}{%
\section{Section Bibliography}\label{section-bibliography}}

\begin{itemize}
\tightlist
\item
  Crawley, M. J. (2012). The R book. John Wiley \& Sons.
\end{itemize}

\hypertarget{r-basics}{%
\section{R basics}\label{r-basics}}

So let's get started with R programming!

\hypertarget{introduction-to-r}{%
\subsection{Introduction to R}\label{introduction-to-r}}

\textbf{R} is an \emph{Open Source}, powerful, flexible and extensible statistical language. It is used by many companies (Google, Microsoft, Facebook, BBVA, etc\ldots) and universities by Statisticians and Data Scientists in software development. Unlike traditional spreadsheets, in R programming sentences are written instead of the classic formulas. It is necessary to know the structure of the data. Prototypes can be made with a few lines of code.

\hypertarget{r-history}{%
\subsection{R History}\label{r-history}}

R is an implementation of the statistical language S (combined with the programming language Scheme). S was developed in the AT\&T labs by John Chambers in the late 1970s. The two main implementations of S are:

\begin{itemize}
\tightlist
\item
  R
\item
  S+ (S-PLUS)
\end{itemize}

There are usually several releases a year (usually the most important in April):

\begin{itemize}
\tightlist
\item
  3.1.0 (Spring Dance) 10/04/2014
\item
  3.2.0 (Full of Ingredients) 16/04/2015
\item
  3.5.0 (Joy in Playing) 23/04/2018
\item
  4.0.0 (Bunny-Wunnies Freak Out) 24/04/2020
\item
  4.1.0 (Camp Pontanezen) 18/05/2021
\end{itemize}

\hypertarget{r-advantages}{%
\subsection{R Advantages}\label{r-advantages}}

R is a great software for solving data analysis problems. There are many packages for data processing, statistical modelling, data mining and graphics. There is a community of users creating packages called \href{https://www.r-project.org}{the R project}.

R is very useful for making graphs, analyzing data and obtaining statistical models with data that fit in the RAM memory of the PC. There are limitations, from a memory point of view, with large volumes of data. It is very common to use another resources to prepare the data:

\begin{itemize}
\tightlist
\item
  Small or medium volumes: Python, Julia, Perl\ldots{}
\item
  Large Volumes: Spark, Hadoop, Pig, Hive\ldots{}
\end{itemize}

\hypertarget{what-do-we-mean-by-r}{%
\subsection{What do we mean by R?}\label{what-do-we-mean-by-r}}

By R we usually mean:

\begin{itemize}
\tightlist
\item
  The programming language.
\item
  The interpreter who executes the code written in R.
\item
  The graphics generation system of R.
\item
  The R programming IDE, or also known as RStudio (includes the R interpreter, graphics system, package manager and user interface).
\end{itemize}

\hypertarget{console-mode}{%
\subsection{Console Mode}\label{console-mode}}

To open the \textbf{R console}, run from the command line (Terminal in Mac):

\texttt{\$\textgreater{}R}

The console opens, which allows you to write commands interactively. Each of these commands is called \textbf{expressions}. The \textbf{R interpreter} reads these expressions and responds with the result or an error message. The command interface will store the steps followed when analyzing the data.

The \texttt{history()} command displays the history of commands entered during the \textbf{R session}. Names of variables, packages, directories, etc. are auto-completed using \textbf{tabulator}. If the name of a function is written in the console, its code is displayed. For example: \texttt{history}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{history}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## function (max.show = 25, reverse = FALSE, pattern, ...) 
## {
##     file1 <- tempfile("Rrawhist")
##     savehistory(file1)
##     rawhist <- readLines(file1)
##     unlink(file1)
##     if (!missing(pattern)) 
##         rawhist <- unique(grep(pattern, rawhist, value = TRUE, 
##             ...))
##     nlines <- length(rawhist)
##     if (nlines) {
##         inds <- max(1, nlines - max.show):nlines
##         if (reverse) 
##             inds <- rev(inds)
##     }
##     else inds <- integer()
##     file2 <- tempfile("hist")
##     writeLines(rawhist[inds], file2)
##     file.show(file2, title = "R History", delete.file = TRUE)
## }
## <bytecode: 0x55eb7e418520>
## <environment: namespace:utils>
\end{verbatim}

\hypertarget{getting-help-in-r}{%
\subsection{Getting help in R}\label{getting-help-in-r}}

The simplest way to get help in R is to click on the Help button on the toolbar of the RGui window (this stands for R's Graphic User Interface).

However, if you know the name of the function you want help with, you just type a question mark \texttt{?} at the command line prompt followed by the name of the function. So to get help on \texttt{read.table}, just type:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{?read.table}
\end{Highlighting}
\end{Shaded}

Sometimes you cannot remember the precise name of the function, but you know the subject on which you want help (e.g.~data input in this case). Use the help.search function (without a question mark) with your query in double quotes like this:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{help.search}\NormalTok{(}\StringTok{"read tables"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Other useful functions are \texttt{find} and \texttt{apropos}. The \texttt{find} function tells you what package something is in:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{find}\NormalTok{(}\StringTok{"mean"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "package:base"
\end{verbatim}

while \texttt{apropos} returns a character vector giving the names of all objects in the search list that match your (potentially partial) enquiry:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{apropos}\NormalTok{(}\StringTok{"lm"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] ".colMeans"       ".lm.fit"         "colMeans"        "confint.lm"     
##  [5] "contr.helmert"   "dummy.coef.lm"   "glm"             "glm.control"    
##  [9] "glm.fit"         "KalmanForecast"  "KalmanLike"      "KalmanRun"      
## [13] "KalmanSmooth"    "kappa.lm"        "lm"              "lm.fit"         
## [17] "lm.influence"    "lm.wfit"         "model.matrix.lm" "nlm"            
## [21] "nlminb"          "predict.glm"     "predict.lm"      "residuals.glm"  
## [25] "residuals.lm"    "summary.glm"     "summary.lm"
\end{verbatim}

To see a worked example just type the function name (e.g.~linear models, \texttt{lm}) and you will see the printed and graphical output produced by the \texttt{lm} function:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{example}\NormalTok{(lm)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 
## lm> require(graphics)
## 
## lm> ## Annette Dobson (1990) "An Introduction to Generalized Linear Models".
## lm> ## Page 9: Plant Weight Data.
## lm> ctl <- c(4.17,5.58,5.18,6.11,4.50,4.61,5.17,4.53,5.33,5.14)
## 
## lm> trt <- c(4.81,4.17,4.41,3.59,5.87,3.83,6.03,4.89,4.32,4.69)
## 
## lm> group <- gl(2, 10, 20, labels = c("Ctl","Trt"))
## 
## lm> weight <- c(ctl, trt)
## 
## lm> lm.D9 <- lm(weight ~ group)
## 
## lm> lm.D90 <- lm(weight ~ group - 1) # omitting intercept
## 
## lm> ## No test: 
## lm> ##D anova(lm.D9)
## lm> ##D summary(lm.D90)
## lm> ## End(No test)
## lm> opar <- par(mfrow = c(2,2), oma = c(0, 0, 1.1, 0))
## 
## lm> plot(lm.D9, las = 1)      # Residuals, Fitted, ...
\end{verbatim}

\includegraphics{bookdownproj_files/figure-latex/unnamed-chunk-12-1.pdf}

\begin{verbatim}
## 
## lm> par(opar)
## 
## lm> ## Don't show: 
## lm> ## model frame :
## lm> stopifnot(identical(lm(weight ~ group, method = "model.frame"),
## lm+                     model.frame(lm.D9)))
## 
## lm> ## End(Don't show)
## lm> ### less simple examples in "See Also" above
## lm> 
## lm> 
## lm>
\end{verbatim}

Demonstrations of R functions can be useful for seeing the range of things that R can do. Here are some for you to try:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\#demo(persp)}
\CommentTok{\#demo(graphics)}
\CommentTok{\#demo(Hershey)}
\CommentTok{\#demo(plotmath)}
\end{Highlighting}
\end{Shaded}

\hypertarget{packages-in-r}{%
\subsection{Packages in R}\label{packages-in-r}}

Finding your way around the contributed packages can be tricky, simply because there are so many of them, and the name of the package is not always as indicative of its function as you might hope. There is no comprehensive cross-referenced index, but there is a very helpful feature called `Task Views' on CRAN, which explains the packages available under a limited number of usefully descriptive headings.

\href{https://cran.r-project.org/}{Click here to see the `Task Views'}

\hypertarget{built-in-r-libraries}{%
\subsection{Built-in R libraries}\label{built-in-r-libraries}}

To use one of the built-in libraries, simply type the library function with the name of the library in brackets. Thus, to load the \texttt{dplyr} library type:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(dplyr)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 
## Attaching package: 'dplyr'
\end{verbatim}

\begin{verbatim}
## The following object is masked from 'package:gridExtra':
## 
##     combine
\end{verbatim}

\begin{verbatim}
## The following object is masked from 'package:simmer':
## 
##     select
\end{verbatim}

\begin{verbatim}
## The following objects are masked from 'package:stats':
## 
##     filter, lag
\end{verbatim}

\begin{verbatim}
## The following objects are masked from 'package:base':
## 
##     intersect, setdiff, setequal, union
\end{verbatim}

\hypertarget{contents-of-packages}{%
\subsection{Contents of Packages}\label{contents-of-packages}}

It is easy to use the \texttt{help} function to discover the contents of library packages. Here is how you find out about the contents of the \texttt{dplyr} library:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(}\AttributeTok{help=}\NormalTok{dplyr)}
\end{Highlighting}
\end{Shaded}

Then, to find out how to use, say, mutate (\texttt{mutate}), just type:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{?mutate}
\end{Highlighting}
\end{Shaded}

\hypertarget{installing-packages}{%
\subsection{Installing Packages}\label{installing-packages}}

The base package does not contain some of the libraries referred to in this course, but downloading these is very simple. Before you start, you should check whether you need to ``Run as administrator'' before you can install packages (right click on the R icon to find this).

Run the R program, then from the command line use the install.packages function to download the libraries you want. For example, to install the \texttt{ggplot2} package type this:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\#install.packages("ggplot2")}
\end{Highlighting}
\end{Shaded}

\hypertarget{command-line-versus-scripts}{%
\subsection{Command line versus scripts}\label{command-line-versus-scripts}}

When writing functions and other multi-line sections of input you will find it useful to use a text editor rather than execute everything directly at the command line.

Currently, most users prefer to use an IDE rather than executable text files. The most famous IDE for using R is \href{https://rstudio.com/}{Rstudio}.

\hypertarget{rstudio}{%
\subsection{RStudio}\label{rstudio}}

Programming IDE to develop projects in R: \url{https://www.rstudio.com/}

There are two versions:

\begin{itemize}
\tightlist
\item
  RStudio Desktop
\item
  RStudio Server (RStudio Desktop interface in web version)
\end{itemize}

Both versions have open source (free) and commercial (with support included) versions.

Allows the complete management of a software project:

\begin{itemize}
\tightlist
\item
  Console R
\item
  File management
\item
  Help
\item
  Package management (installation, update, etc.)
\item
  Review of command history
\end{itemize}

\hypertarget{working-directory}{%
\subsection{Working Directory}\label{working-directory}}

As we have mentioned, R is a programming language that allows us to perform certain actions through an IDE installed in our computer.

In many cases we will need to store data or code sets to use them later. We may also need to read a data set from an external format or even write it. To do all these things, we need to know where we are on the computer, in other words, which folder we are currently in.

We will call this location the working directory. We are going to place there all the resources we need to work with R.

We will use the function setwd() to indicate our location to the R session we are working at.

Example:

\begin{verbatim}
setwd("C://User/Desktop/My_Working_Directory")
\end{verbatim}

\hypertarget{exercise-set-up-your-working-directory}{%
\subsection{Exercise: Set up your Working Directory}\label{exercise-set-up-your-working-directory}}

Try to start getting familiar with Rstudio and to set your working directory in a folder that is suitable for the rest of the course.

Remember, within this folder you can create sub-folders for each session in which you can include all the necessary material.

\hypertarget{expressions-objects-and-symbols}{%
\section{Expressions, Objects and Symbols}\label{expressions-objects-and-symbols}}

The R code is composed by expressions. Some examples of expressions:

\begin{itemize}
\tightlist
\item
  Assignments
\item
  Conditional sentences
\item
  Arithmetic operations
\item
  \ldots{}
\end{itemize}

Expressions are made up of objects and functions. Each expression is separated from another by a new line or semicolon (;).

The R code manipulates objects. Some examples of objects:

\begin{itemize}
\tightlist
\item
  Vectors
\item
  Lists
\item
  Functions
\item
  \ldots{}
\end{itemize}

Formally the variable names in R are called symbols. Thus, we assign the object to a symbol of the current environment. The environment is formed by the set of symbols in a certain context.

\hypertarget{some-examples-to-start-with}{%
\subsection{Some examples to start with}\label{some-examples-to-start-with}}

We can use R for many things, but there are certain basics that need to be learned. When we enter a code in the R console, this code will provide us with an output. Let's look at an example: If we enter a number or a word, R will return the same number or word.

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{23}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 23
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\StringTok{"Baby Yoda"}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Baby Yoda"
\end{verbatim}

Each of these codes we have generated is interpreted by R, sent to our computer in a low level language, and returned in an understandable format for us.

Each code can be understood as an object (not stored) that R is interpreting for us. If we want to store that objects in our computer RAM to use them later in the same R session we need to create an assignment (we assign something to a symbol). Example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my\_number }\OtherTok{=} \DecValTok{23}
\NormalTok{my\_character }\OtherTok{=} \StringTok{"Baby Yoda"}
\end{Highlighting}
\end{Shaded}

So we can use them later. For example, let's just print them:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{print}\NormalTok{(my\_number)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 23
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{print}\NormalTok{(my\_character)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Baby Yoda"
\end{verbatim}

Notice that to assign something to a symbol we can use \texttt{=} or \texttt{\textless{}-}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my\_number }\OtherTok{=} \DecValTok{23}
\NormalTok{my\_character }\OtherTok{=} \StringTok{"Baby Yoda"}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{print}\NormalTok{(my\_number)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 23
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{print}\NormalTok{(my\_character)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Baby Yoda"
\end{verbatim}

\hypertarget{r-as-a-calculator}{%
\section{R as a Calculator}\label{r-as-a-calculator}}

The screen prompt \texttt{\textgreater{}} is an invitation to put R to work. You can use the Rstudio command line as a calculator, like this:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{log}\NormalTok{(}\DecValTok{42}\SpecialCharTok{/}\FloatTok{7.3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1.749795
\end{verbatim}

Each line can have at most 8192 characters, but if you want to see a lengthy instruction or a complicated expression on the screen, you can continue it on one or more further lines simply by ending the line at a place where the line is obviously incomplete (e.g.~with a trailing comma, operator, or with more left parentheses than right parentheses, implying that more right parentheses will follow).

When continuation is expected, the prompt changes from \textgreater{} to +:

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{5}\SpecialCharTok{+}\DecValTok{6}\SpecialCharTok{+}\DecValTok{3}\SpecialCharTok{+}\DecValTok{6}\SpecialCharTok{+}\DecValTok{4}\SpecialCharTok{+}\DecValTok{2}\SpecialCharTok{+}\DecValTok{4}\SpecialCharTok{+}\DecValTok{8}\SpecialCharTok{+}
\DecValTok{3}\SpecialCharTok{+}\DecValTok{2}\SpecialCharTok{+}\DecValTok{7}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 50
\end{verbatim}

Note that the + continuation prompt does not carry out arithmetic plus. If you have made a mistake, and you want to get rid of the + prompt and return to the \textgreater{} prompt, then press the Esc key and use the Up arrow to edit the last (incomplete) line.

Two or more expressions can be placed on a single line so long as they are separated by semi-colons:

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{2}\SpecialCharTok{+}\DecValTok{3}\NormalTok{; }\DecValTok{5}\SpecialCharTok{*}\DecValTok{7}\NormalTok{; }\DecValTok{3{-}7}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 5
\end{verbatim}

\begin{verbatim}
## [1] 35
\end{verbatim}

\begin{verbatim}
## [1] -4
\end{verbatim}

For very big numbers or very small numbers R uses the following scheme (called exponents):

\begin{itemize}
\tightlist
\item
  \texttt{1.2e3}: means 1200 because the e3 means `move the decimal point 3 places to the right'
\item
  \texttt{1.2e-2}: means 0.012 because the e-2 means `move the decimal point 2 places to the left'
\item
  \texttt{3.9+4.5i}: is a complex number with real (3.9) and imaginary (4.5) parts, and i is the square root of --1.
\end{itemize}

\hypertarget{complex-numbers-in-r}{%
\subsection{Complex numbers in R}\label{complex-numbers-in-r}}

Complex numbers consist of a real part and an imaginary part, which is identified by lower-case i like this:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{z }\OtherTok{=} \FloatTok{3.5}\SpecialCharTok{{-}}\NormalTok{8i}
\end{Highlighting}
\end{Shaded}

The elementary trigonometric, logarithmic, exponential, square root and hyperbolic functions are all
implemented for complex values. The following are the special R functions that you can use with com-
plex numbers:

\begin{itemize}
\tightlist
\item
  Determine the real part:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{Re}\NormalTok{(z)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 3.5
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Determine the imaginary part:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{Im}\NormalTok{(z)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] -8
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Calculate the modulus (if x is the real part and y is the imaginary part, then the modulus is \(\sqrt(x^2 + y^2)\)):
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{Mod}\NormalTok{(z)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 8.732125
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Calculate the argument (\texttt{Arg(x+\ yi)=\ atan(y/x)}):
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{Arg}\NormalTok{(z)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] -1.158386
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Work out the complex conjugate (change the sign of the imaginary part):
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{Conj}\NormalTok{(z)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 3.5+8i
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Check if the object is a complex number:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{is.complex}\NormalTok{(z)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Coerce a number into a complex number:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{as.complex}\NormalTok{(}\FloatTok{3.8}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 3.8+0i
\end{verbatim}

\hypertarget{rounding}{%
\subsection{Rounding}\label{rounding}}

Various sorts of rounding (rounding up, rounding down, rounding to the nearest integer) can be done easily. Take the number \texttt{5.7} as an example. The `greatest integer less than' function is \texttt{floor}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{floor}\NormalTok{(}\FloatTok{5.7}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 5
\end{verbatim}

The `next integer' function is ceiling:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ceiling}\NormalTok{(}\FloatTok{5.7}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 6
\end{verbatim}

You can round to the nearest integer by adding 0.5 to the number, then using floor. There is a built-in function for this, but we can easily write one of our own to introduce the notion of function writing. Call it \texttt{rounded}, then define it as a function like this:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{rounded }\OtherTok{=} \ControlFlowTok{function}\NormalTok{(x)\{}\FunctionTok{floor}\NormalTok{(x}\FloatTok{+0.5}\NormalTok{)\}}
\end{Highlighting}
\end{Shaded}

Now we can use the new function:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{rounded}\NormalTok{(}\FloatTok{5.7}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 6
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{rounded}\NormalTok{(}\FloatTok{5.4}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 5
\end{verbatim}

There is an R function called round that you can use by specifying 0 decimal places in the second
argument:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{round}\NormalTok{(}\FloatTok{5.7}\NormalTok{,}\DecValTok{0}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 6
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{round}\NormalTok{(}\FloatTok{5.4}\NormalTok{,}\DecValTok{0}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 5
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{round}\NormalTok{(}\SpecialCharTok{{-}}\FloatTok{5.7}\NormalTok{,}\DecValTok{0}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] -6
\end{verbatim}

\hypertarget{arithmetics}{%
\subsection{Arithmetics}\label{arithmetics}}

The screen prompt in R is a fully functional calculator. You can add and subtract using the obvious \texttt{+} and \texttt{-} symbols, while division is achieved with a forward slash \texttt{/} and multiplication is done by using an asterisk \texttt{*} like this:

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{7} \SpecialCharTok{+} \DecValTok{3} \SpecialCharTok{{-}} \DecValTok{5} \SpecialCharTok{*} \DecValTok{2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0
\end{verbatim}

Notice from this example that multiplication \texttt{(5\ ×\ 2)} is done \emph{before} the additions and subtractions.

Powers (like squared or cube root) use the caret symbol \texttt{ˆ} and are done before multiplication or division, as you can see from this example:

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{3}\SpecialCharTok{\^{}}\DecValTok{2} \SpecialCharTok{/} \DecValTok{2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 4.5
\end{verbatim}

All the mathematical functions you could ever want are here (see Table 2.1).

The \texttt{log} function gives logs to the base e (e = 2.718 282), for which the antilog function is \texttt{exp}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{log}\NormalTok{(}\DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 2.302585
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{exp}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 2.718282
\end{verbatim}

Logs to other bases are possible by providing the \texttt{log} function with a second argument which is the base of the logs you want to take. Suppose you want log to base 3 of 9:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{log}\NormalTok{(}\DecValTok{9}\NormalTok{,}\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 2
\end{verbatim}

The trigonometric functions in R measure angles in radians. A circle is \(2\pi\) radians, and this is \(360^\circ\) , so a right angle (\(90^\circ\)) is \(\pi / 2\) radians. R knows the value of \(\pi\) as \texttt{pi}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pi}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 3.141593
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sin}\NormalTok{(pi}\SpecialCharTok{/}\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{cos}\NormalTok{(pi}\SpecialCharTok{/}\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 6.123234e-17
\end{verbatim}

Notice that the cosine of a right angle does not come out as exactly zero, even though the sine came out as exactly 1. The \texttt{e-017} means `times \(10^{–17}\)'. While this is a very small number, it is clearly not exactly zero.

\hypertarget{modulo-and-integer-quotients}{%
\subsection{Modulo and integer quotients}\label{modulo-and-integer-quotients}}

Integer quotients and remainders are obtained using the notation \texttt{\%/\%} (percent, divide, percent) and \texttt{\%\%} (percent, percent) respectively. Suppose we want to know the integer part of a division: say, how many 13s are there in 119:

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{119} \SpecialCharTok{\%/\%} \DecValTok{13}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 9
\end{verbatim}

Now suppose we wanted to know the remainder (what is left over when 119 is divided by 13): in maths this is known as \textbf{modulo}:

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{119} \SpecialCharTok{\%\%} \DecValTok{13}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 2
\end{verbatim}

Modulo is very useful for testing whether numbers are odd or even: odd numbers have modulo 2 value 1 and even numbers have modulo 2 value 0:

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{9} \SpecialCharTok{\%\%} \DecValTok{2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{8} \SpecialCharTok{\%\%} \DecValTok{2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0
\end{verbatim}

Likewise, you use modulo to test if one number is an exact multiple of some other number. For instance, to find out whether 15 421 is a multiple of 7 (which it is), then ask:

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{15421} \SpecialCharTok{\%\%} \DecValTok{7}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0
\end{verbatim}

\hypertarget{operators}{%
\subsection{Operators}\label{operators}}

R uses the following operator tokens:

\begin{itemize}
\tightlist
\item
  \texttt{+\ -\ *\ /\ \%/\%\ \%\%\ ˆ}: arithmetic (plus, minus, times, divide, integer quotient, modulo, power)
\item
  \texttt{\textgreater{}=\ \textless{}\ \textless{}=\ ==\ !=}: relational (greater than, greater than or equals, less than, less than or equals, equals, not equals)
\item
  \texttt{!\ \&\ \textbar{}}: logical (not, and, or)
\item
  \texttt{\textasciitilde{}}: model formulae (`is modelled as a function of')
\item
  \texttt{=\ -\textgreater{}}: assignment (gets)
\item
  \texttt{\$}: list indexing (the `element name' operator)
\item
  \texttt{:}: create a sequence
\end{itemize}

Several of these operators have different meaning inside model formulae. Thus * indicates the main effects plus interaction (rather than multiplication), : indicates the interaction between two variables (rather than generate a sequence) and ˆ means all interactions up to the indicated power (rather than raise to the power). You will learn more about these ideas in further sessions.

\hypertarget{r-basic-data-types}{%
\section{R Basic Data types}\label{r-basic-data-types}}

In the previous examples we worked with numbers, but variables could be assigned other types of information. There are four basic types:

\begin{itemize}
\item
  \emph{Integers}: integer numbers. If you type an integer in R, as before 3 or 4, it will usually be stored as a double unless explicitly defined;
\item
  \emph{Doubles}: real numbers;
\item
  \emph{Logicals} or \emph{Booleans}: corresponding to \texttt{TRUE} and \texttt{FALSE}, also abbreviated as \texttt{T} and \texttt{F} respectively;
\item
  \emph{Characters}: strings of text surrounded by \texttt{"} (for example \texttt{"hi"}) or by \texttt{\textquotesingle{}} (for example `by');
\item
  \emph{Dates}: date-time expressions in R.
\end{itemize}

\hypertarget{integers}{%
\subsection{Integers}\label{integers}}

Integer vectors exist so that data can be passed to C or Fortran code which expects them, and so that small integer data can be represented exactly and compactly. The range of integers is from −2 000 000 000 to + 2 000 000 000 (\texttt{-2*10ˆ9\ to\ +2*10ˆ9}, which R could portray as \texttt{-2e+09} to \texttt{2e+09}).

Be careful. Do not try to change the class of a vector by using the \texttt{integer} function. Here is a numeric vector of whole numbers that you want to convert into a vector of integers:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{=} \FunctionTok{c}\NormalTok{(}\DecValTok{5}\NormalTok{,}\DecValTok{3}\NormalTok{,}\DecValTok{7}\NormalTok{,}\DecValTok{8}\NormalTok{)}
\FunctionTok{is.integer}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{is.numeric}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

To coerce a numeric vector to be an integers vector we have to use the \texttt{as.integer} function like this:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{=} \FunctionTok{c}\NormalTok{(}\DecValTok{5}\NormalTok{,}\DecValTok{3}\NormalTok{,}\DecValTok{7}\NormalTok{,}\DecValTok{8}\NormalTok{)}
\NormalTok{x }\OtherTok{=} \FunctionTok{as.integer}\NormalTok{(x)}
\FunctionTok{is.integer}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

The integer function works as trunc when applied to real numbers, and removes the imaginary part when
applied to complex numbers:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{as.integer}\NormalTok{(}\FloatTok{5.7}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 5
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{as.integer}\NormalTok{(}\FloatTok{5.7} \SpecialCharTok{{-}}\NormalTok{3i)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Warning: imaginary parts discarded in coercion
\end{verbatim}

\begin{verbatim}
## [1] 5
\end{verbatim}

\hypertarget{integer-vs.-double}{%
\subsection{Integer vs.~Double}\label{integer-vs.-double}}

The two most common numeric classes used in R are integer and double (for double precision floating point numbers). R automatically converts between these two classes when needed for mathematical purposes. As a result, it's feasible to use R and perform analyses for years without specifying these differences.

By default, when you create a numeric vector using the \texttt{c()} function it will produce a vector of double precision numeric values. To create a vector of integers using \texttt{c()} you must specify explicity by placing an L directly after each number.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dbl\_var }\OtherTok{=} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\FloatTok{2.5}\NormalTok{, }\FloatTok{4.5}\NormalTok{)}
\NormalTok{dbl\_var}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1.0 2.5 4.5
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{int\_var }\OtherTok{=} \FunctionTok{c}\NormalTok{(1L, 6L, 10L)}
\NormalTok{int\_var}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  1  6 10
\end{verbatim}

To check whether a vector is made up of integer or double values:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{typeof}\NormalTok{(dbl\_var)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "double"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{typeof}\NormalTok{(int\_var)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "integer"
\end{verbatim}

By default, if you read in data that has no decimal points or you create numeric values using the \texttt{x\ =\ 1:10} method the numeric values will be coded as integer. If you want to change a double to an integer or vice versa you can specify one of the following:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# integers to doubles}
\FunctionTok{as.double}\NormalTok{(int\_var)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  1  6 10
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# doubles to integers}
\FunctionTok{as.integer}\NormalTok{(dbl\_var)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1 2 4
\end{verbatim}

\hypertarget{logical-operators}{%
\subsection{Logical operators}\label{logical-operators}}

A crucial part of computing involves asking questions about things. Is one thing bigger than other? Are two things the same size? Questions can be joined together using words like `and' `or', `not'. Questions in R typically evaluate to \texttt{TRUE} or \texttt{FALSE} but there is the option of a `maybe' (when the answer is not available, \texttt{NA}). In R, \textless{} means `less than', \textgreater{} means `greater than', and ! means `not' (see Table 2.2).

You can use \texttt{T} for TRUE and \texttt{F} for FALSE, but you should be aware that \texttt{T} and \texttt{F} might have been allocated
as variables. So this is obvious:

\begin{Shaded}
\begin{Highlighting}[]
\ConstantTok{TRUE} \SpecialCharTok{==} \ConstantTok{FALSE}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{T }\SpecialCharTok{==}\NormalTok{ F}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE
\end{verbatim}

This, however, is not so obviours:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{T }\OtherTok{=} \DecValTok{0}
\NormalTok{T }\SpecialCharTok{==} \ConstantTok{FALSE}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{F }\OtherTok{=} \DecValTok{1}
\ConstantTok{TRUE} \SpecialCharTok{==}\NormalTok{ F}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

But now, of course, \texttt{T} is not equal to \texttt{F}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{T }\SpecialCharTok{!=}\NormalTok{ F}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

To be sure, always write TRUE and FALSE in full, and never use T or F as variable names.

Maybe you noticed in the last code chunk that, in R, TRUE is coded as \texttt{1} and FALSE as \texttt{0}:

\begin{Shaded}
\begin{Highlighting}[]
\ConstantTok{TRUE} \SpecialCharTok{==} \DecValTok{1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\ConstantTok{FALSE} \SpecialCharTok{==} \DecValTok{0}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

Let's remove the T and F variables to avoid future errors:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{rm}\NormalTok{(}\AttributeTok{list =} \FunctionTok{c}\NormalTok{(T,F))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Warning in rm(list = c(T, F)): object '0' not found
\end{verbatim}

\begin{verbatim}
## Warning in rm(list = c(T, F)): object '1' not found
\end{verbatim}

\hypertarget{real-numbers-equality}{%
\subsection{Real numbers equality}\label{real-numbers-equality}}

You need to be careful in programming when you want to test whether or not two computed numbers are equal. R will assume that you mean `exactly equal', and what that means depends upon machine precision. Most numbers are rounded to an accuracy of 53 binary digits.

Typically therefore, two floating point numbers will not reliably be equal unless they were computed by the same algorithm, and not always even then. You can see this by squaring the square root of 2: surely these values are the same?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{=} \FunctionTok{sqrt}\NormalTok{(}\DecValTok{2}\NormalTok{)}
\NormalTok{x }\SpecialCharTok{*}\NormalTok{ x }\SpecialCharTok{==} \DecValTok{2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE
\end{verbatim}

In fact, they are not the same. We can see by how much the two values differ by subtraction:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\SpecialCharTok{*}\NormalTok{ x }\SpecialCharTok{{-}} \DecValTok{2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 4.440892e-16
\end{verbatim}

So how do we test for equality of real numbers? The best advice is not to do it. Try instead to use the alternatives `less than' with `greater than or equal to', or conversely `greater than' with `less than or equal to'. Then you will not go wrong. Sometimes, however, you really do want to test for equality. In those circumstances, do not use double equals to test for equality, but employ the \texttt{all.equal} function instead.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{=} \FloatTok{0.3} \SpecialCharTok{{-}} \FloatTok{0.2}
\NormalTok{y }\OtherTok{=} \FloatTok{0.1}
\NormalTok{x }\SpecialCharTok{==}\NormalTok{ y}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{all.equal}\NormalTok{(x,y)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

WARNING: Do not use \texttt{all.equal} directly in \texttt{if} expressions. Either use \texttt{isTRUE(all.equal(\ ....))}

\hypertarget{logical-arithmetic}{%
\subsection{Logical arithmetic}\label{logical-arithmetic}}

Arithmetic involving logical expressions is very useful in programming and in selection of variables. The key thing to understand is that logical expressions evaluate to either true or false (represented in R by \texttt{TRUE} or \texttt{FALSE}), and that R can coerce \texttt{TRUE} or \texttt{FALSE} into numerical values: 1 for \texttt{TRUE} and 0 for \texttt{FALSE}. Suppose that x is a sequence from 0 to 6 like this:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{=} \DecValTok{0}\SpecialCharTok{:}\DecValTok{6}
\end{Highlighting}
\end{Shaded}

Now we can ask questions about the contents of the vector called x. Is x less than 4?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\SpecialCharTok{\textless{}} \DecValTok{4}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE
\end{verbatim}

The answer is yes for the first four values (0, 1, 2 and 3) and no for the last three (4, 5 and 6).

Two important logical functions are \texttt{all} and \texttt{any}. They check an entire vector but return a single logical value: \texttt{TRUE} or \texttt{FALSE}. Are all the x values bigger than 0?

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{all}\NormalTok{(x}\SpecialCharTok{\textgreater{}}\DecValTok{0}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE
\end{verbatim}

No.~The first x value is a zero. Are any of the x values negative?

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{any}\NormalTok{(x}\SpecialCharTok{\textless{}}\DecValTok{0}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE
\end{verbatim}

No.~The smallest x value is a zero.

We can use the answers of logical functions in arithmetic. We can count the true values of (\texttt{x\textless{}4}), using \texttt{sum}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sum}\NormalTok{(x}\SpecialCharTok{\textless{}}\DecValTok{4}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 4
\end{verbatim}

We can multiply (x\textless4) by other vectors:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(x}\SpecialCharTok{\textless{}}\DecValTok{4}\NormalTok{) }\SpecialCharTok{*} \FunctionTok{runif}\NormalTok{(}\DecValTok{7}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.3638331 0.9908843 0.4828548 0.2473120 0.0000000 0.0000000 0.0000000
\end{verbatim}

\hypertarget{characters}{%
\subsection{Characters}\label{characters}}

In R, character strings are defined by double quotation marks:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OtherTok{=} \StringTok{"abc"}
\NormalTok{b }\OtherTok{=} \StringTok{"123"}
\end{Highlighting}
\end{Shaded}

Numbers can be coerced to characters (as in b above), but non-numeric characters cannot be coerced to
numbers:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{as.numeric}\NormalTok{(a)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Warning: NAs introduced by coercion
\end{verbatim}

\begin{verbatim}
## [1] NA
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{as.numeric}\NormalTok{(b)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 123
\end{verbatim}

One of the initially confusing things about character strings is the distinction between the length of a character object (a vector), and the numbers of characters (nchar) in the strings that comprise that object.
An example should make the distinction clear:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pets }\OtherTok{=} \FunctionTok{c}\NormalTok{(}\StringTok{"cat"}\NormalTok{,}\StringTok{"dog"}\NormalTok{,}\StringTok{"gerbil"}\NormalTok{,}\StringTok{"terrapin"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Here, \texttt{pets} is a vector comprising four character strings:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{length}\NormalTok{(pets)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 4
\end{verbatim}

and the individual character strings have 3, 3, 6 and 8 characters, respectively:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{nchar}\NormalTok{(pets)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 3 3 6 8
\end{verbatim}

When first defined, character strings are not factors:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{class}\NormalTok{(pets)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "character"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{is.factor}\NormalTok{(pets)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE
\end{verbatim}

We have to coerce this variable to convert it into a factor

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pets }\OtherTok{=} \FunctionTok{as.factor}\NormalTok{(pets)}
\FunctionTok{is.factor}\NormalTok{(pets)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

\hypertarget{characters-letters-vectors}{%
\subsection{Characters: letters vectors}\label{characters-letters-vectors}}

There are built-in vectors in R that contain the 26 letters of the alphabet in lower case (letters) and in upper
case (LETTERS):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{letters}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] "a" "b" "c" "d" "e" "f" "g" "h" "i" "j" "k" "l" "m" "n" "o" "p" "q" "r" "s"
## [20] "t" "u" "v" "w" "x" "y" "z"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{LETTERS}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] "A" "B" "C" "D" "E" "F" "G" "H" "I" "J" "K" "L" "M" "N" "O" "P" "Q" "R" "S"
## [20] "T" "U" "V" "W" "X" "Y" "Z"
\end{verbatim}

To discover which number in the alphabet the letter \texttt{n} is, you can use the \texttt{which} function like this:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{which}\NormalTok{(letters }\SpecialCharTok{==} \StringTok{"n"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 14
\end{verbatim}

For the purposes of printing you might want to suppress the quotes that appear around character strings by default. The function to do this is called noquote:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{noquote}\NormalTok{(letters)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] a b c d e f g h i j k l m n o p q r s t u v w x y z
\end{verbatim}

\hypertarget{characters-pasting-strings-together}{%
\subsection{Characters: Pasting strings together}\label{characters-pasting-strings-together}}

You can amalgamate individual strings into vectors of character information:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{c}\NormalTok{(a,b)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "abc" "123"
\end{verbatim}

This shows that the concatenation produces a vector of two strings. It does not convert two 3-character strings into one 6-character string. The R function to do that is \texttt{paste}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{paste}\NormalTok{(a,b,}\AttributeTok{sep =} \StringTok{""}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "abc123"
\end{verbatim}

The third argument, \texttt{sep=""}, means that the two character strings are to be pasted together without any separator between them: the default for \texttt{paste} is to insert a single blank space, like this:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{paste}\NormalTok{(a,b)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "abc 123"
\end{verbatim}

Notice that you do not lose blanks that are within character strings when you use the \texttt{sep=""} option in
\texttt{paste}.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{paste}\NormalTok{(a,b,}\StringTok{" a longer phrase containing blanks"}\NormalTok{,}\AttributeTok{sep=}\StringTok{""}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "abc123 a longer phrase containing blanks"
\end{verbatim}

If one of the arguments to \texttt{paste} is a vector, each of the elements of the vector is pasted to the specified character string to produce an object of the same length as the vector:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{d }\OtherTok{=} \FunctionTok{c}\NormalTok{(a,b,}\StringTok{"new"}\NormalTok{)}
\NormalTok{e }\OtherTok{=} \FunctionTok{paste}\NormalTok{(d, }\StringTok{"a longer phrase containing blanks"}\NormalTok{)}
\NormalTok{e}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "abc a longer phrase containing blanks"
## [2] "123 a longer phrase containing blanks"
## [3] "new a longer phrase containing blanks"
\end{verbatim}

\hypertarget{characters-extracting-parts-of-strings}{%
\subsection{Characters: Extracting parts of strings}\label{characters-extracting-parts-of-strings}}

We being by defining a phrase:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{phrase }\OtherTok{=} \StringTok{"the quick brown fox jumps over the lazy dog"}
\end{Highlighting}
\end{Shaded}

The function called \texttt{substr} is used to extract substrings of a specified number of characters from within a character string. In the next example we are extracting the first 20 characters from \texttt{phrase} object:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{substr}\NormalTok{(phrase, }\DecValTok{1}\NormalTok{, }\DecValTok{20}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "the quick brown fox "
\end{verbatim}

The second argument in \texttt{substr} is the number of the character at which extraction is to begin (in this case the first), and the third argument is the number of the character at which extraction is to end (in this case, the 20th).

\hypertarget{characters-counting-things-within-strings}{%
\subsection{Characters: Counting things within strings}\label{characters-counting-things-within-strings}}

Counting the total number of characters in a string could not be simpler; just use the \texttt{nchar} function directly, like this:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{nchar}\NormalTok{(phrase)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 43
\end{verbatim}

So there are 43 characters including the blanks between the words. To count the numbers of separate individual characters (including blanks) you need to split up the character string into individual characters (43 of them), using \texttt{strsplit} like this:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{strsplit}\NormalTok{(phrase, }\AttributeTok{split =} \StringTok{""}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [[1]]
##  [1] "t" "h" "e" " " "q" "u" "i" "c" "k" " " "b" "r" "o" "w" "n" " " "f" "o" "x"
## [20] " " "j" "u" "m" "p" "s" " " "o" "v" "e" "r" " " "t" "h" "e" " " "l" "a" "z"
## [39] "y" " " "d" "o" "g"
\end{verbatim}

The \texttt{split\ =\ ""} argument is for determine the character we are going to use to split the entire object. If we use a blank space instead we can separate the string in all the different words:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{strsplit}\NormalTok{(phrase, }\AttributeTok{split =} \StringTok{" "}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [[1]]
## [1] "the"   "quick" "brown" "fox"   "jumps" "over"  "the"   "lazy"  "dog"
\end{verbatim}

The table function can then be used for counting the number of occurrences of each of the characters:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{table}\NormalTok{(}\FunctionTok{strsplit}\NormalTok{(phrase, }\AttributeTok{split =} \StringTok{""}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 
##   a b c d e f g h i j k l m n o p q r s t u v w x y z 
## 8 1 1 1 1 3 1 1 2 1 1 1 1 1 1 4 1 1 2 1 2 2 1 1 1 1 1
\end{verbatim}

This demonstrates that all of the letters of the alphabet were used at least once within our phrase, and that there were eight blanks within the string called phrase. This suggests a way of counting the number of words in a phrase, given that this will always be one more than the number of blanks (so long as there are no leading or trailing blanks in the string):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{nwords }\OtherTok{=} \DecValTok{1}\SpecialCharTok{+}\FunctionTok{table}\NormalTok{(}\FunctionTok{strsplit}\NormalTok{(phrase, }\AttributeTok{split =} \StringTok{""}\NormalTok{))[}\DecValTok{1}\NormalTok{]}
\NormalTok{nwords}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   
## 9
\end{verbatim}

Another solution is to \texttt{sum} all the elements in the table splitting the phrase with a blank space:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sum}\NormalTok{(}\FunctionTok{table}\NormalTok{(}\FunctionTok{strsplit}\NormalTok{(phrase, }\AttributeTok{split =} \StringTok{" "}\NormalTok{)))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 9
\end{verbatim}

\hypertarget{characters-upper--and-lower-case-text}{%
\subsection{Characters: Upper- and lower-case text}\label{characters-upper--and-lower-case-text}}

It is easy to switch between upper and lower cases using the \texttt{toupper} and \texttt{tolower} functions:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{toupper}\NormalTok{(phrase)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{tolower}\NormalTok{(}\FunctionTok{toupper}\NormalTok{(phrase))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "the quick brown fox jumps over the lazy dog"
\end{verbatim}

\hypertarget{dates-and-times}{%
\subsection{Dates and times}\label{dates-and-times}}

The measurement of time is highly idiosyncratic. Successive years start on different days of the week. There are months with different numbers of days. Leap years have an extra day in February. Americans and Britons put the day and the month in different places: 3/4/2006 is March 4 for the former and April 3 for the latter.

All these things mean that working with dates and times is extremely complicated. Fortunately, R has a robust system for dealing with this complexity.

To see how R handles dates and times, have a look at Sys.time():

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{Sys.time}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "2022-01-07 11:46:33 CET"
\end{verbatim}

This description of date and time is strictly hierarchical from left to right: the longest time scale (years) comes first, then month, then day, separated by hyphens, then there is a blank space, followed by the time, with hours first (using the 24-hour clock), then minutes, then seconds, separated by colons. Finally, there is a character string explaining the time zone (CET stands for Central Europe Time)

This representation of the date and time as a character string is user-friendly and familiar, but it is no good for calculations. For that, we need a single numeric representation of the combined date and time. The convention in R is to base this on seconds (the smallest time scale that is accommodated in Sys.time)

The baseline for expressing today's date and time in seconds is 1 January 1970:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{as.numeric}\NormalTok{(}\FunctionTok{Sys.time}\NormalTok{())}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1641552393
\end{verbatim}

This is fine for plotting time series graphs, but it is not much good for computing monthly means (e.g.~is the mean for June significantly different from the July mean?) or daily means (e.g.~is the Monday mean significantly different from the Friday mean?).

To answer questions like these we have to be able to access a broad set of categorical variables associated with the date: the year, the month, the day of the week, and so forth. To accommodate this, R uses the POSIX system for representing times and dates:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{class}\NormalTok{(}\FunctionTok{Sys.time}\NormalTok{())}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "POSIXct" "POSIXt"
\end{verbatim}

You can think of the class \texttt{POSIXct}, with suffix `ct', as continuous time (i.e.~a number of seconds), and
\texttt{POSIXlt}, with suffix `lt', as list time (i.e.~a list of all the various categorical descriptions of the time,
including day of the week and so forth). It is hard to remember these acronyms, but it is well worth making
the effort. Naturally, you can easily convert to one representation to the other:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{time.list }\OtherTok{=} \FunctionTok{as.POSIXlt}\NormalTok{(}\FunctionTok{Sys.time}\NormalTok{())}
\FunctionTok{unlist}\NormalTok{(time.list)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##                sec                min               hour               mday 
## "33.2872455120087"               "46"               "11"                "7" 
##                mon               year               wday               yday 
##                "0"              "122"                "5"                "6" 
##              isdst               zone             gmtoff 
##                "0"              "CET"             "3600"
\end{verbatim}

Here you see the nine components of the list. The time is represented by the number of seconds (\texttt{sec}), minutes (\texttt{min}) and hours (on the 24-hour clock). Next comes the day of the month (\texttt{mday}, starting from 1), then the month of the year (mon, starting at January = 0), then the year (starting at 0 = 1900). The day of the week (\texttt{wday}) is coded from Sunday = 0 to Saturday = 6. The day within the year (\texttt{yday}) is coded from 0 = January 1. Finally, there is a logical variable \texttt{isdst} which asks whether daylight saving time is in operation (0 = FALSE in this case). The ones you are most likely to use include \texttt{year} (to get yearly mean values), \texttt{mon} (to get monthly means) and \texttt{wday} (to get means for the different days of the week).

\hypertarget{dates-and-times-reading-time-data-from-files}{%
\subsection{Dates and times: Reading time data from files}\label{dates-and-times-reading-time-data-from-files}}

It is most likely that your data files contain dates in Excel format, for example 03/09/2014 (a character string showing month/day/year separated by slashes).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df }\OtherTok{=} \FunctionTok{read.csv}\NormalTok{(}\AttributeTok{file =} \StringTok{"Data/boulder{-}precip.csv"}\NormalTok{)}
\FunctionTok{attach}\NormalTok{(df)}
\FunctionTok{head}\NormalTok{(df)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##    ID    DATE PRECIP TEMP
## 1 756 8/21/13    0.1   55
## 2 757 8/26/13    0.1   25
## 3 758 8/27/13    0.1   NA
## 4 759  9/1/13    0.0 -999
## 5 760  9/9/13    0.1   15
## 6 761 9/10/13    1.0   25
\end{verbatim}

To convert a factor or a character string into a POSIXlt object, we employ an important function called `strip time', written \texttt{strptime}.

\hypertarget{dates-and-times-the-strptime-function}{%
\subsection{\texorpdfstring{Dates and times: The \texttt{strptime} function}{Dates and times: The strptime function}}\label{dates-and-times-the-strptime-function}}

To convert a factor or a character string into dates using the strptime function, we provide a format statement enclosed in double quotes to tell R exactly what to expect, in what order, and separated by what kind of symbol. For our present example we have day (as two digits), then slash, then month (as two digits), then slash, then year (without the century, making two digits).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Rdate }\OtherTok{=} \FunctionTok{strptime}\NormalTok{(DATE, }\StringTok{"\%m/\%d/\%y"}\NormalTok{)}
\FunctionTok{class}\NormalTok{(Rdate)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "POSIXlt" "POSIXt"
\end{verbatim}

It is always a good idea at this stage to add the R-formatted date to your dataframe:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df }\OtherTok{=} \FunctionTok{data.frame}\NormalTok{(df, Rdate)}
\FunctionTok{head}\NormalTok{(df)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##    ID    DATE PRECIP TEMP      Rdate
## 1 756 8/21/13    0.1   55 2013-08-21
## 2 757 8/26/13    0.1   25 2013-08-26
## 3 758 8/27/13    0.1   NA 2013-08-27
## 4 759  9/1/13    0.0 -999 2013-09-01
## 5 760  9/9/13    0.1   15 2013-09-09
## 6 761 9/10/13    1.0   25 2013-09-10
\end{verbatim}

Now, at last, we can do things with the date information. We might want the mean value of \texttt{PRECIP} for each day of the week. The name of this object is Rdate\$wday:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{tapply}\NormalTok{(PRECIP,Rdate}\SpecialCharTok{$}\NormalTok{wday,mean)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##         0         1         2         3         4         5         6 
## 0.5000000 0.2250000 0.3666667 1.2000000 9.8000000 0.8000000 0.1000000
\end{verbatim}

It is hard to remember all the format codes for strip time, but they are roughly mnemonic and they are always preceded by a percent symbol. Here is the full list of format components:

\begin{itemize}
\tightlist
\item
  \texttt{\%a}: Abbreviated weekday name
\item
  \texttt{\%A}: Full weekday name
\item
  \texttt{\%b}: Abbreviated month name
\item
  \texttt{\%B}: Full month name
\item
  \texttt{\%c}: Date and time, locale-specific
\item
  \texttt{\%d}: Day of the month as decimal number (01--31)
\item
  \texttt{\%H}: Hours as decimal number (00--23) on the 24-hour clock
\item
  \texttt{\%I}: Hours as decimal number (01--12) on the 12-hour clock
\item
  \texttt{\%j}: Day of year as decimal number (0--366)
\item
  \texttt{\%m}: Month as decimal number (0--11)
\item
  \texttt{\%M}: Minute as decimal number (00--59)
\item
  \texttt{\%p}: AM/PM indicator in the locale
\item
  \texttt{\%S}: Second as decimal number (00--61, allowing for two `leap seconds')
\item
  \texttt{\%U}: Week of the year (00--53) using the first Sunday as day 1 of week 1
\item
  \texttt{\%w}: Weekday as decimal number (0--6, Sunday is 0)
\item
  \texttt{\%W}: Week of the year (00--53) using the first Monday as day 1 of week 1
\item
  \texttt{\%x}: Date, locale-specific
\item
  \texttt{\%X}: Time, locale-specific
\item
  \texttt{\%Y}: Year with century
\item
  \texttt{\%y}: Year without century
\item
  \texttt{\%Z}: Time zone as a character string (output only)
\end{itemize}

There is a useful function called weekdays (note the plural) for turning the day number into the appropriate name:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y }\OtherTok{=} \FunctionTok{strptime}\NormalTok{(}\StringTok{"01/02/2020"}\NormalTok{, }\AttributeTok{format=}\StringTok{"\%d/\%m/\%Y"}\NormalTok{)}
\FunctionTok{weekdays}\NormalTok{(y)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Saturday"
\end{verbatim}

which is converted from:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y}\SpecialCharTok{$}\NormalTok{wday}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 6
\end{verbatim}

because the days of the week are numbered from Sunday = 0.

Here is another kind of date, with years in two-digit form (\texttt{\%y}), and the months as abbreviated names (\texttt{\%b}) using no separators:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{other.dates }\OtherTok{=} \FunctionTok{c}\NormalTok{(}\StringTok{"1jan99"}\NormalTok{, }\StringTok{"2jan05"}\NormalTok{, }\StringTok{"31mar04"}\NormalTok{, }\StringTok{"30jul05"}\NormalTok{)}
\FunctionTok{strptime}\NormalTok{(other.dates, }\StringTok{"\%d\%b\%y"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "1999-01-01 CET"  "2005-01-02 CET"  "2004-03-31 CEST" "2005-07-30 CEST"
\end{verbatim}

Here is yet another possibility with year, then month in full, then week of the year, then day of the week abbreviated, all separated by a single blank space:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{yet.another.date }\OtherTok{=} \FunctionTok{c}\NormalTok{(}\StringTok{"2016 January 2 Mon"}\NormalTok{,}\StringTok{"2017 February 6 Fri"}\NormalTok{,}\StringTok{"2018 March 10 Tue"}\NormalTok{)}
\FunctionTok{strptime}\NormalTok{(yet.another.date,}\StringTok{"\%Y \%B \%W \%a"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "2016-01-11 CET" "2017-02-10 CET" "2018-03-06 CET"
\end{verbatim}

\hypertarget{dates-and-times-summary}{%
\subsection{Dates and times: Summary}\label{dates-and-times-summary}}

The key thing to understand is the difference between the two representations of dates and times in R. They have unfortunately non-memorable names.

\begin{itemize}
\tightlist
\item
  POSIXlt gives a list containing separate vectors for the year, month, day of the week, day within the year, and suchlike. It is very useful as a categorical explanatory variable (e.g.~to get monthly means from data gathered over many years using date\$mon).
\item
  POSIXct gives a vector containing the date and time expressed as a continuous variable that you can use in regression models (it is the number of seconds since the beginning of 1970).
\end{itemize}

\hypertarget{testing-and-coercing}{%
\subsection{Testing and coercing}\label{testing-and-coercing}}

The concepts of membership and coercion may be unfamiliar. Membership relates to the class of an object in R. Coercion changes the class of an object. For instance, a logical variable has class \texttt{logical} and mode logical. This is how we create the variable:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lv }\OtherTok{=} \FunctionTok{c}\NormalTok{(}\ConstantTok{TRUE}\NormalTok{,}\ConstantTok{FALSE}\NormalTok{,}\ConstantTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

We can assess its membership by asking if it is a logical variable using the \texttt{is.logical} function:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{is.logical}\NormalTok{(lv)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

It is not a factor, and so it does not have levels:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{levels}\NormalTok{(lv)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## NULL
\end{verbatim}

But we can coerce it be a two-level factor like this:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fv }\OtherTok{=} \FunctionTok{as.factor}\NormalTok{(lv)}
\NormalTok{fv}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE  FALSE TRUE 
## Levels: FALSE TRUE
\end{verbatim}

We can coerce a logical variable to be numeric: \texttt{TRUE} evaluates to 1 and \texttt{FALSE} evaluates to zero, like this:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{nv }\OtherTok{=} \FunctionTok{as.numeric}\NormalTok{(lv)}
\NormalTok{nv}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1 0 1
\end{verbatim}

In general, the expression \texttt{as(object,\ value)} is the way to coerce an object to a particular class. Membership functions ask \texttt{is.something} and coercion functions say \texttt{as.something}.

Objects have a type, and you can test the type of an object using an is.type function (Table 2.3). For instance, mathematical functions expect numeric input and text-processing functions expect character input. Some types of objects can be coerced into other types. A familiar type of coercion occurs when we interpret the TRUE and FALSE of logical variables as numeric 1 and 0, respectively. Factor levels can be coerced to numbers. Numbers can be coerced into characters, but non-numeric characters cannot be coerced into numbers.

\hypertarget{missing-values-infinity-and-things-that-are-not-numbers}{%
\subsection{Missing values, infinity and things that are not numbers}\label{missing-values-infinity-and-things-that-are-not-numbers}}

Calculations can lead to answers that are plus infinity, represented in R by \texttt{Inf}, or minus infinity, which is represented as \texttt{-Inf}:

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{3}\SpecialCharTok{/}\DecValTok{0}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] Inf
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\SpecialCharTok{{-}}\DecValTok{12}\SpecialCharTok{/}\DecValTok{0}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] -Inf
\end{verbatim}

Calculations involving infinity can be evaluated: for instance,

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{exp}\NormalTok{(}\SpecialCharTok{{-}}\ConstantTok{Inf}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{0}\SpecialCharTok{/}\ConstantTok{Inf}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0
\end{verbatim}

Other calculations, however, lead to quantities that are not numbers. These are represented in R by NaN (`not a number'). Here are some of the classic cases:

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{0}\SpecialCharTok{/}\DecValTok{0}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] NaN
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\ConstantTok{Inf}\SpecialCharTok{{-}}\ConstantTok{Inf}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] NaN
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\ConstantTok{Inf}\SpecialCharTok{/}\ConstantTok{Inf}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] NaN
\end{verbatim}

You need to understand clearly the distinction between \texttt{NaN} and \texttt{NA} (this stands for `not available' and is the missing-value symbol in R).

The function \texttt{is.nan} is provided to check specifically for \texttt{NaN}, and \texttt{is.na} also returns \texttt{TRUE} for \texttt{NaN}. Coercing \texttt{NaN} to logical or integer type gives an \texttt{NA} of the appropriate type. There are built-in tests to check whether a number is finite or infinite:

Missing values in dataframes are a real source of irritation, because they affect the way that model-fitting functions operate and they can greatly reduce the power of the modelling that we would like to do.

You may want to discover which values in a vector are missing. Here is a simple case:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y }\OtherTok{=} \FunctionTok{c}\NormalTok{(}\DecValTok{4}\NormalTok{,}\ConstantTok{NA}\NormalTok{,}\DecValTok{7}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

The missing value question should evaluate to \texttt{FALSE\ TRUE\ FALSE}. There are two ways of looking for missing values that you might think should work, but do not. These involve treating \texttt{NA} as if it was a piece of text and using double equals (==) to test for it. So this does not work:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y }\SpecialCharTok{==} \ConstantTok{NA}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] NA NA NA
\end{verbatim}

because it turns all the values into \texttt{NA} (definitively not what you intended). This does not work either:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y }\SpecialCharTok{==} \StringTok{"NA"}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE    NA FALSE
\end{verbatim}

It correctly reports that the numbers are not character strings, but it returns \texttt{NA} for the missing value itself, rather than \texttt{TRUE} as required. This is how you do it properly:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{is.na}\NormalTok{(y)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE  TRUE FALSE
\end{verbatim}

To produce a vector with the \texttt{NA} stripped out, use subscripts with the not \texttt{!} operator like this:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y[}\SpecialCharTok{!} \FunctionTok{is.na}\NormalTok{(y)]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 4 7
\end{verbatim}

Some functions do not work with their default settings when there are missing values in the data, and \texttt{mean} is a classic example of this:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{=} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{8}\NormalTok{, }\ConstantTok{NA}\NormalTok{)}
\FunctionTok{mean}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] NA
\end{verbatim}

In order to calculate the mean of the non-missing values, you need to specify that the NA are to be removed, using the \texttt{na.rm=TRUE} argument:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{mean}\NormalTok{(x, }\AttributeTok{na.rm =}\NormalTok{ T)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] NA
\end{verbatim}

\hypertarget{r-basic-data-structures}{%
\section{R Basic Data Structures}\label{r-basic-data-structures}}

\hypertarget{vectors}{%
\subsection{Vectors}\label{vectors}}

A vector is a variable with one or more values of the same type (atomic one dimensional arrays). For instance, the numbers of peas in six pods were 4, 7, 6, 5, 6 and 7. The vector called peas is one object of \texttt{length\ =\ 6}. In this case, the class of the object is numeric. The easiest way to create a vector in R is to concatenate (link together) the six values using the concatenate function, \texttt{c}, like this:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{peas }\OtherTok{=} \FunctionTok{c}\NormalTok{(}\DecValTok{4}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{7}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

We can ask all sorts of questions about the vector called peas. For instance, what type of vector is it?

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{class}\NormalTok{(peas)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "numeric"
\end{verbatim}

How big is the vector?

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{length}\NormalTok{(peas)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 6
\end{verbatim}

The great advantage of a vector-based language is that it is very simple to ask quite involved questions that involve all of the values in the vector. These vector functions are often self-explanatory:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{mean}\NormalTok{(peas)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 5.833333
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{max}\NormalTok{(peas)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 7
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{min}\NormalTok{(peas)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 4
\end{verbatim}

Another way to create a vector is to input data from the keyboard using the function called \texttt{scan}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\#peas = scan()}
\end{Highlighting}
\end{Shaded}

The prompt appears \texttt{1:} which means type in the first number of peas (4) then press the return key, then the prompt \texttt{2:} appears (you type in 7) and so on. When you have typed in all six values, and the prompt \texttt{7:} has appeared, you just press the return key to tell R that the vector is now complete. R replies by telling you how many items it has read:

\begin{verbatim}
Read 6 items
\end{verbatim}

As we explained, vectors are single-dimensional arrays. The array indexes range from 1 to the vector length, \texttt{length(v)}. Vectors are also known as atomic vectors.

All elements of the vector are of the same basic type:

\begin{itemize}
\tightlist
\item
  logical
\item
  integer
\item
  double
\item
  character
\item
  complex
\end{itemize}

It has a fixed size that is fixed in its creation. The simplest way to create a vector is by using the combination function \texttt{c(v1,\ v2,...)}. To name the elements of a vector we use the function \texttt{names(v)}. Here you have some different ways to create vectors in R:

\begin{itemize}
\tightlist
\item
  Using the \texttt{vector} function
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Logical Vector}
\NormalTok{v1 }\OtherTok{=} \FunctionTok{vector}\NormalTok{(}\AttributeTok{mode =} \StringTok{\textquotesingle{}logical\textquotesingle{}}\NormalTok{, }\AttributeTok{length =} \DecValTok{4}\NormalTok{)}
\NormalTok{v1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE FALSE FALSE FALSE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Integer vector}
\NormalTok{v2 }\OtherTok{=} \FunctionTok{vector}\NormalTok{(}\AttributeTok{mode =} \StringTok{\textquotesingle{}integer\textquotesingle{}}\NormalTok{, }\AttributeTok{length =} \DecValTok{4}\NormalTok{)}
\NormalTok{v2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0 0 0 0
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Using the ``type'' function
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Numeric vector}
\NormalTok{v3 }\OtherTok{=} \FunctionTok{numeric}\NormalTok{(}\DecValTok{4}\NormalTok{)}
\NormalTok{v3}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0 0 0 0
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Character vector}
\NormalTok{v4 }\OtherTok{=} \FunctionTok{character}\NormalTok{(}\DecValTok{4}\NormalTok{)}
\NormalTok{v4}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "" "" "" ""
\end{verbatim}

\hypertarget{sequences}{%
\subsection{Sequences}\label{sequences}}

An important way of creating vectors is to generate a sequence of numbers. The simplest sequences are in steps of 1, and the colon operator is the simplest way of generating such sequences. All you do is specify the first and last values separated by a colon. Here is a sequence from 0 up to 10:

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{0}\SpecialCharTok{:}\DecValTok{10}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1]  0  1  2  3  4  5  6  7  8  9 10
\end{verbatim}

Here is a sequence from 15 down to 5:

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{15}\SpecialCharTok{:}\DecValTok{5}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] 15 14 13 12 11 10  9  8  7  6  5
\end{verbatim}

To generate a sequence in steps other than 1, you use the seq function. There are various forms of this, of which the simplest has three arguments: \texttt{from}, \texttt{to}, \texttt{by} (the initial value, the final value and the increment). If the initial value is smaller than the final value, the increment should be positive, like this:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{seq}\NormalTok{(}\DecValTok{0}\NormalTok{, }\FloatTok{1.5}\NormalTok{, }\FloatTok{0.1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 1.1 1.2 1.3 1.4 1.5
\end{verbatim}

If the initial value is larger than the final value, the increment should be negative, like this:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{seq}\NormalTok{(}\DecValTok{6}\NormalTok{, }\DecValTok{4}\NormalTok{, }\SpecialCharTok{{-}}\FloatTok{0.2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] 6.0 5.8 5.6 5.4 5.2 5.0 4.8 4.6 4.4 4.2 4.0
\end{verbatim}

In many cases, you want to generate a sequence to match an existing vector in length. Rather than having to figure out the increment that will get from the initial to the final value and produce a vector of exactly the appropriate length, R provides the \texttt{along} and \texttt{length} options. Suppose you have a vector of population sizes:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{N }\OtherTok{=} \FunctionTok{c}\NormalTok{(}\DecValTok{55}\NormalTok{,}\DecValTok{76}\NormalTok{,}\DecValTok{92}\NormalTok{,}\DecValTok{103}\NormalTok{,}\DecValTok{84}\NormalTok{,}\DecValTok{88}\NormalTok{,}\DecValTok{121}\NormalTok{,}\DecValTok{91}\NormalTok{,}\DecValTok{65}\NormalTok{,}\DecValTok{77}\NormalTok{,}\DecValTok{99}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

You need to plot this against a sequence that starts at 0.04 in steps of 0.01:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{seq}\NormalTok{(}\AttributeTok{from=}\FloatTok{0.04}\NormalTok{,}\AttributeTok{by=}\FloatTok{0.01}\NormalTok{,}\AttributeTok{length=}\DecValTok{11}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] 0.04 0.05 0.06 0.07 0.08 0.09 0.10 0.11 0.12 0.13 0.14
\end{verbatim}

But this requires you to figure out the length of \texttt{N}. A simpler method is to use the \texttt{along} argument and specify the vector, \texttt{N}, whose length has to be matched:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{seq}\NormalTok{(}\FloatTok{0.04}\NormalTok{,}\AttributeTok{by=}\FloatTok{0.01}\NormalTok{,}\AttributeTok{along=}\NormalTok{N)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] 0.04 0.05 0.06 0.07 0.08 0.09 0.10 0.11 0.12 0.13 0.14
\end{verbatim}

Alternatively, you can get R to work out the increment (0.01 in this example), by specifying the start and the end values (\texttt{from} and \texttt{to}), and the name of the vector (\texttt{N}) whose length has to be matched:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{seq}\NormalTok{(}\AttributeTok{from=}\FloatTok{0.04}\NormalTok{,}\AttributeTok{to=}\FloatTok{0.14}\NormalTok{,}\AttributeTok{along=}\NormalTok{N)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] 0.04 0.05 0.06 0.07 0.08 0.09 0.10 0.11 0.12 0.13 0.14
\end{verbatim}

If you want a vector made up of sequences of unequal lengths, then use the sequence function. Suppose that most of the five sequences you want to string together are from 1 to 4, but the second one is 1 to 3 and the last one is 1 to 5, then:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sequence}\NormalTok{(}\AttributeTok{nvec =} \FunctionTok{c}\NormalTok{(}\DecValTok{4}\NormalTok{,}\DecValTok{3}\NormalTok{,}\DecValTok{4}\NormalTok{,}\DecValTok{4}\NormalTok{,}\DecValTok{4}\NormalTok{,}\DecValTok{5}\NormalTok{), }\AttributeTok{from =} \DecValTok{1}\NormalTok{, }\AttributeTok{by =} \DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] 1 2 3 4 1 2 3 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 5
\end{verbatim}

\hypertarget{generating-repeats}{%
\subsubsection{Generating repeats}\label{generating-repeats}}

You will often want to generate repeats of numbers or characters, for which the function is \texttt{rep}. The object that is named in the first argument is repeated a number of times as specified in the second argument. At its simplest, we would generate five 9s like this:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{rep}\NormalTok{(}\DecValTok{9}\NormalTok{,}\DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 9 9 9 9 9
\end{verbatim}

You can see the issues involved by a comparison of these three increasingly complicated uses of the \texttt{rep} function:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{rep}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{4}\NormalTok{, }\AttributeTok{times =} \DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1 2 3 4 1 2 3 4
\end{verbatim}

In the simplest case, the entire first argument is repeated (i.e.~the sequence 1 to 4 appears twice).

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{rep}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{4}\NormalTok{, }\AttributeTok{each=}\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1 1 2 2 3 3 4 4
\end{verbatim}

You often want each element of the sequence to be repeated, and this is accomplished with the each argument.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{rep}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{4}\NormalTok{, }\AttributeTok{each =} \DecValTok{2}\NormalTok{, }\AttributeTok{times =} \DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] 1 1 2 2 3 3 4 4 1 1 2 2 3 3 4 4 1 1 2 2 3 3 4 4
\end{verbatim}

Finally, you might want each number repeated and the whole series repeated a certain number of times (here three times).

When each element of the series is to be repeated a different number of times, then the second argument must be a vector of the same length as the vector comprising the first argument (length 4 in this example). So if we want one 1, two 2s, three 3s and four 4s we would write:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{rep}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{4}\NormalTok{, }\DecValTok{1}\SpecialCharTok{:}\DecValTok{4}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] 1 2 2 3 3 3 4 4 4 4
\end{verbatim}

In a more complicated case, there is a different but irregular repeat of each of the elements of the first argument. Suppose that we need four 1s, one 2, four 3s and two 4s. Then we use the concatenation function \texttt{c} to create a vector of length 4 \texttt{c(4,1,4,2)} which will act as the second argument to the \texttt{rep} function:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{rep}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{4}\NormalTok{, }\FunctionTok{c}\NormalTok{(}\DecValTok{4}\NormalTok{,}\DecValTok{1}\NormalTok{,}\DecValTok{4}\NormalTok{,}\DecValTok{2}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] 1 1 1 1 2 3 3 3 3 4 4
\end{verbatim}

Here is the most complex case with character data rather than numbers: each element of the series is repeated an irregular number of times:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{rep}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\StringTok{"cat"}\NormalTok{, }\StringTok{"dog"}\NormalTok{, }\StringTok{"gerbil"}\NormalTok{, }\StringTok{"goldfish"}\NormalTok{, }\StringTok{"rat"}\NormalTok{), }\FunctionTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{1}\NormalTok{,}\DecValTok{3}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] "cat"      "cat"      "dog"      "dog"      "dog"      "gerbil"  
##  [7] "gerbil"   "goldfish" "rat"      "rat"      "rat"
\end{verbatim}

This is the most general, and also the most useful form of the \texttt{rep} function.

\hypertarget{generating-factor-levels}{%
\subsubsection{Generating Factor Levels}\label{generating-factor-levels}}

The function gl (`generate levels') is useful when you want to encode long vectors of factor levels. The syntax for the three arguments is: `up to', `with repeats of', `to total length'. Here is the simplest case where we want factor levels up to 4 with repeats of 3 repeated only once (i.e.~to total length 12):

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gl}\NormalTok{(}\DecValTok{4}\NormalTok{,}\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] 1 1 1 2 2 2 3 3 3 4 4 4
## Levels: 1 2 3 4
\end{verbatim}

Here is the function when we want that whole pattern repeated twice:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gl}\NormalTok{(}\DecValTok{4}\NormalTok{,}\DecValTok{3}\NormalTok{,}\DecValTok{24}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] 1 1 1 2 2 2 3 3 3 4 4 4 1 1 1 2 2 2 3 3 3 4 4 4
## Levels: 1 2 3 4
\end{verbatim}

If you want text for the factor levels, rather than numbers, use labels like this:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Temp }\OtherTok{=} \FunctionTok{gl}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{24}\NormalTok{, }\AttributeTok{labels =} \FunctionTok{c}\NormalTok{(}\StringTok{"Low"}\NormalTok{, }\StringTok{"High"}\NormalTok{))}
\NormalTok{Soft }\OtherTok{=} \FunctionTok{gl}\NormalTok{(}\DecValTok{3}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{24}\NormalTok{, }\AttributeTok{labels =} \FunctionTok{c}\NormalTok{(}\StringTok{"Hard"}\NormalTok{,}\StringTok{"Medium"}\NormalTok{,}\StringTok{"Soft"}\NormalTok{))}
\NormalTok{M.user }\OtherTok{=} \FunctionTok{gl}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{24}\NormalTok{, }\AttributeTok{labels =} \FunctionTok{c}\NormalTok{(}\StringTok{"N"}\NormalTok{, }\StringTok{"Y"}\NormalTok{))}
\NormalTok{Brand }\OtherTok{=} \FunctionTok{gl}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{24}\NormalTok{, }\AttributeTok{labels =} \FunctionTok{c}\NormalTok{(}\StringTok{"X"}\NormalTok{, }\StringTok{"M"}\NormalTok{))}
\FunctionTok{data.frame}\NormalTok{(Temp,Soft,M.user,Brand)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##    Temp   Soft M.user Brand
## 1   Low   Hard      N     X
## 2   Low   Hard      N     M
## 3  High   Hard      N     X
## 4  High   Hard      N     M
## 5   Low   Hard      Y     X
## 6   Low   Hard      Y     M
## 7  High   Hard      Y     X
## 8  High   Hard      Y     M
## 9   Low Medium      N     X
## 10  Low Medium      N     M
## 11 High Medium      N     X
## 12 High Medium      N     M
## 13  Low Medium      Y     X
## 14  Low Medium      Y     M
## 15 High Medium      Y     X
## 16 High Medium      Y     M
## 17  Low   Soft      N     X
## 18  Low   Soft      N     M
## 19 High   Soft      N     X
## 20 High   Soft      N     M
## 21  Low   Soft      Y     X
## 22  Low   Soft      Y     M
## 23 High   Soft      Y     X
## 24 High   Soft      Y     M
\end{verbatim}

\hypertarget{vector-and-subscripts}{%
\subsection{Vector and Subscripts}\label{vector-and-subscripts}}

You will often want to use some but not all of the contents of a vector. To do this, you need to master the use of subscripts (or indices as they are also known). In R, subscripts involve the use of square brackets \texttt{{[}{]}}. Our vector called \texttt{peas} shows the numbers of peas in six pods:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{peas }\OtherTok{=} \FunctionTok{c}\NormalTok{(}\DecValTok{4}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{7}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

The first element of \texttt{peas} is 4, the second 7, and so on. The elements are indexed left to right, 1 to 6. It could not be more straightforward. If we want to extract the fourth element of peas (which you can see is a 5) then this is what we do:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{peas[}\DecValTok{4}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 5
\end{verbatim}

If we want to extract several values (say the 2nd, 3rd and 6th) we use a vector to specify the pods we want as subscripts, either in two stages like this:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pods }\OtherTok{=} \FunctionTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{,}\DecValTok{6}\NormalTok{)}
\NormalTok{peas[pods]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 7 6 7
\end{verbatim}

or in a single step, like this:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{peas[}\FunctionTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{,}\DecValTok{6}\NormalTok{)]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 7 6 7
\end{verbatim}

You can drop values from a vector by using negative subscripts. Here are all but the first values of peas:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{peas[}\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 7 6 5 6 7
\end{verbatim}

Here are all but the last (note the use of the \texttt{length} function to decide what is last):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{peas[}\SpecialCharTok{{-}}\FunctionTok{length}\NormalTok{(peas)]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 4 7 6 5 6
\end{verbatim}

We can use sequences of numbers to extract values from a vector. Here are the first three values of \texttt{peas}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{peas[}\DecValTok{1}\SpecialCharTok{:}\DecValTok{3}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 4 7 6
\end{verbatim}

Here are the even-numbered values of \texttt{peas}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{peas[}\FunctionTok{seq}\NormalTok{(}\DecValTok{2}\NormalTok{,}\FunctionTok{length}\NormalTok{(peas), }\DecValTok{2}\NormalTok{)]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 7 5 7
\end{verbatim}

or alternatively:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{peas[}\DecValTok{1}\SpecialCharTok{:}\FunctionTok{length}\NormalTok{(peas) }\SpecialCharTok{\%\%} \DecValTok{2} \SpecialCharTok{==} \DecValTok{0}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 7 5 7
\end{verbatim}

Using the modulo function \%\% on the sequence 1 to 6 to extract the even numbers 2, 4 and 6. Finally, we can assign some value to the elements between some specific indices

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{peas[}\DecValTok{4}\SpecialCharTok{:}\DecValTok{5}\NormalTok{] }\OtherTok{=} \DecValTok{0}
\NormalTok{peas}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 4 7 6 0 0 7
\end{verbatim}

\hypertarget{classes-of-vector}{%
\subsubsection{Classes of vector}\label{classes-of-vector}}

The vector called \texttt{peas} contained numbers: in the jargon, it is of class numeric. R allows vectors of six types, so long as all of the elements in one vector belong to the same class. The classes are logical, integer, real, complex, string (or character) or raw. You will use numeric, logical and character variables all the time. Engineers and mathematicians will use complex numbers. But you could go a whole career without ever needing to use integer or raw.

\hypertarget{naming-elements-within-vectors}{%
\subsubsection{Naming elements within vectors}\label{naming-elements-within-vectors}}

It is often useful to have the values in a vector labelled in some way. For instance, if our data are counts of 0, 1, 2, . . . occurrences in a vector called \texttt{counts},

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{counts }\OtherTok{=} \FunctionTok{c}\NormalTok{(}\DecValTok{25}\NormalTok{,}\DecValTok{12}\NormalTok{,}\DecValTok{7}\NormalTok{,}\DecValTok{4}\NormalTok{,}\DecValTok{6}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{1}\NormalTok{,}\DecValTok{0}\NormalTok{,}\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

so that there were 25 zeros, 12 ones and so on, it would be useful to name each of the counts with the relevant number 0 to 8:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{names}\NormalTok{(counts) }\OtherTok{=} \DecValTok{0}\SpecialCharTok{:}\DecValTok{8}
\end{Highlighting}
\end{Shaded}

Now when we inspect the vector called counts we see both the names and the frequencies:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{counts}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  0  1  2  3  4  5  6  7  8 
## 25 12  7  4  6  2  1  0  2
\end{verbatim}

Or even access to some element using its name:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{counts[}\StringTok{"0"}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  0 
## 25
\end{verbatim}

\hypertarget{working-with-logical-subscripts}{%
\subsubsection{Working with logical subscripts}\label{working-with-logical-subscripts}}

Take the example of a vector containing the 11 numbers 0 to 10:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{=} \DecValTok{0}\SpecialCharTok{:}\DecValTok{10}
\end{Highlighting}
\end{Shaded}

There are two quite different kinds of things we might want to do with this. We might want to add up the values of the elements:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sum}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 55
\end{verbatim}

Alternatively, we might want to count the elements that passed some logical criterion. Suppose we wanted to know how many of the values were less than 5:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sum}\NormalTok{(x}\SpecialCharTok{\textless{}}\DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 5
\end{verbatim}

You see the distinction. We use the vector function \texttt{sum} in both cases. But \texttt{sum(x)} adds up the values of the x's and \texttt{sum(x\textless{}5)} counts up the number of cases that pass the logical condition `x is less than 5'. This works because of coercion. Logical \texttt{TRUE} has been coerced to numeric 1 and logical \texttt{FALSE} has been coerced to numeric 0.

How do you add up the values of just some of the elements of x? We specify a logical condition, but we do not want to count the number of cases that pass the condition, we want to add up all the values of the cases that pass.

Note that when we counted the number of cases, the counting was applied to the entire vector, using \texttt{sum(x\textless{}5)}. To find the sum of the values of x that are less than 5, we write:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sum}\NormalTok{(x[x}\SpecialCharTok{\textless{}}\DecValTok{5}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 10
\end{verbatim}

Let us look at this in more detail. The logical condition \texttt{x\textless{}5} is either true or false:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x}\SpecialCharTok{\textless{}}\DecValTok{5}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE
\end{verbatim}

You can imagine false as being numeric 0 and true as being numeric 1. Then the vector of subscripts \texttt{{[}x\textless{}5{]}} is five 1s followed by six 0s:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{as.numeric}\NormalTok{(x}\SpecialCharTok{\textless{}}\DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] 1 1 1 1 1 0 0 0 0 0 0
\end{verbatim}

Now imagine multiplying the values of x by the values of the logical vector

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x}\SpecialCharTok{*}\NormalTok{(x}\SpecialCharTok{\textless{}}\DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] 0 1 2 3 4 0 0 0 0 0 0
\end{verbatim}

When the function \texttt{sum} is applied, it gives us the answer we want: the sum of the values of the numbers 0 + 1 + 2 + 3 + 4 = 10.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sum}\NormalTok{(x}\SpecialCharTok{*}\NormalTok{(x}\SpecialCharTok{\textless{}}\DecValTok{5}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 10
\end{verbatim}

This produces the same answer as \texttt{sum(x{[}x\textless{}5{]})}, but is rather less elegant. There are many other ways of indexing elements of a vector using logical operators. We have a vector with values between 0 and 100:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{v }\OtherTok{=} \DecValTok{0}\SpecialCharTok{:}\DecValTok{100}
\end{Highlighting}
\end{Shaded}

We can select all the elements over 30:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{v[v}\SpecialCharTok{\textgreater{}}\DecValTok{30}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1]  31  32  33  34  35  36  37  38  39  40  41  42  43  44  45  46  47  48  49
## [20]  50  51  52  53  54  55  56  57  58  59  60  61  62  63  64  65  66  67  68
## [39]  69  70  71  72  73  74  75  76  77  78  79  80  81  82  83  84  85  86  87
## [58]  88  89  90  91  92  93  94  95  96  97  98  99 100
\end{verbatim}

even, all those over 30 and under or equal 50:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{v[v }\SpecialCharTok{\textgreater{}} \DecValTok{30} \SpecialCharTok{\&}\NormalTok{ v }\SpecialCharTok{\textless{}=} \DecValTok{50}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50
\end{verbatim}

Finally, we can use a specific set of elements to select those from the vector:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{v[ v }\SpecialCharTok{\%in\%} \FunctionTok{c}\NormalTok{(}\DecValTok{10}\NormalTok{, }\DecValTok{20}\NormalTok{, }\DecValTok{30}\NormalTok{)]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 10 20 30
\end{verbatim}

\hypertarget{vector-operations}{%
\subsection{Vector Operations}\label{vector-operations}}

When arithmetic operations are performed between two vectors, R returns another vector with the results of the element by element operation. Boolean operations are also possible. Most functions and operations are ``vectorized''.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{avector }\OtherTok{=} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{)}
\NormalTok{bvector }\OtherTok{=} \FunctionTok{c}\NormalTok{(}\DecValTok{4}\NormalTok{,}\DecValTok{5}\NormalTok{,}\DecValTok{6}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

If we sum up the two vectors the result will be a new vector with the sum of the elements with the same index:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{avector }\SpecialCharTok{+}\NormalTok{ bvector}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 5 7 9
\end{verbatim}

If the vectors are not the same size, R repeats the smallest of them as many times as necessary.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{avector }\SpecialCharTok{+} \DecValTok{1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 2 3 4
\end{verbatim}

Vectors multiplication will follow the same rule, as the multiplication by an scalar:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{avector }\SpecialCharTok{*}\NormalTok{ bvector}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  4 10 18
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{avector}\SpecialCharTok{*}\DecValTok{2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 2 4 6
\end{verbatim}

If we want to multiplicate vectors as one-dimensional matrices (dot product) we need to use a different sintax:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{avector }\SpecialCharTok{\%*\%}\NormalTok{ bvector}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1]
## [1,]   32
\end{verbatim}

In this case we obtained an scalar because the inner product was computed, but we can transpose one of the vectors to obtain the outer product using the \texttt{t()} function:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{avector }\SpecialCharTok{\%*\%} \FunctionTok{t}\NormalTok{(bvector)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2] [,3]
## [1,]    4    5    6
## [2,]    8   10   12
## [3,]   12   15   18
\end{verbatim}

\hypertarget{vector-functions}{%
\subsection{Vector Functions}\label{vector-functions}}

One of R's great strengths is its ability to evaluate functions over entire vectors, thereby avoiding the need for loops and subscripts. The most important vector functions are listed in Table 2.4.

Here is a numeric vector:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y }\OtherTok{=} \FunctionTok{c}\NormalTok{(}\DecValTok{8}\NormalTok{,}\DecValTok{3}\NormalTok{,}\DecValTok{5}\NormalTok{,}\DecValTok{7}\NormalTok{,}\DecValTok{6}\NormalTok{,}\DecValTok{6}\NormalTok{,}\DecValTok{8}\NormalTok{,}\DecValTok{9}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{,}\DecValTok{9}\NormalTok{,}\DecValTok{4}\NormalTok{,}\DecValTok{10}\NormalTok{,}\DecValTok{4}\NormalTok{,}\DecValTok{11}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Some vector functions produce a single number:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{mean}\NormalTok{(y)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 6.333333
\end{verbatim}

Others produce two numbers:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{range}\NormalTok{(y)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  2 11
\end{verbatim}

here showing that the minimum was 2 and the maximum was 11. Other functions produce several numbers:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{fivenum}\NormalTok{(y)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  2.0  4.0  6.0  8.5 11.0
\end{verbatim}

This is Tukey's famous five-number summary: the minimum, the lower hinge, the median, the upper hinge and the maximum.

Perhaps the single most useful vector function in R is \texttt{table}. You need to see it in action to appreciate just how good it is. Here is a huge vector called \texttt{counts} containing 10 000 random integers between 0 and 10 from a uniform distribution

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{counts }\OtherTok{=} \FunctionTok{sample}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{, }\AttributeTok{size =} \DecValTok{10000}\NormalTok{, }\AttributeTok{replace =} \ConstantTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Here is a look at the first 30 values in counts:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{counts[}\DecValTok{1}\SpecialCharTok{:}\DecValTok{30}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] 10  7  9  7  3  4  7  1  5  7  1  3  4  1  6  5  7  5 10  5  6  8  2  3  3
## [26]  7  1  8  2  5
\end{verbatim}

The question is this: how many zeros are there in the whole vector of 10 000 numbers, how many 1s, and so on right up to the largest value within counts? A formidable task for you or me, but for R it is just:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{table}\NormalTok{(counts)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## counts
##    1    2    3    4    5    6    7    8    9   10 
## 1017  986  989  987  974  978  997 1022 1053  997
\end{verbatim}

\hypertarget{tapply-function}{%
\subsubsection{\texorpdfstring{\texttt{tapply} function}{tapply function}}\label{tapply-function}}

One of the most important functions in all of R is tapply. It does not sound like much from the name, but you will use it time and again for calculating means, variances, sample sizes, minima and maxima. With weather data, for instance, we might want the 12 monthly mean temperatures rather than the whole-year average. We have a response variable, temperature, and a categorical explanatory variable, month:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{temperature }\OtherTok{=} \FunctionTok{read.csv}\NormalTok{(}\StringTok{"./Data/city\_temperature.csv"}\NormalTok{)}
\FunctionTok{attach}\NormalTok{(temperature)}
\FunctionTok{names}\NormalTok{(temperature)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Region"         "Country"        "State"          "City"          
## [5] "Month"          "Day"            "Year"           "AvgTemperature"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{tapply}\NormalTok{(AvgTemperature, Month, mean)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##        1        2        3        4        5        6        7        8 
## 30.90471 33.50187 38.67561 46.13972 52.81063 59.37346 63.68533 63.12633 
##        9       10       11       12 
## 55.79678 47.70037 38.83678 30.47562
\end{verbatim}

It is easy to apply other functions in the same way: here are the monthly variances

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{tapply}\NormalTok{(AvgTemperature,Month,var)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##         1         2         3         4         5         6         7         8 
##  694.4614  633.2653  697.8510  767.8669  973.1084 1042.9352  980.9215  948.5103 
##         9        10        11        12 
##  882.3228  812.8217  785.9120  979.5516
\end{verbatim}

and the monthly max

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{tapply}\NormalTok{(AvgTemperature,Month,max)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##     1     2     3     4     5     6     7     8     9    10    11    12 
##  66.5  68.6  74.8  81.1  88.7 102.5 100.4 101.0  91.4  83.3  74.5  70.0
\end{verbatim}

If R does not have a built in function to do what you want, then you can easily write your own. Here, for instance, is a function to calculate the standard error of each mean (these are called anonymous functions in R, because they are unnamed):

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{tapply}\NormalTok{(AvgTemperature, Month,  }\ControlFlowTok{function}\NormalTok{(x) }\FunctionTok{sqrt}\NormalTok{(}\FunctionTok{var}\NormalTok{(x)}\SpecialCharTok{/}\FunctionTok{length}\NormalTok{(x)))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##         1         2         3         4         5         6         7         8 
## 0.1446289 0.1446299 0.1449792 0.1545970 0.1730663 0.1835656 0.1751918 0.1723541 
##         9        10        11        12 
## 0.1689770 0.1595505 0.1594831 0.1746138
\end{verbatim}

The \texttt{tapply} function is very flexible. It can produce multi-dimensional tables simply by replacing the one categorical variable (\texttt{Month}) by a \texttt{list} of categorical variables. Here are the monthly means calculated separately for each year, as specified by \texttt{list(Year,Month)}. The variable you name first in the list (\texttt{Year}) will appear as the row of the results table and the second will appear as the columns (\texttt{Month}):

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{tapply}\NormalTok{(AvgTemperature,}\FunctionTok{list}\NormalTok{(Year,Month),mean)[,}\DecValTok{1}\SpecialCharTok{:}\DecValTok{6}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##             1        2        3        4        5        6
## 200        NA       NA       NA       NA       NA       NA
## 201        NA       NA       NA       NA       NA       NA
## 1995 22.59082 31.34159 31.27190 37.80881 44.95441 50.55163
## 1996 18.08208 19.10475 25.95685 35.57652 43.73778 50.99244
## 1997 25.79462 30.60540 33.23219 39.33719 46.48344 53.38289
## 1998 27.00767 29.15087 32.80416 40.43363 48.75534 54.22356
## 1999 26.07477 30.85468 35.46308 42.24148 47.33011 54.67496
## 2000 25.05871 32.17456 35.57957 46.41452 53.99290 59.49000
## 2001 33.14029 33.28294 40.46552 43.84822 52.21448 54.50970
## 2002 30.88344 36.58143 34.60559 43.68704 54.10151 38.15141
## 2003 28.42867 26.63484 36.12358 40.95430 48.39011 56.53770
## 2004 27.87397 31.66127 37.06129 44.72202 52.05897 62.11159
## 2005 35.04232 31.47177 38.67312 48.97246 55.90238 63.44032
## 2006 29.23203 32.16905 38.62158 47.16979 53.53997 60.69301
## 2007 40.09750 38.35009 43.29540 52.09333 57.68266 65.78025
## 2008 37.41471 40.13305 42.38426 50.03049 58.44178 64.35772
## 2009 33.20831 35.33643 42.16637 47.20308 59.01427 64.22975
## 2010 25.41574 30.35200 37.11865 45.17927 51.46735 60.83972
## 2011 32.77954 33.30758 40.97986 50.51585 57.07600 62.27951
## 2012 35.67784 30.45354 45.51511 49.80105 58.81749 60.94851
## 2013 34.17175 35.80811 37.82493 49.38892 57.52337 64.08892
## 2014 37.04133 35.72973 46.33086 52.17991 57.58596 64.26360
## 2015 36.87864 36.98958 43.73880 50.28946 57.90881 64.77072
## 2016 34.73095 41.22544 38.58570 50.50559 53.44534 65.47865
## 2017 30.96312 39.02403 46.69494 48.59640 58.65650 66.35387
## 2018 34.86553 32.96776 39.32351 53.77184 61.45348 65.32789
## 2019 30.31927 40.28722 45.52725 46.30789 34.89703 66.84974
## 2020 38.31691 42.69720 44.17044 50.36505 53.66778       NA
\end{verbatim}

The subscripts {[},1:6{]} simply restrict the output to the first six months.

There is just one thing about \texttt{tapply} that might confuse you. If you try to apply a function that has built-in protection against missing values, then \texttt{tapply} may not do what you want, producing \texttt{NA} instead of the numerical answer. This is most likely to happen with the mean function because its default is to produce NA when there are one or more missing values. The remedy is to provide an extra argument to \texttt{tapply}, specifying that you want to see the average of the non-missing values. Use \texttt{na.rm=TRUE} to remove the missing values like this:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{tapply}\NormalTok{(AvgTemperature,Year,mean,}\AttributeTok{na.rm=}\ConstantTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##       200       201      1995      1996      1997      1998      1999      2000 
## -99.00000 -99.00000  38.63447  36.53759  41.29181  40.93638  42.25044  46.42167 
##      2001      2002      2003      2004      2005      2006      2007      2008 
##  44.92223  43.83141  43.50428  47.62057  48.85940  48.09095  50.78713  51.06084 
##      2009      2010      2011      2012      2013      2014      2015      2016 
##  49.92104  47.09856  49.96520  49.11578  51.17017  52.33811  51.77581  50.39242 
##      2017      2018      2019      2020 
##  51.68254  50.20742  49.60530  44.80030
\end{verbatim}

You might want to trim some of the extreme values before calculating the mean (the arithmetic mean is famously sensitive to outliers). The \texttt{trim} option allows you to specify the fraction of the data (between 0 and 0.5) that you want to be omitted from the left- and right-hand tails of the sorted vector of values before computing the mean of the central values:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{tapply}\NormalTok{(AvgTemperature,Year,mean,}\AttributeTok{trim=}\FloatTok{0.2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##       200       201      1995      1996      1997      1998      1999      2000 
## -99.00000 -99.00000  49.73343  48.49846  50.11555  50.42651  51.01058  52.25806 
##      2001      2002      2003      2004      2005      2006      2007      2008 
##  51.33122  51.84361  50.82469  51.57898  51.90048  52.28212  52.73041  52.23925 
##      2009      2010      2011      2012      2013      2014      2015      2016 
##  52.62449  50.94259  52.62774  51.74824  51.57276  53.23475  52.13158  52.07910 
##      2017      2018      2019      2020 
##  52.29157  53.30457  52.35184  44.95409
\end{verbatim}

\hypertarget{aggregate-function}{%
\subsubsection{\texorpdfstring{\texttt{aggregate} function}{aggregate function}}\label{aggregate-function}}

Suppose that we have two response variables (\texttt{y} and \texttt{z}) and two explanatory variables (\texttt{x} and \texttt{w}) that we might want to use to summarize functions like mean or variance of \texttt{y} and/or \texttt{z}. The \texttt{aggregate} function has a formula method which allows elegant summaries of four kinds:

\begin{itemize}
\tightlist
\item
  one to one: \texttt{aggregate(y\ \textasciitilde{}\ x,\ mean)}
\item
  one to many: \texttt{aggregate(y\ \textasciitilde{}\ x\ +\ w,\ mean)}
\item
  many to one: \texttt{aggregate(cbind(y,z)\ \textasciitilde{}\ x,\ mean)}
\item
  many to many: \texttt{aggregate(cbind(y,z)\ \textasciitilde{}\ x\ +\ w,\ mean)}
\end{itemize}

Here is an example using a dataframe with many categorical and continuous variables:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df }\OtherTok{=} \FunctionTok{read.csv}\NormalTok{(}\StringTok{"./Data/bank.csv"}\NormalTok{, }\AttributeTok{sep =} \StringTok{";"}\NormalTok{, }\AttributeTok{stringsAsFactors =} \ConstantTok{TRUE}\NormalTok{)}
\FunctionTok{head}\NormalTok{(df)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   age         job marital         education default housing    loan   contact
## 1  30 blue-collar married          basic.9y      no     yes      no  cellular
## 2  39    services  single       high.school      no      no      no telephone
## 3  25    services married       high.school      no     yes      no telephone
## 4  38    services married          basic.9y      no unknown unknown telephone
## 5  47      admin. married university.degree      no     yes      no  cellular
## 6  32    services  single university.degree      no      no      no  cellular
##   month day_of_week duration campaign pdays previous    poutcome emp.var.rate
## 1   may         fri      487        2   999        0 nonexistent         -1.8
## 2   may         fri      346        4   999        0 nonexistent          1.1
## 3   jun         wed      227        1   999        0 nonexistent          1.4
## 4   jun         fri       17        3   999        0 nonexistent          1.4
## 5   nov         mon       58        1   999        0 nonexistent         -0.1
## 6   sep         thu      128        3   999        2     failure         -1.1
##   cons.price.idx cons.conf.idx euribor3m nr.employed  y
## 1         92.893         -46.2     1.313      5099.1 no
## 2         93.994         -36.4     4.855      5191.0 no
## 3         94.465         -41.8     4.962      5228.1 no
## 4         94.465         -41.8     4.959      5228.1 no
## 5         93.200         -42.0     4.191      5195.8 no
## 6         94.199         -37.5     0.884      4963.6 no
\end{verbatim}

Here is one-to-one use of \texttt{aggregate} to find mean the \texttt{cons.price.idx} in the different \texttt{marital} samples:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{aggregate}\NormalTok{(cons.price.idx }\SpecialCharTok{\textasciitilde{}}\NormalTok{ marital, df, mean)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##    marital cons.price.idx
## 1 divorced       93.60055
## 2  married       93.59904
## 3   single       93.52997
## 4  unknown       93.53755
\end{verbatim}

Here is a one-to-many use to look at the interaction between \texttt{marital} and \texttt{contact}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{aggregate}\NormalTok{(cons.price.idx }\SpecialCharTok{\textasciitilde{}}\NormalTok{ marital }\SpecialCharTok{+}\NormalTok{ contact, df, mean)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##    marital   contact cons.price.idx
## 1 divorced  cellular       93.34316
## 2  married  cellular       93.32591
## 3   single  cellular       93.34077
## 4  unknown  cellular       93.27671
## 5 divorced telephone       94.04743
## 6  married telephone       94.03531
## 7   single telephone       93.99391
## 8  unknown telephone       93.99400
\end{verbatim}

Finally, here is a many-to-many use to find mean \texttt{euribor3m} as well as mean \texttt{cons.price.idx} for the interaction between \texttt{marital} and \texttt{contact}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{aggregate}\NormalTok{(}\FunctionTok{cbind}\NormalTok{(cons.price.idx, euribor3m) }\SpecialCharTok{\textasciitilde{}}\NormalTok{ marital }\SpecialCharTok{+}\NormalTok{ contact, df, mean)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##    marital   contact cons.price.idx euribor3m
## 1 divorced  cellular       93.34316  3.155212
## 2  married  cellular       93.32591  3.206862
## 3   single  cellular       93.34077  2.936846
## 4  unknown  cellular       93.27671  3.282143
## 5 divorced telephone       94.04743  4.665497
## 6  married telephone       94.03531  4.561857
## 7   single telephone       93.99391  4.372266
## 8  unknown telephone       93.99400  4.858000
\end{verbatim}

\hypertarget{parallel-minima-and-maxima}{%
\subsubsection{Parallel minima and maxima}\label{parallel-minima-and-maxima}}

Here are three vectors of the same length, \texttt{x}, \texttt{y} and \texttt{z}. The parallel minimum function, \texttt{pmin}, finds the minimum from any one of the three variables for each subscript, and produces a vector as its result (of length equal to the longest of \texttt{x}, \texttt{y}, or \texttt{z}):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{=} \FunctionTok{runif}\NormalTok{(}\DecValTok{6}\NormalTok{)}
\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.8711427 0.4030111 0.5606412 0.2872073 0.2260351 0.1647041
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y }\OtherTok{=} \FunctionTok{runif}\NormalTok{(}\DecValTok{6}\NormalTok{)}
\NormalTok{y}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.9675614 0.2442290 0.9152520 0.2996409 0.5876295 0.9767194
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{z }\OtherTok{=} \FunctionTok{runif}\NormalTok{(}\DecValTok{6}\NormalTok{)}
\NormalTok{z}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.6375336 0.9140610 0.3177856 0.4496507 0.6497485 0.2029685
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{pmin}\NormalTok{(x,y,z)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.6375336 0.2442290 0.3177856 0.2872073 0.2260351 0.1647041
\end{verbatim}

\hypertarget{summary-by-groups-with-tapply}{%
\subsubsection{\texorpdfstring{Summary by groups with \texttt{tapply}}{Summary by groups with tapply}}\label{summary-by-groups-with-tapply}}

The vector function \texttt{tapply} is one of the most important and useful vector functions to master. The `t' stands for `table' and the idea is to apply a function to produce a table from the values in the vector, based on one or more grouping variables (often the grouping is by factor levels). This sounds much more complicated than it really is:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{daphnia }\OtherTok{=} \FunctionTok{read.table}\NormalTok{(}\StringTok{"./Data/daphnia.txt"}\NormalTok{, }\AttributeTok{header =} \ConstantTok{TRUE}\NormalTok{)}
\FunctionTok{attach}\NormalTok{(daphnia)}
\FunctionTok{names}\NormalTok{(daphnia)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Growth.rate" "Water"       "Detergent"   "Daphnia"
\end{verbatim}

The response variable is \texttt{Growth.rate} and the other three variables are factors. Suppose we want the mean growth rate for each detergent:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{tapply}\NormalTok{(Growth.rate, Detergent, mean)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   BrandA   BrandB   BrandC   BrandD 
## 3.884832 4.010044 3.954512 3.558231
\end{verbatim}

This produces a table with four entries, one for each level of the factor called \texttt{Detergent}.

To produce a two-dimensional table we put the two grouping variables in a list. Here we calculate the median growth rate for water type and daphnia clone:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{tapply}\NormalTok{(Growth.rate,}\FunctionTok{list}\NormalTok{(Water,Daphnia),median)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##        Clone1   Clone2   Clone3
## Tyne 2.874053 3.908644 4.618288
## Wear 2.590373 5.532726 4.302642
\end{verbatim}

The first variable in the list creates the rows of the table and the second the columns.

\hypertarget{addresses-within-vectors}{%
\subsubsection{Addresses within vectors}\label{addresses-within-vectors}}

There is an important function called \texttt{which} for finding addresses within vectors. The vector y looks like this:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y }\OtherTok{=} \FunctionTok{c}\NormalTok{(}\DecValTok{8}\NormalTok{,}\DecValTok{3}\NormalTok{,}\DecValTok{5}\NormalTok{,}\DecValTok{7}\NormalTok{,}\DecValTok{6}\NormalTok{,}\DecValTok{6}\NormalTok{,}\DecValTok{8}\NormalTok{,}\DecValTok{9}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{,}\DecValTok{9}\NormalTok{,}\DecValTok{4}\NormalTok{,}\DecValTok{10}\NormalTok{,}\DecValTok{4}\NormalTok{,}\DecValTok{11}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Suppose we wanted to know which elements of \texttt{y} contained values bigger than 5. We type:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{which}\NormalTok{(y}\SpecialCharTok{\textgreater{}}\DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  1  4  5  6  7  8 11 13 15
\end{verbatim}

Notice that the answer to this enquiry is a set of subscripts. We do not use subscripts inside the \texttt{which} function itself. The function is applied to the whole array. To see the values of y that are larger than 5, we just type:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y[y}\SpecialCharTok{\textgreater{}}\DecValTok{5}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  8  7  6  6  8  9  9 10 11
\end{verbatim}

\hypertarget{finding-closest-values}{%
\subsubsection{Finding closest values}\label{finding-closest-values}}

Finding the value in a vector that is closest to a specified value is straightforward using which. The vector \texttt{x} contains 1000 random numbers from a normal distribution with mean = 100 and standard deviation = 10:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{2020}\NormalTok{)}
\NormalTok{x }\OtherTok{=} \FunctionTok{rnorm}\NormalTok{(}\DecValTok{1000}\NormalTok{, }\DecValTok{100}\NormalTok{, }\DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Here, we want to find the value of \texttt{x} that is closest to 108.0. The logic is to work out the difference between 108 and each of the 1000 random numbers, then find which of these differences is the smallest. This is what the R code looks like:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{which}\NormalTok{(}\FunctionTok{abs}\NormalTok{(x}\DecValTok{{-}108}\NormalTok{) }\SpecialCharTok{==} \FunctionTok{min}\NormalTok{(}\FunctionTok{abs}\NormalTok{(x}\DecValTok{{-}108}\NormalTok{)))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 626
\end{verbatim}

The closest value to 108.0 is in location 626 within \texttt{x}. But just how close to 108.0 is this 626 value? We use 626 as a subscript on \texttt{x} to find this out:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x[}\DecValTok{626}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 108.0139
\end{verbatim}

\hypertarget{sorting-ranking-and-ordering}{%
\subsubsection{Sorting, Ranking and Ordering}\label{sorting-ranking-and-ordering}}

These three related concepts are important, and one of them (order) is difficult to understand at the beginning. Let us take a simple example:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{2020}\NormalTok{)}
\NormalTok{houses\_prices }\OtherTok{=} \FunctionTok{runif}\NormalTok{(}\DecValTok{10}\NormalTok{, }\DecValTok{150}\NormalTok{, }\DecValTok{500}\NormalTok{)}
\NormalTok{houses\_prices}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] 376.4160 287.9790 366.4756 316.9119 197.6340 173.5845 195.2034 287.5913
##  [9] 150.9039 367.0721
\end{verbatim}

We apply the three different functions to the vector called \texttt{houses\_price}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ranks }\OtherTok{=} \FunctionTok{rank}\NormalTok{(houses\_prices)}
\NormalTok{ranks}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] 10  6  8  7  4  2  3  5  1  9
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sorted }\OtherTok{=} \FunctionTok{sort}\NormalTok{(houses\_prices)}
\NormalTok{sorted}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] 150.9039 173.5845 195.2034 197.6340 287.5913 287.9790 316.9119 366.4756
##  [9] 367.0721 376.4160
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ordered }\OtherTok{=} \FunctionTok{order}\NormalTok{(houses\_prices)}
\NormalTok{ordered}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1]  9  6  7  5  8  2  4  3 10  1
\end{verbatim}

Let's create a data frame to observe the data easily:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{view }\OtherTok{=} \FunctionTok{data.frame}\NormalTok{(houses\_prices, ranks, sorted, ordered)}
\NormalTok{view}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##    houses_prices ranks   sorted ordered
## 1       376.4160    10 150.9039       9
## 2       287.9790     6 173.5845       6
## 3       366.4756     8 195.2034       7
## 4       316.9119     7 197.6340       5
## 5       197.6340     4 287.5913       8
## 6       173.5845     2 287.9790       2
## 7       195.2034     3 316.9119       4
## 8       287.5913     5 366.4756       3
## 9       150.9039     1 367.0721      10
## 10      367.0721     9 376.4160       1
\end{verbatim}

\textbf{RANK}: The prices themselves are in no particular sequence. The \texttt{ranks} column contains the value that is the rank of the particular data point (value of \texttt{Price}), where 1 is assigned to the lowest data point and \texttt{length(Price)} -- here 10 -- is assigned to the highest data point.

\textbf{SORT}: The sorted vector is very straightforward. It contains the values of \texttt{Price} sorted into ascending order. If you want to sort into descending order, use the reverse order function \texttt{rev} like this:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{rev}\NormalTok{(}\FunctionTok{sort}\NormalTok{(houses\_prices))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] 376.4160 367.0721 366.4756 316.9119 287.9790 287.5913 197.6340 195.2034
##  [9] 173.5845 150.9039
\end{verbatim}

\textbf{ORDER}: This is the most important of the three functions, and the hardest to understand. The numbers in this column are subscripts between 1 and 10. The order function returns an integer vector containing the permutation that will sort the input into ascending order.

Using \texttt{order} with subscripts is a much safer option than using \texttt{sort}, because with \texttt{sort} the values of the response variable and the explanatory variables could be uncoupled with potentially disastrous results if this is not realized at the time that modelling was carried out.

Imagine we have another variable that is the location of the house represented by a letter:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{2020}\NormalTok{)}
\NormalTok{location }\OtherTok{=} \FunctionTok{sample}\NormalTok{(LETTERS, }\DecValTok{10}\NormalTok{)}
\NormalTok{location}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] "L" "W" "V" "A" "Q" "D" "J" "F" "X" "M"
\end{verbatim}

We can use the \texttt{order} function to organize the location of the houses like this:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{location[}\FunctionTok{order}\NormalTok{(houses\_prices)]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] "X" "D" "J" "Q" "F" "W" "A" "V" "M" "L"
\end{verbatim}

\hypertarget{unique-and-duplicated-functions}{%
\subsubsection{\texorpdfstring{\texttt{unique} and \texttt{duplicated} functions}{unique and duplicated functions}}\label{unique-and-duplicated-functions}}

The difference is best seen with a simple example. Here is a vector of names:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{names }\OtherTok{=} \FunctionTok{c}\NormalTok{(}\StringTok{"Williams"}\NormalTok{,}\StringTok{"Jones"}\NormalTok{,}\StringTok{"Smith"}\NormalTok{,}\StringTok{"Williams"}\NormalTok{,}\StringTok{"Jones"}\NormalTok{,}\StringTok{"Williams"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

We can see how many times each name appears using table:We can see how many times each name appears using \texttt{table}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{table}\NormalTok{(names)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## names
##    Jones    Smith Williams 
##        2        1        3
\end{verbatim}

It is clear that the vector contains just three different names. The function called \texttt{unique} extracts these three unique names, creating a vector of length 3, unsorted, in the order in which the names are encountered in the vector:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{unique}\NormalTok{(names)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Williams" "Jones"    "Smith"
\end{verbatim}

In contrast, the function called \texttt{duplicated} produces a vector, of the same length as the vector of names, containing the logical values either \texttt{FALSE} or \texttt{TRUE}, depending upon whether or not that name has appeared already (reading from the left). You need to see this in action to understand what is happening, and why it might be useful:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{duplicated}\NormalTok{(names)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE FALSE FALSE  TRUE  TRUE  TRUE
\end{verbatim}

The first three names are not duplicated (\texttt{FALSE}), but the last three are all duplicated (\texttt{TRUE}). We can mimic the \texttt{unique} function by using this vector as subscripts like this:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{names[}\SpecialCharTok{!}\FunctionTok{duplicated}\NormalTok{(names)]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Williams" "Jones"    "Smith"
\end{verbatim}

There you have it: if you want a shortened vector, containing only the unique values in names, then use \texttt{unique}, but if you want a vector of the same length as names then use \texttt{duplicated}.

\hypertarget{sets}{%
\subsection{Sets}\label{sets}}

There are three essential functions for manipulating sets. The principles are easy to see if we work with an example of two sets:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{setA }\OtherTok{=} \FunctionTok{c}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\StringTok{"b"}\NormalTok{, }\StringTok{"c"}\NormalTok{, }\StringTok{"d"}\NormalTok{, }\StringTok{"e"}\NormalTok{)}
\NormalTok{setB }\OtherTok{=} \FunctionTok{c}\NormalTok{(}\StringTok{"d"}\NormalTok{, }\StringTok{"e"}\NormalTok{, }\StringTok{"f"}\NormalTok{, }\StringTok{"g"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

The \textbf{union} of two sets is everything in the two sets taken together, but counting elements only once that are common to both sets:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{union}\NormalTok{(setA, setB)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "a" "b" "c" "d" "e" "f" "g"
\end{verbatim}

The \textbf{intersection} of two sets is the material that they have in common:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{intersect}\NormalTok{(setA, setB)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "d" "e"
\end{verbatim}

Note, however, that the \textbf{difference} between two sets is order-dependent. It is the material that is in the first named set, that is not in the second named set. Thus \texttt{setdiff(A,B)} gives a different answer than \texttt{setdiff(B,A)}. For our example:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{setdiff}\NormalTok{(setA, setB)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "a" "b" "c"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{setdiff}\NormalTok{(setB, setA)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "f" "g"
\end{verbatim}

There is also a built-in function \texttt{setequal} for testing if two sets are equal:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{setequal}\NormalTok{(setA, setB)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE
\end{verbatim}

You can use \texttt{\%in\%} for comparing sets. The result is a logical vector whose length matches the vector on the left:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{setA }\SpecialCharTok{\%in\%}\NormalTok{ setB}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE FALSE FALSE  TRUE  TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{setB }\SpecialCharTok{\%in\%}\NormalTok{ setA}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  TRUE  TRUE FALSE FALSE
\end{verbatim}

\hypertarget{factors}{%
\subsection{Factors}\label{factors}}

Conceptually, factors are variables in R which take on a limited number of different values; such variables are often refered to as categorical variables. One of the most important uses of factors is in statistical modeling; since categorical variables enter into statistical models differently than continuous variables, storing data as factors ensures that the modeling functions will treat such data correctly.

Factors in R are stored as a vector of integer values with a corresponding set of character values to use when the factor is displayed. The \texttt{factor} function is used to create a factor. The only required argument to \texttt{factor} is a vector of values which will be returned as a vector of factor values. Both numeric and character variables can be made into factors, but the factor levels will always be character values. You can see the possible levels for a factor through the \texttt{levels} command.

To change the order in which the levels will be displayed from their default sorted order, the \texttt{levels=} argument can be given a vector of all the possible values of the variable in the order you desire. If the ordering should also be used when performing comparisons, use the optional \texttt{ordered=TRUE} argument. In this case, the factor is known as an ordered factor.

\emph{Reminder:}

\begin{itemize}
\item
  \textbf{Categorical variable}: one that can take a limited number of possible values (categories). Examples of categorical variables: gender of a person, nationality\ldots{}

  \begin{itemize}
  \tightlist
  \item
    Categorical nominal variable: one that does not have a pre-established order.
  \item
    Categorical ordinal variable: that which has an established order.
  \end{itemize}
\item
  \textbf{Continuous variable}: one that can take an infinite number of possible values. Examples of continuous variables: weight of a person, height of a person\ldots{}
\end{itemize}

The different values that the variable can take are called levels, \textbf{factor levels}.

Why use factors?

\begin{itemize}
\tightlist
\item
  They allow to establish a different order than the alphabetical one.
\item
  Many R models/packages use them
\end{itemize}

Factors are categorical variables that have a fixed number of levels. A simple example of a factor might be a variable called gender with two levels: `female' and `male'. If you had three females and two males, you could create the factor like this:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{gender }\OtherTok{=} \FunctionTok{factor}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\StringTok{"female"}\NormalTok{, }\StringTok{"male"}\NormalTok{, }\StringTok{"female"}\NormalTok{, }\StringTok{"male"}\NormalTok{, }\StringTok{"female"}\NormalTok{))}
\FunctionTok{class}\NormalTok{(gender)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "factor"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{mode}\NormalTok{(gender)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "numeric"
\end{verbatim}

More often, you will create a dataframe by reading your data from a file using read.table. When we did this in the previous version of R (R3), the strings in our data table were automatically converted into factors. This was useful as long as our data table was well structured and clean, but it could cause problems in some cases. Let's see an example of a well-structured data table:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{data }\OtherTok{=} \FunctionTok{read.table}\NormalTok{(}\AttributeTok{file =} \StringTok{"./Data/GenderPurchase.csv"}\NormalTok{, }\AttributeTok{header =} \ConstantTok{TRUE}\NormalTok{, }\AttributeTok{sep =} \StringTok{","}\NormalTok{)}
\FunctionTok{is.factor}\NormalTok{(data}\SpecialCharTok{$}\NormalTok{Gender)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE
\end{verbatim}

As we can see, in this version of R (R4), the strings are coded as default character type. We can solve this by adding a parameter to our command as seen below:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{data }\OtherTok{=} \FunctionTok{read.table}\NormalTok{(}\AttributeTok{file =} \StringTok{"./Data/GenderPurchase.csv"}\NormalTok{, }\AttributeTok{header =} \ConstantTok{TRUE}\NormalTok{, }\AttributeTok{sep =} \StringTok{","}\NormalTok{, }\AttributeTok{stringsAsFactors =} \ConstantTok{TRUE}\NormalTok{)}
\FunctionTok{is.factor}\NormalTok{(data}\SpecialCharTok{$}\NormalTok{Gender)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

Let's see what happens with a data table that is not well structured in case of reading the strings as factors:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{data }\OtherTok{=} \FunctionTok{read.table}\NormalTok{(}\AttributeTok{file =} \StringTok{"./Data/titanic3.csv"}\NormalTok{, }\AttributeTok{header =} \ConstantTok{TRUE}\NormalTok{, }\AttributeTok{sep =} \StringTok{","}\NormalTok{, }\AttributeTok{stringsAsFactors =} \ConstantTok{TRUE}\NormalTok{)}
\FunctionTok{str}\NormalTok{(data)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 'data.frame':    1309 obs. of  14 variables:
##  $ pclass   : int  1 1 1 1 1 1 1 1 1 1 ...
##  $ survived : int  1 1 0 0 0 1 1 0 1 0 ...
##  $ name     : Factor w/ 1307 levels "Abbing, Mr. Anthony",..: 22 24 25 26 27 31 46 47 51 55 ...
##  $ sex      : Factor w/ 2 levels "female","male": 1 2 1 2 1 2 1 2 1 2 ...
##  $ age      : num  29 0.917 2 30 25 ...
##  $ sibsp    : int  0 1 1 1 1 0 1 0 2 0 ...
##  $ parch    : int  0 2 2 2 2 0 0 0 0 0 ...
##  $ ticket   : Factor w/ 929 levels "110152","110413",..: 188 50 50 50 50 125 93 16 77 826 ...
##  $ fare     : num  211 152 152 152 152 ...
##  $ cabin    : Factor w/ 187 levels "","A10","A11",..: 45 81 81 81 81 151 147 17 63 1 ...
##  $ embarked : Factor w/ 4 levels "","C","Q","S": 4 4 4 4 4 4 4 4 4 2 ...
##  $ boat     : Factor w/ 28 levels "","1","10","11",..: 13 4 1 1 1 14 3 1 28 1 ...
##  $ body     : int  NA NA NA 135 NA NA NA NA NA 22 ...
##  $ home.dest: Factor w/ 370 levels "","?Havana, Cuba",..: 310 232 232 232 232 238 163 25 23 230 ...
\end{verbatim}

We can find ourselves with variables that are completely useless and very difficult to manage, with as many levels of the factors as cases we have in the data table.

In these cases it is much more comfortable to read the strings as characters and work on those variables to extract useful information from them as we will see later.

We will use the daphnia dataset to perform some examples with factors:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{daphnia }\OtherTok{=} \FunctionTok{read.table}\NormalTok{(}\StringTok{"./Data/daphnia.txt"}\NormalTok{, }\AttributeTok{header =} \ConstantTok{TRUE}\NormalTok{, }\AttributeTok{stringsAsFactors =} \ConstantTok{TRUE}\NormalTok{)}
\FunctionTok{attach}\NormalTok{(daphnia)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## The following objects are masked from daphnia (pos = 3):
## 
##     Daphnia, Detergent, Growth.rate, Water
\end{verbatim}

There are some important functions for dealing with factors. You will often want to check that a variable is a factor (especially if the factor levels are numbers rather than characters):

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{is.factor}\NormalTok{(Water)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

To discover the names of the factor levels, we use the levels function:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{levels}\NormalTok{(Detergent)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "BrandA" "BrandB" "BrandC" "BrandD"
\end{verbatim}

To discover the number of levels of a factor, we use the nlevels function:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{nlevels}\NormalTok{(Detergent)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 4
\end{verbatim}

The same result is achieved by applying the length function to the levels of a factor:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{length}\NormalTok{(}\FunctionTok{levels}\NormalTok{(Detergent))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 4
\end{verbatim}

By default, factor levels are treated in alphabetical order. If you want to change this (as you might, for instance, in ordering the bars of a bar chart) then this is straightforward: just type the factor levels in the order that you want them to be used, and provide this vector as the second argument to the factor function.

Suppose we have an experiment with three factor levels in a variable called treatment, and we want them to appear in this order: `nothing', `single' dose and `double' dose. We shall need to override R's natural tendency to order them `double', `nothing', `single':

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{2020}\NormalTok{)}
\NormalTok{treatment }\OtherTok{=} \FunctionTok{as.factor}\NormalTok{(}\FunctionTok{sample}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\StringTok{"double"}\NormalTok{, }\StringTok{"nothing"}\NormalTok{, }\StringTok{"single"}\NormalTok{), }\DecValTok{100}\NormalTok{, }\AttributeTok{replace =} \ConstantTok{TRUE}\NormalTok{))}
\NormalTok{response }\OtherTok{=} \FunctionTok{sample}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{,}\DecValTok{1}\NormalTok{), }\DecValTok{100}\NormalTok{, }\AttributeTok{replace =} \ConstantTok{TRUE}\NormalTok{)}
\FunctionTok{tapply}\NormalTok{(response, treatment, mean)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##    double   nothing    single 
## 0.4166667 0.4871795 0.4000000
\end{verbatim}

This is achieved using the factor function like this:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{treatment }\OtherTok{=} \FunctionTok{factor}\NormalTok{(treatment,}\AttributeTok{levels=}\FunctionTok{c}\NormalTok{(}\StringTok{"nothing"}\NormalTok{,}\StringTok{"single"}\NormalTok{,}\StringTok{"double"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

Now we get the order we want:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{tapply}\NormalTok{(response,treatment,mean)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   nothing    single    double 
## 0.4871795 0.4000000 0.4166667
\end{verbatim}

Only == and != can be used for factors. Note, also, that a factor can only be compared to another factor with
an identical set of levels (not necessarily in the same ordering) or to a character vector. For example, you
cannot ask quantitative questions about factor levels, like \textgreater{} or \textless=, even if these levels are numeric.

To turn factor levels into numbers (integers) use the unclass function like this:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{as.vector}\NormalTok{(}\FunctionTok{unclass}\NormalTok{(treatment))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   [1] 2 1 3 3 1 1 3 3 1 1 1 3 1 2 1 3 1 1 1 2 1 2 1 3 2 1 1 1 2 1 2 2 3 3 3 1 2
##  [38] 3 3 1 2 3 3 3 2 3 3 2 1 1 1 3 2 1 3 1 2 3 3 1 3 1 2 1 2 1 1 3 2 1 2 3 1 2
##  [75] 1 1 1 3 3 3 2 1 1 3 3 1 3 3 1 3 2 3 2 3 3 2 2 2 1 3
\end{verbatim}

\hypertarget{matrices-and-arrays}{%
\subsection{Matrices and Arrays}\label{matrices-and-arrays}}

An array is a multi-dimensional object. The dimensions of an array are specified by its \texttt{dim} attribute, which gives the maximal indices in each dimension. So for a three-dimensional array consisting of 24 numbers in a sequence 1:24, with dimensions 2 × 4 × 3, we write:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y }\OtherTok{=} \DecValTok{1}\SpecialCharTok{:}\DecValTok{24}
\FunctionTok{dim}\NormalTok{(y) }\OtherTok{=} \FunctionTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{,}\DecValTok{4}\NormalTok{,}\DecValTok{3}\NormalTok{)}
\NormalTok{y}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## , , 1
## 
##      [,1] [,2] [,3] [,4]
## [1,]    1    3    5    7
## [2,]    2    4    6    8
## 
## , , 2
## 
##      [,1] [,2] [,3] [,4]
## [1,]    9   11   13   15
## [2,]   10   12   14   16
## 
## , , 3
## 
##      [,1] [,2] [,3] [,4]
## [1,]   17   19   21   23
## [2,]   18   20   22   24
\end{verbatim}

This produces three two-dimensional tables, because the third dimension is 3. This is what happens when you change the dimensions:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{dim}\NormalTok{(y) }\OtherTok{=} \FunctionTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{4}\NormalTok{)}
\NormalTok{y}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## , , 1
## 
##      [,1] [,2]
## [1,]    1    4
## [2,]    2    5
## [3,]    3    6
## 
## , , 2
## 
##      [,1] [,2]
## [1,]    7   10
## [2,]    8   11
## [3,]    9   12
## 
## , , 3
## 
##      [,1] [,2]
## [1,]   13   16
## [2,]   14   17
## [3,]   15   18
## 
## , , 4
## 
##      [,1] [,2]
## [1,]   19   22
## [2,]   20   23
## [3,]   21   24
\end{verbatim}

Now we have four two-dimensional tables, each of three rows and two columns.

A matrix is a two-dimensional array containing numbers. A dataframe is a two-dimensional list containing (potentially a mix of) numbers, text or logical variables in different columns.

When there are two subscripts {[}5,3{]} to an object like a matrix or a dataframe, the first subscript refers to the row number (5 in this example; the rows are defined as margin number 1) and the second subscript refers to the column number (3 in this example; the columns are margin number 2).

There is an important and powerful convention in R, such that when a subscript appears as a blank it is understood to mean `all of'. Thus:

\begin{itemize}
\tightlist
\item
  {[},4{]} means all rows in column 4 of an object;
\item
  {[}2,{]} means all columns in row 2 of an object.
\end{itemize}

\hypertarget{matrices}{%
\subsection{Matrices}\label{matrices}}

There are several ways of making a matrix. You can create one directly like this:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{X }\OtherTok{=} \FunctionTok{matrix}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{0}\NormalTok{,}\DecValTok{0}\NormalTok{,}\DecValTok{0}\NormalTok{,}\DecValTok{1}\NormalTok{,}\DecValTok{0}\NormalTok{,}\DecValTok{0}\NormalTok{,}\DecValTok{0}\NormalTok{,}\DecValTok{1}\NormalTok{),}\AttributeTok{nrow=}\DecValTok{3}\NormalTok{)}
\NormalTok{X}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2] [,3]
## [1,]    1    0    0
## [2,]    0    1    0
## [3,]    0    0    1
\end{verbatim}

where, by default, the numbers are entered column-wise.

The class and attributes of \texttt{X} indicate that it is a matrix of three rows and three columns (these are its \texttt{dim} attributes):

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{class}\NormalTok{(X)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "matrix" "array"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{attributes}\NormalTok{(X)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## $dim
## [1] 3 3
\end{verbatim}

In the next example, the data in the vector appear row-wise, so we indicate this with \texttt{byrow=T}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vector }\OtherTok{=} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{,}\DecValTok{4}\NormalTok{,}\DecValTok{4}\NormalTok{,}\DecValTok{3}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{1}\NormalTok{)}
\NormalTok{V }\OtherTok{=} \FunctionTok{matrix}\NormalTok{(vector,}\AttributeTok{byrow=}\NormalTok{T,}\AttributeTok{nrow=}\DecValTok{2}\NormalTok{)}
\NormalTok{V}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2] [,3] [,4]
## [1,]    1    3    4    2
## [2,]    2    4    3    1
\end{verbatim}

Another way to convert a vector into a matrix is by providing the vector object with two dimensions (rows and columns) using the dim function like this:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{dim}\NormalTok{(vector) }\OtherTok{=} \FunctionTok{c}\NormalTok{(}\DecValTok{4}\NormalTok{,}\DecValTok{2}\NormalTok{)}
\FunctionTok{is.matrix}\NormalTok{(vector)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

We need to be careful, however, because we have made no allowance at this stage for the fact that the data were entered row-wise into vector:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vector}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2]
## [1,]    1    4
## [2,]    2    3
## [3,]    3    2
## [4,]    4    1
\end{verbatim}

The matrix we want is the transpose, \texttt{t}, of this matrix:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{t}\NormalTok{(vector)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2] [,3] [,4]
## [1,]    1    2    3    4
## [2,]    4    3    2    1
\end{verbatim}

\hypertarget{naming-the-rows-and-columns-of-matrices}{%
\subsubsection{Naming the rows and columns of matrices}\label{naming-the-rows-and-columns-of-matrices}}

At first, matrices have numbers naming their rows and columns (see above). Here is a 4 × 5 matrix of random integers from a Poisson distribution with mean 1.5:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{X }\OtherTok{=} \FunctionTok{matrix}\NormalTok{(}\FunctionTok{rpois}\NormalTok{(}\DecValTok{20}\NormalTok{,}\FloatTok{1.5}\NormalTok{),}\AttributeTok{nrow=}\DecValTok{4}\NormalTok{)}
\NormalTok{X}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2] [,3] [,4] [,5]
## [1,]    0    2    4    0    1
## [2,]    1    6    2    2    2
## [3,]    0    2    3    1    1
## [4,]    1    2    1    1    1
\end{verbatim}

Suppose that the rows refer to four different trials and we want to label the rows `Trial.1' etc. We employ the function \texttt{rownames} to do this. We could use the \texttt{paste} function but here we take advantage of the \texttt{prefix} option:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{rownames}\NormalTok{(X) }\OtherTok{=} \FunctionTok{rownames}\NormalTok{(X,}\AttributeTok{do.NULL=}\ConstantTok{FALSE}\NormalTok{,}\AttributeTok{prefix=}\StringTok{"Trial."}\NormalTok{)}
\NormalTok{X}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##         [,1] [,2] [,3] [,4] [,5]
## Trial.1    0    2    4    0    1
## Trial.2    1    6    2    2    2
## Trial.3    0    2    3    1    1
## Trial.4    1    2    1    1    1
\end{verbatim}

For the columns we want to supply a vector of different names for the five drugs involved in the trial, and use this to specify the \texttt{colnames(X)}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{drug.names }\OtherTok{=} \FunctionTok{c}\NormalTok{(}\StringTok{"aspirin"}\NormalTok{, }\StringTok{"paracetamol"}\NormalTok{, }\StringTok{"nurofen"}\NormalTok{, }\StringTok{"hedex"}\NormalTok{, }\StringTok{"placebo"}\NormalTok{)}
\FunctionTok{colnames}\NormalTok{(X) }\OtherTok{=}\NormalTok{ drug.names}
\NormalTok{X}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##         aspirin paracetamol nurofen hedex placebo
## Trial.1       0           2       4     0       1
## Trial.2       1           6       2     2       2
## Trial.3       0           2       3     1       1
## Trial.4       1           2       1     1       1
\end{verbatim}

\hypertarget{matrices-functions}{%
\subsubsection{Matrices Functions}\label{matrices-functions}}

Using R, we can operate with matrices easily, since by default this type of data structures are designed for matrix algebra.

Let's create a matrix to see some examples:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{M1 }\OtherTok{=} \FunctionTok{matrix}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{9}\NormalTok{, }\AttributeTok{byrow =}\NormalTok{ T, }\AttributeTok{nrow =} \DecValTok{3}\NormalTok{)}
\NormalTok{M1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2] [,3]
## [1,]    1    4    7
## [2,]    2    5    8
## [3,]    3    6    9
\end{verbatim}

We can know the size of the matrix using the \texttt{dim} function:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{dim}\NormalTok{(M1)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 3 3
\end{verbatim}

We can also create diagonal matrices using the \texttt{diag} function:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{diag}\NormalTok{(}\DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2] [,3] [,4] [,5]
## [1,]    1    0    0    0    0
## [2,]    0    1    0    0    0
## [3,]    0    0    1    0    0
## [4,]    0    0    0    1    0
## [5,]    0    0    0    0    1
\end{verbatim}

Or even create a diagonal matrix using a defined vector:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{diag}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2] [,3]
## [1,]    1    0    0
## [2,]    0    2    0
## [3,]    0    0    3
\end{verbatim}

We can calculate a matrix transpose:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{t}\NormalTok{(M1)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2] [,3]
## [1,]    1    2    3
## [2,]    4    5    6
## [3,]    7    8    9
\end{verbatim}

And the trace of a matrix easily:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sum}\NormalTok{(}\FunctionTok{diag}\NormalTok{(M1))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 15
\end{verbatim}

To calculate the determinant we just need to use the \texttt{det} function:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{det}\NormalTok{(M1)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0
\end{verbatim}

In case the determinant is not 0 we can calculate the inverse of that matrix using the \texttt{solve} function. Let's see what happens in this case:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\#solve(M1)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Error in solve.default(M1) : system is computationally singular: reciprocal condition number = 2.59052e-18
\end{verbatim}

We can create a random matrix to check this function:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{2020}\NormalTok{)}
\NormalTok{M2 }\OtherTok{=} \FunctionTok{matrix}\NormalTok{(}\FunctionTok{sample}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{100}\NormalTok{, }\AttributeTok{size =} \DecValTok{9}\NormalTok{), }\AttributeTok{byrow =}\NormalTok{ T, }\AttributeTok{nrow =} \DecValTok{3}\NormalTok{)}
\FunctionTok{det}\NormalTok{(M2)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] -345436
\end{verbatim}

And now apply the \texttt{solve} function:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{solve}\NormalTok{(M2)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##               [,1]         [,2]         [,3]
## [1,] -0.0111048067  0.016060862 -0.003925474
## [2,]  0.0149550134 -0.003381234 -0.005662409
## [3,] -0.0001418497 -0.004226543  0.016894591
\end{verbatim}

Finally, we can perform a matrix decomposition using the \texttt{eigen} function in R, obtaining the eigenvectors and the eigenvalues of that decomposition,

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{eigen}\NormalTok{(M1)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## eigen() decomposition
## $values
## [1]  1.611684e+01 -1.116844e+00 -5.700691e-16
## 
## $vectors
##            [,1]       [,2]       [,3]
## [1,] -0.4645473 -0.8829060  0.4082483
## [2,] -0.5707955 -0.2395204 -0.8164966
## [3,] -0.6770438  0.4038651  0.4082483
\end{verbatim}

or even a Singular Value Decomposition using the \texttt{svd} function:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s }\OtherTok{=} \FunctionTok{svd}\NormalTok{(M1)}
\NormalTok{s}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## $d
## [1] 1.684810e+01 1.068370e+00 5.543107e-16
## 
## $u
##            [,1]        [,2]       [,3]
## [1,] -0.4796712  0.77669099  0.4082483
## [2,] -0.5723678  0.07568647 -0.8164966
## [3,] -0.6650644 -0.62531805  0.4082483
## 
## $v
##            [,1]       [,2]       [,3]
## [1,] -0.2148372 -0.8872307  0.4082483
## [2,] -0.5205874 -0.2496440 -0.8164966
## [3,] -0.8263375  0.3879428  0.4082483
\end{verbatim}

We can check that R makes a successful decomposition:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s}\SpecialCharTok{$}\NormalTok{u }\SpecialCharTok{\%*\%} \FunctionTok{diag}\NormalTok{(s}\SpecialCharTok{$}\NormalTok{d) }\SpecialCharTok{\%*\%} \FunctionTok{t}\NormalTok{(s}\SpecialCharTok{$}\NormalTok{v)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2] [,3]
## [1,]    1    4    7
## [2,]    2    5    8
## [3,]    3    6    9
\end{verbatim}

\hypertarget{matrices-operations}{%
\subsubsection{Matrices Operations}\label{matrices-operations}}

We can perform arithmetic operations with matrices (additions, subtractions, multiplications\ldots) in a similar way as we have done with vectors.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{M1 }\OtherTok{=} \FunctionTok{matrix}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{9}\NormalTok{, }\AttributeTok{byrow =} \ConstantTok{TRUE}\NormalTok{, }\AttributeTok{nrow =} \DecValTok{3}\NormalTok{)}
\NormalTok{M2 }\OtherTok{=} \FunctionTok{matrix}\NormalTok{(}\DecValTok{11}\SpecialCharTok{:}\DecValTok{19}\NormalTok{, }\AttributeTok{byrow =} \ConstantTok{TRUE}\NormalTok{, }\AttributeTok{nrow =} \DecValTok{3}\NormalTok{)}

\NormalTok{M3 }\OtherTok{=}\NormalTok{ M1 }\SpecialCharTok{+}\NormalTok{ M2}
\NormalTok{M3}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2] [,3]
## [1,]   12   14   16
## [2,]   18   20   22
## [3,]   24   26   28
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{M1 }\SpecialCharTok{+} \DecValTok{2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2] [,3]
## [1,]    3    4    5
## [2,]    6    7    8
## [3,]    9   10   11
\end{verbatim}

In the case of matrices multiplication we must remember that two matrices can be multiplied only when the number of columns in the first equals the number of rows in the second

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{M1 }\OtherTok{=} \FunctionTok{matrix}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{6}\NormalTok{, }\AttributeTok{byrow =} \ConstantTok{TRUE}\NormalTok{, }\AttributeTok{nrow =} \DecValTok{3}\NormalTok{, }\AttributeTok{ncol =} \DecValTok{2}\NormalTok{)}
\NormalTok{M1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2]
## [1,]    1    2
## [2,]    3    4
## [3,]    5    6
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{M2 }\OtherTok{=} \FunctionTok{matrix}\NormalTok{(}\DecValTok{10}\SpecialCharTok{:}\DecValTok{15}\NormalTok{, }\AttributeTok{byrow =} \ConstantTok{TRUE}\NormalTok{, }\AttributeTok{nrow =} \DecValTok{2}\NormalTok{, }\AttributeTok{ncol =} \DecValTok{3}\NormalTok{)}
\NormalTok{M2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2] [,3]
## [1,]   10   11   12
## [2,]   13   14   15
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{M3 }\OtherTok{=}\NormalTok{ M1 }\SpecialCharTok{\%*\%}\NormalTok{ M2}
\NormalTok{M3}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2] [,3]
## [1,]   36   39   42
## [2,]   82   89   96
## [3,]  128  139  150
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{M4 }\OtherTok{=}\NormalTok{ M2 }\SpecialCharTok{\%*\%}\NormalTok{ M1}
\NormalTok{M4}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2]
## [1,]  103  136
## [2,]  130  172
\end{verbatim}

We can also apply some other R built-in functions to a matrix. For example:

\begin{itemize}
\tightlist
\item
  \texttt{rowSums} will sum up all the elements for each row
\item
  \texttt{colSums} will do the same by columns
\item
  \texttt{rowMeans} will calculate the mean of each row (is the same for columns with \texttt{colMeans})
\item
  \texttt{summary} will show some statistics about the matrix by columns
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{summary}\NormalTok{(M4)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##        V1              V2     
##  Min.   :103.0   Min.   :136  
##  1st Qu.:109.8   1st Qu.:145  
##  Median :116.5   Median :154  
##  Mean   :116.5   Mean   :154  
##  3rd Qu.:123.2   3rd Qu.:163  
##  Max.   :130.0   Max.   :172
\end{verbatim}

\hypertarget{matrices-manipulation}{%
\subsubsection{Matrices Manipulation}\label{matrices-manipulation}}

To add columns to a matrix you use the function \texttt{cbind(m1,\ m2,\ ...)}, which joins matrices and/or vectors per column.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{M5 }\OtherTok{=} \FunctionTok{cbind}\NormalTok{(M1, M3)}
\NormalTok{M5}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2] [,3] [,4] [,5]
## [1,]    1    2   36   39   42
## [2,]    3    4   82   89   96
## [3,]    5    6  128  139  150
\end{verbatim}

We can add just a new column:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{M5 }\OtherTok{=} \FunctionTok{cbind}\NormalTok{(M5, }\FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{))}
\NormalTok{M5}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2] [,3] [,4] [,5] [,6]
## [1,]    1    2   36   39   42    1
## [2,]    3    4   82   89   96    2
## [3,]    5    6  128  139  150    3
\end{verbatim}

To add rows to a matrix you use the \texttt{rbind(m1,\ m2,\ ...)} function, which joins arrays and/or vectors per row.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{M5 }\OtherTok{=} \FunctionTok{rbind}\NormalTok{(M2, M3)}
\NormalTok{M5}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2] [,3]
## [1,]   10   11   12
## [2,]   13   14   15
## [3,]   36   39   42
## [4,]   82   89   96
## [5,]  128  139  150
\end{verbatim}

And we can add an extra row using the same function:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{M5 }\OtherTok{=} \FunctionTok{rbind}\NormalTok{(M5, }\FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{))}
\NormalTok{M5}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2] [,3]
## [1,]   10   11   12
## [2,]   13   14   15
## [3,]   36   39   42
## [4,]   82   89   96
## [5,]  128  139  150
## [6,]    1    2    3
\end{verbatim}

\hypertarget{indexing-matrices}{%
\subsubsection{Indexing Matrices}\label{indexing-matrices}}

As with vectors, we will use the square brackets \texttt{{[}\ {]}} to index matrices. In the particular case of matrices we will use two integers: one for the row and one for the column \texttt{{[}row,\ column{]}}.

To select all the elements of a row or a column, it is enough not to include any number before or after the comma, respectively. For example: \texttt{matrix{[}row,\ {]}}; \texttt{matrix{[},\ col{]}}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{M1 }\OtherTok{=} \FunctionTok{matrix}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{9}\NormalTok{, }\AttributeTok{byrow =}\NormalTok{ T, }\AttributeTok{nrow =} \DecValTok{3}\NormalTok{)}
\NormalTok{M1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2] [,3]
## [1,]    1    4    7
## [2,]    2    5    8
## [3,]    3    6    9
\end{verbatim}

Let's see some examples:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# We select the first two rows}
\NormalTok{M1[}\DecValTok{1}\SpecialCharTok{:}\DecValTok{2}\NormalTok{,]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2] [,3]
## [1,]    1    4    7
## [2,]    2    5    8
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# We select the last column}
\NormalTok{M1[, }\FunctionTok{ncol}\NormalTok{(M1)]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 7 8 9
\end{verbatim}

As we did with vectors, we can use vectors to perform selections inside a matrix,

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Select the first and last columns}
\NormalTok{M1[, }\FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\FunctionTok{ncol}\NormalTok{(M1))]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2]
## [1,]    1    7
## [2,]    2    8
## [3,]    3    9
\end{verbatim}

and assign values to a specific position

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{M1[}\DecValTok{1}\NormalTok{,}\DecValTok{1}\NormalTok{] }\OtherTok{=} \DecValTok{0}
\NormalTok{M1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2] [,3]
## [1,]    0    4    7
## [2,]    2    5    8
## [3,]    3    6    9
\end{verbatim}

Finally, we can use logical expressions to select elements inside a matrix:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{M1[M1 }\SpecialCharTok{\textless{}} \DecValTok{4}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0 2 3
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{M1[M1 }\SpecialCharTok{\textgreater{}} \DecValTok{3} \SpecialCharTok{\&}\NormalTok{ M1 }\SpecialCharTok{\textless{}} \DecValTok{8}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 4 5 6 7
\end{verbatim}

\hypertarget{lists}{%
\subsection{Lists}\label{lists}}

Lists are extremely important objects in R. You will have heard of the problems of `comparing apples and oranges' or how two things are `as different as chalk and cheese'. You can think of lists as a way of getting around these problems. Here are four completely different objects: a numeric vector, a logical vector, a vector of character strings and a vector of complex numbers:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{apples }\OtherTok{=} \FunctionTok{c}\NormalTok{(}\DecValTok{4}\NormalTok{,}\FloatTok{4.5}\NormalTok{,}\FloatTok{4.2}\NormalTok{,}\FloatTok{5.1}\NormalTok{,}\FloatTok{3.9}\NormalTok{)}
\NormalTok{oranges }\OtherTok{=} \FunctionTok{c}\NormalTok{(}\ConstantTok{TRUE}\NormalTok{, }\ConstantTok{TRUE}\NormalTok{, }\ConstantTok{FALSE}\NormalTok{)}
\NormalTok{chalk }\OtherTok{=} \FunctionTok{c}\NormalTok{(}\StringTok{"limestone"}\NormalTok{, }\StringTok{"marl"}\NormalTok{,}\StringTok{"oolite"}\NormalTok{, }\StringTok{"CaC03"}\NormalTok{)}
\NormalTok{cheese }\OtherTok{=} \FunctionTok{c}\NormalTok{(}\FloatTok{3.2{-}4.5}\NormalTok{i,}\FloatTok{12.8+2.2}\NormalTok{i)}
\end{Highlighting}
\end{Shaded}

We cannot bundle them together into a dataframe, because the vectors are of different lengths. However, despite their differences, however, we can bundle them together in a single list called items:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{items }\OtherTok{=} \FunctionTok{list}\NormalTok{(apples,oranges,chalk,cheese)}
\NormalTok{items}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [[1]]
## [1] 4.0 4.5 4.2 5.1 3.9
## 
## [[2]]
## [1]  TRUE  TRUE FALSE
## 
## [[3]]
## [1] "limestone" "marl"      "oolite"    "CaC03"    
## 
## [[4]]
## [1]  3.2-4.5i 12.8+2.2i
\end{verbatim}

Subscripts on vectors, matrices, arrays and dataframes have one set of square brackets {[}6{]}, {[}3,4{]} or {[}2,3,2,1{]}, but subscripts on lists have double square brackets {[}{[}2{]}{]} or {[}{[}i,j{]}{]}. If we want to extract the chalk from the list, we use subscript {[}{[}3{]}{]}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{items[[}\DecValTok{3}\NormalTok{]]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "limestone" "marl"      "oolite"    "CaC03"
\end{verbatim}

If we want to extract the third element within chalk (oolite) then we use single subscripts after the double subscripts like this:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{items[[}\DecValTok{3}\NormalTok{]][}\DecValTok{3}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "oolite"
\end{verbatim}

There is another indexing convention in R which is used to extract named components from lists using the element names operator \$. This is known as `indexing tagged lists'. For this to work, the elements of the list must have names. At the moment our list called \texttt{items} has no names:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{names}\NormalTok{(items)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## NULL
\end{verbatim}

You can give names to the elements of a list in the function that creates the list by using the equals sign like this:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{items }\OtherTok{=} \FunctionTok{list}\NormalTok{(}\AttributeTok{first=}\NormalTok{apples,}\AttributeTok{second=}\NormalTok{oranges,}\AttributeTok{third=}\NormalTok{chalk,}\AttributeTok{fourth=}\NormalTok{cheese)}
\end{Highlighting}
\end{Shaded}

Now you can extract elements of the list by name

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{items}\SpecialCharTok{$}\NormalTok{fourth}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  3.2-4.5i 12.8+2.2i
\end{verbatim}

\hypertarget{lapply-function}{%
\subsubsection{\texorpdfstring{\texttt{lapply} function}{lapply function}}\label{lapply-function}}

We can ask a variety of questions about our new list object:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{class}\NormalTok{(items)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "list"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{is.numeric}\NormalTok{(items)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{is.list}\NormalTok{(items)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{length}\NormalTok{(items)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 4
\end{verbatim}

Note that the length of a list is the number of items in the list, not the lengths of the individual vectors within the list.

The function lapply applies a specified function to each of the elements of a list in turn (without the need for specifying a loop, and not requiring us to know how many elements there are in the list). A useful function to apply to lists is the length function; this asks how many elements comprise each component of the list. Technically we want to know the length of each of the vectors making up the list:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{lapply}\NormalTok{(items, length)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## $first
## [1] 5
## 
## $second
## [1] 3
## 
## $third
## [1] 4
## 
## $fourth
## [1] 2
\end{verbatim}

This shows that items consists of four vectors, and shows that there were 5 elements in the first vector, 3 in the second 4 in the third and 2 in the fourth. But 5 of what, and 3 of what? To find out, we apply the function class to the list:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{lapply}\NormalTok{(items, class)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## $first
## [1] "numeric"
## 
## $second
## [1] "logical"
## 
## $third
## [1] "character"
## 
## $fourth
## [1] "complex"
\end{verbatim}

So the answer is there were 5 numbers in the first vector, 3 logical variables in the second, 4 character strings in the third vector and 2 complex numbers in the fourth.

Applying numeric functions to lists will only work for objects of class \texttt{numeric} or \texttt{complex}, or objects (like logical values) that can be coerced into numbers. Here is what happens when we use \texttt{lapply} to apply the function \texttt{mean} to \texttt{items}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{lapply}\NormalTok{(items, mean)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Warning in mean.default(X[[i]], ...): argument is not numeric or logical:
## returning NA
\end{verbatim}

\begin{verbatim}
## $first
## [1] 4.34
## 
## $second
## [1] 0.6666667
## 
## $third
## [1] NA
## 
## $fourth
## [1] 8-1.15i
\end{verbatim}

Finally, the most useful overview of the contents of a list is obtained with str, the structure function:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{str}\NormalTok{(items)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## List of 4
##  $ first : num [1:5] 4 4.5 4.2 5.1 3.9
##  $ second: logi [1:3] TRUE TRUE FALSE
##  $ third : chr [1:4] "limestone" "marl" "oolite" "CaC03"
##  $ fourth: cplx [1:2] 3.2-4.5i 12.8+2.2i
\end{verbatim}

\hypertarget{data-frames}{%
\subsection{Data Frames}\label{data-frames}}

Data frame is a two dimensional data structure in R. It is a special case of a list which has each component of equal length.

\hypertarget{check-if-a-variable-is-a-data-frame-or-not}{%
\subsubsection{Check if a variable is a data frame or not}\label{check-if-a-variable-is-a-data-frame-or-not}}

We can check if a variable is a data frame or not using the \texttt{class()} function.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{typeof}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "list"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{class}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "data.frame"
\end{verbatim}

In this example, x can be considered as a list of 3 components with each component having a two element vector.

\hypertarget{functions-of-data-frame}{%
\subsubsection{Functions of data frame}\label{functions-of-data-frame}}

Here you have some useful functions we can use to have a better understanding about the content we have inside our data frame:

\begin{itemize}
\tightlist
\item
  We can check the names of the variables using the \texttt{names()} function
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{names}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "SN"     "Age"    "Gender"
\end{verbatim}

\begin{itemize}
\tightlist
\item
  We can know the number of columns and rows we have in our data frame (the \texttt{length()} function will return also the number of columns, it is taking the number of elements we are storing in the underlying list, which are the column vectors):
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ncol}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 3
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{nrow}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 2
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{length}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 3
\end{verbatim}

\begin{itemize}
\tightlist
\item
  The \texttt{str()} and the \texttt{summary()} are the most useful functions to understand our data frames:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{str}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 'data.frame':    2 obs. of  3 variables:
##  $ SN    : int  1 2
##  $ Age   : num  21 15
##  $ Gender: chr  "Male" "Female"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{summary}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##        SN            Age          Gender         
##  Min.   :1.00   Min.   :15.0   Length:2          
##  1st Qu.:1.25   1st Qu.:16.5   Class :character  
##  Median :1.50   Median :18.0   Mode  :character  
##  Mean   :1.50   Mean   :18.0                     
##  3rd Qu.:1.75   3rd Qu.:19.5                     
##  Max.   :2.00   Max.   :21.0
\end{verbatim}

\hypertarget{how-to-create-a-data-frame}{%
\subsubsection{How to create a data frame}\label{how-to-create-a-data-frame}}

We can create a data frame using the \texttt{data.frame()} function. Below you can see how to create the data frame we are using for all the previous examples:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{=} \FunctionTok{data.frame}\NormalTok{(}\StringTok{"SN"} \OtherTok{=} \DecValTok{1}\SpecialCharTok{:}\DecValTok{2}\NormalTok{, }\StringTok{"Age"} \OtherTok{=} \FunctionTok{c}\NormalTok{(}\DecValTok{21}\NormalTok{,}\DecValTok{15}\NormalTok{), }\StringTok{"Gender"} \OtherTok{=} \FunctionTok{c}\NormalTok{(}\StringTok{"Male"}\NormalTok{,}\StringTok{"Female"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

Let's take another look to the data frame structure:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{str}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 'data.frame':    2 obs. of  3 variables:
##  $ SN    : int  1 2
##  $ Age   : num  21 15
##  $ Gender: chr  "Male" "Female"
\end{verbatim}

Which is the type of the \texttt{Gender} variable? Do we need to change it? It is a character vector and, in order to use this variable in future models we will need to transform it into a factor. Remember that R3 automatically converts all the characters into factors, but we need to define those in R4.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{=} \FunctionTok{data.frame}\NormalTok{(}\StringTok{"SN"} \OtherTok{=} \DecValTok{1}\SpecialCharTok{:}\DecValTok{2}\NormalTok{, }\StringTok{"Age"} \OtherTok{=} \FunctionTok{c}\NormalTok{(}\DecValTok{21}\NormalTok{,}\DecValTok{15}\NormalTok{), }\StringTok{"Gender"} \OtherTok{=} \FunctionTok{c}\NormalTok{(}\StringTok{"Male"}\NormalTok{,}\StringTok{"Female"}\NormalTok{), }\AttributeTok{stringsAsFactors =}\NormalTok{ T)}
\FunctionTok{str}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 'data.frame':    2 obs. of  3 variables:
##  $ SN    : int  1 2
##  $ Age   : num  21 15
##  $ Gender: chr  "Male" "Female"
\end{verbatim}

\textbf{NOTE}: Many data input functions of R like, \texttt{read.table()}, \texttt{read.csv()}, \texttt{read.delim()}, \texttt{read.fwf()} also read data into a data frame.

\hypertarget{how-to-access-components-of-a-data-frame}{%
\subsubsection{How to access components of a data frame}\label{how-to-access-components-of-a-data-frame}}

Components of data frame can be accessed like a list or like a matrix.

\hypertarget{accessing-like-a-list}{%
\paragraph{Accessing like a list}\label{accessing-like-a-list}}

We can use either \texttt{{[}}, \texttt{{[}{[}} or \texttt{\$} operator to access columns of data frame.

Accessing with \texttt{{[}{[}} or \texttt{\$} is similar. However, it differs for \texttt{{[}} in that, indexing with \texttt{{[}} will return us a data frame but the other two will reduce it into a vector.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x[}\StringTok{"Gender"}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   Gender
## 1   Male
## 2 Female
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x}\SpecialCharTok{$}\NormalTok{Age}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 21 15
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x[[}\StringTok{"Gender"}\NormalTok{]]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Male"   "Female"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x[}\DecValTok{2}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   Age
## 1  21
## 2  15
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x[[}\DecValTok{3}\NormalTok{]]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Male"   "Female"
\end{verbatim}

\hypertarget{accessing-like-a-matrix}{%
\paragraph{Accessing like a matrix}\label{accessing-like-a-matrix}}

Data frames can be accessed like a matrix by providing index for row and column.

To illustrate this, we use datasets already available in R. Datasets that are available can be listed with the command \texttt{library(help\ =\ "datasets")}.

We will use the \texttt{trees} dataset which contains \texttt{Girth}, \texttt{Height} and \texttt{Volume} for Black Cherry Trees.

A data frame can be examined using functions like \texttt{str()} and \texttt{head()}.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{str}\NormalTok{(trees)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 'data.frame':    31 obs. of  3 variables:
##  $ Girth : num  8.3 8.6 8.8 10.5 10.7 10.8 11 11 11.1 11.2 ...
##  $ Height: num  70 65 63 72 81 83 66 75 80 75 ...
##  $ Volume: num  10.3 10.3 10.2 16.4 18.8 19.7 15.6 18.2 22.6 19.9 ...
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{head}\NormalTok{(trees, }\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   Girth Height Volume
## 1   8.3     70   10.3
## 2   8.6     65   10.3
## 3   8.8     63   10.2
\end{verbatim}

We can see that trees is a data frame with 31 rows and 3 columns. We also display the first 3 rows of the data frame.

Now we proceed to access the data frame like a matrix.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{trees[}\DecValTok{2}\SpecialCharTok{:}\DecValTok{3}\NormalTok{,]    }\CommentTok{\# select 2nd and 3rd row}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   Girth Height Volume
## 2   8.6     65   10.3
## 3   8.8     63   10.2
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{trees[trees}\SpecialCharTok{$}\NormalTok{Height }\SpecialCharTok{\textgreater{}} \DecValTok{82}\NormalTok{,]    }\CommentTok{\# selects rows with Height greater than 82}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##    Girth Height Volume
## 6   10.8     83   19.7
## 17  12.9     85   33.8
## 18  13.3     86   27.4
## 31  20.6     87   77.0
\end{verbatim}

\hypertarget{how-to-modify-a-data-frame}{%
\subsubsection{How to modify a Data Frame}\label{how-to-modify-a-data-frame}}

Data frames can be modified like we modified matrices through reassignment.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x[}\DecValTok{1}\NormalTok{,}\StringTok{"Age"}\NormalTok{] }\OtherTok{=} \DecValTok{20}\NormalTok{; x}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   SN Age Gender
## 1  1  20   Male
## 2  2  15 Female
\end{verbatim}

\hypertarget{adding-components}{%
\paragraph{Adding Components}\label{adding-components}}

Rows can be added to a data frame using the \texttt{rbind()} function.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(}\FunctionTok{rbind}\NormalTok{(x,}\FunctionTok{list}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{16}\NormalTok{,}\StringTok{"Female"}\NormalTok{)))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   SN Age Gender
## 1  1  20   Male
## 2  2  15 Female
## 3  1  16 Female
\end{verbatim}

Similarly, we can add columns using \texttt{cbind()}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(}\FunctionTok{cbind}\NormalTok{(x,}\AttributeTok{State=}\FunctionTok{c}\NormalTok{(}\StringTok{"NY"}\NormalTok{,}\StringTok{"FL"}\NormalTok{)))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   SN Age Gender State
## 1  1  20   Male    NY
## 2  2  15 Female    FL
\end{verbatim}

Since data frames are implemented as list, we can also add new columns through simple list-like assignments.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x}\SpecialCharTok{$}\NormalTok{State }\OtherTok{=} \FunctionTok{c}\NormalTok{(}\StringTok{"NY"}\NormalTok{,}\StringTok{"FL"}\NormalTok{); x}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   SN Age Gender State
## 1  1  20   Male    NY
## 2  2  15 Female    FL
\end{verbatim}

\hypertarget{deleting-components}{%
\paragraph{Deleting Components}\label{deleting-components}}

Data frame columns can be deleted by assigning \texttt{NULL} to it.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x}\SpecialCharTok{$}\NormalTok{State }\OtherTok{=} \ConstantTok{NULL}\NormalTok{; x}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   SN Age Gender
## 1  1  20   Male
## 2  2  15 Female
\end{verbatim}

Similarly, rows can be deleted through reassignments.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{=}\NormalTok{ x[}\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{,]; x}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   SN Age Gender
## 2  2  15 Female
\end{verbatim}

\hypertarget{exporting-a-data-frame}{%
\subsubsection{Exporting a data frame}\label{exporting-a-data-frame}}

As we have mentioned before, any data table we import in R will take the form of a data frame by default. This facilitates us enormously the work of data cleaning since there are many libraries that work on data frames and will help us in this process. We will see many of these resources in the ``Data Wrangling'' module.

For now, we only need some knowledge of importing and exporting data tables in R. Let's start with a built-in dataframe like \texttt{trees}.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{head}\NormalTok{(trees, }\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   Girth Height Volume
## 1   8.3     70   10.3
## 2   8.6     65   10.3
## 3   8.8     63   10.2
\end{verbatim}

This dataframe can be exported in different formats, but let's see only the two main ones that we will use in R, .csv and .txt. The basic function in R for exporting data is called \texttt{write.table()}, and it has a lot of parameters. My recommendation is that you take a look at the documentation of this function to familiarize yourself with it.

The main parameters of the \texttt{write.table()} function are

\begin{itemize}
\tightlist
\item
  \texttt{x}: will be the object we want to export, in this case a data frame
\item
  \texttt{file}: is the name of the file to be exported. In this argument we can also enter a path to organize the file in our OS. The file will take the extension that we indicate in its name.
\item
  \texttt{append}: we will use it if the file already exists and we want to add new information. By default it is \texttt{FALSE}.
\item
  \texttt{quote}: by default it is also \texttt{FALSE.} If you set it to \texttt{TRUE} this parameter will return the factors and strings with quotes
\item
  \texttt{sep}: in this parameter we can decide how to separate the columns of our file. The default is a comma.
\item
  \texttt{dec}: this parameter will allow us to change the symbol of the decimals that by default is a dot.
\item
  \ldots{}
\end{itemize}

Let's see an example. Next we are going to export the data frame \texttt{trees} as a .txt file.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{write.table}\NormalTok{(}\AttributeTok{x =}\NormalTok{ trees, }\AttributeTok{file =} \StringTok{"./Data/trees.txt"}\NormalTok{, }\AttributeTok{quote =} \ConstantTok{TRUE}\NormalTok{, }\AttributeTok{sep =} \StringTok{";"}\NormalTok{, }\AttributeTok{dec =} \StringTok{","}\NormalTok{, }\AttributeTok{row.names =} \ConstantTok{FALSE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Although the function \texttt{write.table()} already provides a simple method to export data tables, we can also use the function \texttt{write.csv()}, which will facilitate the export of .csv files with a predetermined format to facilitate their subsequent use.

This function \texttt{write.csv()} or \texttt{write.csv2()} (a second version that has different default parameters) use as a base the \texttt{write.table()} function, so its behavior is practically the same.

Let's see the same example, but exporting the file in this case as a .csv:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{write.csv}\NormalTok{(}\AttributeTok{x =}\NormalTok{ trees, }\AttributeTok{file =} \StringTok{"./Data/trees.csv"}\NormalTok{)}
\FunctionTok{write.csv2}\NormalTok{(}\AttributeTok{x =}\NormalTok{ trees, }\AttributeTok{file =} \StringTok{"./Data/trees2.csv"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{importing-a-data-frame}{%
\subsubsection{Importing a data frame}\label{importing-a-data-frame}}

When importing data tables the operation will be exactly the same. In this case, the basic function of R is \texttt{read.table()}, and the functions \texttt{read.csv()} and \texttt{read.csv2()} use the previous one to define other behaviors focused on reading .csv files.

The parameters of \texttt{read.table()} are the same as those of write.table() with some exceptions.

\begin{itemize}
\tightlist
\item
  \texttt{header}: is a logical parameter (TRUE/FALSE) that indicates if the file contains a header.
\item
  \texttt{quote}: it is not a logical parameter anymore, but it allows us to decide how we want to code the quotes.
\item
  \texttt{row.names} and \texttt{col.names}: they also existed in the previous function but in this case they make more sense. These parameters will take a vector the size of the number of rows or columns respectively, and set it as such in the data frame
\item
  \texttt{na.strings}: logical vector that by default is FALSE, and assigns as NA's to all character type elements.
\item
  \texttt{skip}: is a parameter that will skip the number of lines of the data table that we indicate with an integer.
\item
  \texttt{stringsAsFactors}: logical vector that by default is FALSE and helps us to code the character type vectors as factors. In some cases it will be useful, but in others we prefer to have the versatility that character vectors offer.
\end{itemize}

Let's see how to import the files that we have previously exported with the \texttt{read.table()} function:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df }\OtherTok{=} \FunctionTok{read.table}\NormalTok{(}\AttributeTok{file =} \StringTok{"./Data/trees.txt"}\NormalTok{, }\AttributeTok{header =} \ConstantTok{TRUE}\NormalTok{, }\AttributeTok{sep =} \StringTok{";"}\NormalTok{, }\AttributeTok{dec =} \StringTok{","}\NormalTok{, }
                \AttributeTok{na.strings =} \ConstantTok{FALSE}\NormalTok{, }\AttributeTok{stringsAsFactors =} \ConstantTok{TRUE}\NormalTok{)}
\FunctionTok{str}\NormalTok{(df)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 'data.frame':    31 obs. of  3 variables:
##  $ Girth : num  8.3 8.6 8.8 10.5 10.7 10.8 11 11 11.1 11.2 ...
##  $ Height: int  70 65 63 72 81 83 66 75 80 75 ...
##  $ Volume: num  10.3 10.3 10.2 16.4 18.8 19.7 15.6 18.2 22.6 19.9 ...
\end{verbatim}

In the case of the functions \texttt{read.csv()} and r\texttt{ead.csv2()} we can ensure that the format in which we have exported the files will be the same as that in which we should read it:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df1 }\OtherTok{=} \FunctionTok{read.csv}\NormalTok{(}\AttributeTok{file =} \StringTok{"./Data/trees.csv"}\NormalTok{)}
\FunctionTok{str}\NormalTok{(df1)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 'data.frame':    31 obs. of  4 variables:
##  $ X     : int  1 2 3 4 5 6 7 8 9 10 ...
##  $ Girth : num  8.3 8.6 8.8 10.5 10.7 10.8 11 11 11.1 11.2 ...
##  $ Height: int  70 65 63 72 81 83 66 75 80 75 ...
##  $ Volume: num  10.3 10.3 10.2 16.4 18.8 19.7 15.6 18.2 22.6 19.9 ...
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df2 }\OtherTok{=} \FunctionTok{read.csv2}\NormalTok{(}\AttributeTok{file =} \StringTok{"./Data/trees2.csv"}\NormalTok{)}
\FunctionTok{str}\NormalTok{(df2)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 'data.frame':    31 obs. of  4 variables:
##  $ X     : int  1 2 3 4 5 6 7 8 9 10 ...
##  $ Girth : num  8.3 8.6 8.8 10.5 10.7 10.8 11 11 11.1 11.2 ...
##  $ Height: int  70 65 63 72 81 83 66 75 80 75 ...
##  $ Volume: num  10.3 10.3 10.2 16.4 18.8 19.7 15.6 18.2 22.6 19.9 ...
\end{verbatim}

\hypertarget{control-flow}{%
\section{Control Flow}\label{control-flow}}

Flow control statements allow us to generate portions of code that perform certain actions given certain conditions. Let's differentiate between: Conditional sentences and loops

\hypertarget{conditional-statements}{%
\subsection{Conditional statements}\label{conditional-statements}}

Conditional statements allow us to perform actions based on specific conditions that we attribute to objects created in our R session. In this way, we can generate huge chains of conditionals that result in multiple different actions. To work with conditional statements in R we will use the following keywords: \texttt{if}, \texttt{else\ if} and \texttt{else}.

The specific syntax to create conditional statements in R is the following

Let's see some code examples. In this first example R will perform an action (to print something) in case \texttt{x} is a negative number:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{=} \SpecialCharTok{{-}}\DecValTok{3}
\ControlFlowTok{if}\NormalTok{ (x }\SpecialCharTok{\textless{}} \DecValTok{0}\NormalTok{) \{}
  \FunctionTok{print}\NormalTok{(}\StringTok{"x is a negative number"}\NormalTok{)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "x is a negative number"
\end{verbatim}

In a second example we are using the \texttt{if} and \texttt{else} statements to print if \texttt{x} is negative or positive

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{=} \DecValTok{5}
\ControlFlowTok{if}\NormalTok{ (x }\SpecialCharTok{\textless{}} \DecValTok{0}\NormalTok{) \{}
  \FunctionTok{print}\NormalTok{(}\StringTok{"x is a negative number"}\NormalTok{)}
\NormalTok{\} }\ControlFlowTok{else}\NormalTok{ \{}
  \FunctionTok{print}\NormalTok{(}\StringTok{"x is a positive number or zero"}\NormalTok{)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "x is a positive number or zero"
\end{verbatim}

In this third example we are using more conditions to print if \texttt{x} is negative, zero or positive.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{=} \SpecialCharTok{{-}}\DecValTok{3}
\ControlFlowTok{if}\NormalTok{ (x }\SpecialCharTok{\textless{}} \DecValTok{0}\NormalTok{) \{}
  \FunctionTok{print}\NormalTok{(}\StringTok{"x is a negative number"}\NormalTok{)}
\NormalTok{\} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (x }\SpecialCharTok{==} \DecValTok{0}\NormalTok{) \{}
  \FunctionTok{print}\NormalTok{(}\StringTok{"x is zero"}\NormalTok{)}
\NormalTok{\} }\ControlFlowTok{else}\NormalTok{ \{}
  \FunctionTok{print}\NormalTok{(}\StringTok{"x is a positive number"}\NormalTok{)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "x is a negative number"
\end{verbatim}

\hypertarget{loops}{%
\subsection{Loops}\label{loops}}

The classic, Fortran-like loop is available in R. The syntax is a little different, but the idea is identical; you request that an index (e.g.~\texttt{i}), takes on a sequence of values, and that one or more lines of commands are executed as many times as there are different values of i. Here is a loop executed five times with the values of i from 1 to 5; we print the square of each value:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# This is the abbreviated way to write a for loop}
\ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{1}\SpecialCharTok{:}\DecValTok{5}\NormalTok{) }\FunctionTok{print}\NormalTok{(i}\SpecialCharTok{\^{}}\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1
## [1] 4
## [1] 9
## [1] 16
## [1] 25
\end{verbatim}

For multiple lines of code, you use curly brackets \texttt{\{\}} to enclose material over which the loop is to work. Note that the `hard return' (the Enter key) at the end of each command line is an essential part of the structure (you can replace the hard returns by semicolons if you like, but clarity is improved if you put each command on a separate line):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{j }\OtherTok{=}\NormalTok{ k }\OtherTok{=} \DecValTok{0}
\ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{1}\SpecialCharTok{:}\DecValTok{5}\NormalTok{) \{}
\NormalTok{  j }\OtherTok{=}\NormalTok{ j}\SpecialCharTok{+}\DecValTok{1}
\NormalTok{  k }\OtherTok{=}\NormalTok{ k}\SpecialCharTok{+}\NormalTok{i}\SpecialCharTok{*}\NormalTok{j}
  \FunctionTok{print}\NormalTok{(i}\SpecialCharTok{+}\NormalTok{j}\SpecialCharTok{+}\NormalTok{k)}
\NormalTok{  \}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 3
## [1] 9
## [1] 20
## [1] 38
## [1] 65
\end{verbatim}

There are two types of loops:

\begin{itemize}
\item
  \texttt{while} loops: they perform a certain action iteratively until a stop condition is met
\item
  \texttt{for} loops: they execute a certain action in an iterative way for each element of a vector (set of elements).
\end{itemize}

We must be very careful not to make an infinite loop. This will produce that our R session starts working without a stop condition and we will have to kill the process to finish it. To prevent this situation we can always use the \texttt{break} keyword in our loops.

Here you can see the specific syntax we use in R to create loops:

\hypertarget{while-loops-examples}{%
\subsubsection{While loops examples}\label{while-loops-examples}}

In this first example we are creating a \texttt{ctr} variable that starts in \texttt{1}. Inside our while loop we are going to print our variable and later add \texttt{1} in each iteration

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ctr }\OtherTok{=} \DecValTok{1}
\ControlFlowTok{while}\NormalTok{ (ctr }\SpecialCharTok{\textless{}=} \DecValTok{7}\NormalTok{) \{}
  \FunctionTok{print}\NormalTok{(}\FunctionTok{paste}\NormalTok{(}\StringTok{"ctr is"}\NormalTok{, ctr))}
\NormalTok{  ctr }\OtherTok{=}\NormalTok{ ctr }\SpecialCharTok{+} \DecValTok{1}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "ctr is 1"
## [1] "ctr is 2"
## [1] "ctr is 3"
## [1] "ctr is 4"
## [1] "ctr is 5"
## [1] "ctr is 6"
## [1] "ctr is 7"
\end{verbatim}

We can apply the same logic to create a countdown to zero:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{count }\OtherTok{=} \DecValTok{10}
\ControlFlowTok{while}\NormalTok{ (count }\SpecialCharTok{\textgreater{}=} \DecValTok{0}\NormalTok{)\{}
    \FunctionTok{print}\NormalTok{ (count)}
\NormalTok{    count }\OtherTok{=}\NormalTok{ count }\SpecialCharTok{{-}} \DecValTok{1}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 10
## [1] 9
## [1] 8
## [1] 7
## [1] 6
## [1] 5
## [1] 4
## [1] 3
## [1] 2
## [1] 1
## [1] 0
\end{verbatim}

\hypertarget{for-loops-example}{%
\subsubsection{For loops example}\label{for-loops-example}}

As we said, \texttt{for} loops are going to execute certain action for each element in any data structure (normally a vector). In this example we are just printing each element we have inside the cities vector.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Print each element in a vector}
\NormalTok{cities }\OtherTok{=} \FunctionTok{c}\NormalTok{(}\StringTok{"New York"}\NormalTok{, }\StringTok{"Paris"}\NormalTok{, }\StringTok{"London"}\NormalTok{, }\StringTok{"Tokyo"}\NormalTok{, }\StringTok{"Rio de Janeiro"}\NormalTok{, }\StringTok{"Cape Town"}\NormalTok{)}
\ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in}\NormalTok{ cities) \{}
  \FunctionTok{print}\NormalTok{(i)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "New York"
## [1] "Paris"
## [1] "London"
## [1] "Tokyo"
## [1] "Rio de Janeiro"
## [1] "Cape Town"
\end{verbatim}

\hypertarget{loops-and-conditional-statements-combination}{%
\subsubsection{Loops and conditional statements combination}\label{loops-and-conditional-statements-combination}}

Once we know the different flow control methods we can combine them to perform much more complex actions. Let's look at some examples.

We can use a conditional statement to break our loops. In this example we are printing our \texttt{ctr} variable as we did before, but we will break the loop if the module obtained dividing ctr by 5 is equal to 0.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Using the break keyword with a condition}
\NormalTok{ctr }\OtherTok{=} \DecValTok{1}
\ControlFlowTok{while}\NormalTok{ (ctr }\SpecialCharTok{\textless{}=} \DecValTok{7}\NormalTok{) \{}
  \ControlFlowTok{if}\NormalTok{ (ctr }\SpecialCharTok{\%\%} \DecValTok{5} \SpecialCharTok{==} \DecValTok{0}\NormalTok{)}
    \ControlFlowTok{break}
  \FunctionTok{print}\NormalTok{(}\FunctionTok{paste}\NormalTok{(}\StringTok{"ctr is"}\NormalTok{, ctr))}
\NormalTok{  ctr }\OtherTok{=}\NormalTok{ ctr }\SpecialCharTok{+} \DecValTok{1}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "ctr is 1"
## [1] "ctr is 2"
## [1] "ctr is 3"
## [1] "ctr is 4"
\end{verbatim}

We can also introduce the \texttt{next} statement inside our loops. This will skip the current iteration, not performing all the actions we have below it inside the loop. In this case we are printing all the cities with a number of characters different to 6.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Print cities with 6 characters}
\NormalTok{cities }\OtherTok{=} \FunctionTok{c}\NormalTok{(}\StringTok{"New York"}\NormalTok{, }\StringTok{"Paris"}\NormalTok{, }\StringTok{"London"}\NormalTok{, }\StringTok{"Tokyo"}\NormalTok{, }\StringTok{"Rio de Janeiro"}\NormalTok{, }\StringTok{"Cape Town"}\NormalTok{)}
\ControlFlowTok{for}\NormalTok{ (city }\ControlFlowTok{in}\NormalTok{ cities) \{}
  \ControlFlowTok{if}\NormalTok{ (}\FunctionTok{nchar}\NormalTok{(city) }\SpecialCharTok{==} \DecValTok{6}\NormalTok{)}
    \ControlFlowTok{next}
  \FunctionTok{print}\NormalTok{(city)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "New York"
## [1] "Paris"
## [1] "Tokyo"
## [1] "Rio de Janeiro"
## [1] "Cape Town"
\end{verbatim}

In this last example we are printing only the even numbers in the \texttt{numbers} list:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Print even numbers}
\NormalTok{numbers }\OtherTok{=} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{100}\NormalTok{)}
\ControlFlowTok{for}\NormalTok{ (number }\ControlFlowTok{in}\NormalTok{ numbers)\{}
    \ControlFlowTok{if}\NormalTok{ (number }\SpecialCharTok{\%\%} \DecValTok{2} \SpecialCharTok{==} \DecValTok{0}\NormalTok{)\{}
        \FunctionTok{print}\NormalTok{(number)}
\NormalTok{    \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 2
## [1] 4
## [1] 6
## [1] 8
## [1] 10
## [1] 12
## [1] 14
## [1] 16
## [1] 18
## [1] 20
## [1] 22
## [1] 24
## [1] 26
## [1] 28
## [1] 30
## [1] 32
## [1] 34
## [1] 36
## [1] 38
## [1] 40
## [1] 42
## [1] 44
## [1] 46
## [1] 48
## [1] 50
## [1] 52
## [1] 54
## [1] 56
## [1] 58
## [1] 60
## [1] 62
## [1] 64
## [1] 66
## [1] 68
## [1] 70
## [1] 72
## [1] 74
## [1] 76
## [1] 78
## [1] 80
## [1] 82
## [1] 84
## [1] 86
## [1] 88
## [1] 90
## [1] 92
## [1] 94
## [1] 96
## [1] 98
## [1] 100
\end{verbatim}

\hypertarget{nested-for-loops}{%
\subsubsection{Nested for loops}\label{nested-for-loops}}

We can use a for loop within another for loop to iterate over two things at once (e.g., rows and columns of a matrix).

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{(i }\ControlFlowTok{in} \DecValTok{1}\SpecialCharTok{:}\DecValTok{5}\NormalTok{)\{}
  \ControlFlowTok{for}\NormalTok{(j }\ControlFlowTok{in} \DecValTok{1}\SpecialCharTok{:}\DecValTok{5}\NormalTok{)\{}
    \FunctionTok{print}\NormalTok{(}\FunctionTok{paste}\NormalTok{(i,j))}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "1 1"
## [1] "1 2"
## [1] "1 3"
## [1] "1 4"
## [1] "1 5"
## [1] "2 1"
## [1] "2 2"
## [1] "2 3"
## [1] "2 4"
## [1] "2 5"
## [1] "3 1"
## [1] "3 2"
## [1] "3 3"
## [1] "3 4"
## [1] "3 5"
## [1] "4 1"
## [1] "4 2"
## [1] "4 3"
## [1] "4 4"
## [1] "4 5"
## [1] "5 1"
## [1] "5 2"
## [1] "5 3"
## [1] "5 4"
## [1] "5 5"
\end{verbatim}

\hypertarget{the-ifelse-function}{%
\subsubsection{\texorpdfstring{The \texttt{ifelse} function}{The ifelse function}}\label{the-ifelse-function}}

Sometimes you want to do one thing if a condition is true and a different thing if the condition is false (rather than do nothing, as in previous examples). The \texttt{ifelse} function allows you to do this for entire vectors without using for loops.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{v }\OtherTok{=} \DecValTok{0}\SpecialCharTok{:}\DecValTok{10}
\FunctionTok{ifelse}\NormalTok{(v}\SpecialCharTok{\textgreater{}}\DecValTok{5}\NormalTok{, }\AttributeTok{yes =}\NormalTok{ T, }\AttributeTok{no =}\NormalTok{ F)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] 1 1 1 1 1 1 0 0 0 0 0
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ifelse}\NormalTok{(v }\SpecialCharTok{\textgreater{}} \DecValTok{5}\NormalTok{, v}\SpecialCharTok{*}\DecValTok{2}\NormalTok{, v)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1]  0  1  2  3  4  5 12 14 16 18 20
\end{verbatim}

\texttt{ifelse} returns a value with the same shape as \texttt{v} which is filled with elements selected from either yes or no depending on whether the element of test is \texttt{TRUE} or \texttt{FALSE}.

\hypertarget{functions}{%
\subsection{Functions}\label{functions}}

Functions are R objects that evaluate a set of input arguments and return an output. This is the syntax we use in R to create functions:

Arguments are a set of variable names that will be used within the function

Arguments can be:

\begin{itemize}
\tightlist
\item
  Required.
\item
  Optional (they are assigned a default value).
\item
  Adjustable length (each of these parameters is accessed with ..1, ..2, etc.).
\end{itemize}

The function return is specified by calling the function \texttt{return(x)}. Sometimes it is not necessary, and the result of the last evaluated expression will be returned. It is recommended to use it for legibility.

The function below has a required parameter (a) and an optional parameter (b).

Parameter b, being optional, if it is not passed in the call, will take the value 1.

The function has two returns:

\begin{itemize}
\tightlist
\item
  When b equals zero (with return)
\item
  When b is not equal to zero (without return)
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{z }\OtherTok{=} \DecValTok{1}
\NormalTok{do\_something }\OtherTok{=} \ControlFlowTok{function}\NormalTok{(a, }\AttributeTok{b =} \DecValTok{1}\NormalTok{) \{}
    \ControlFlowTok{if}\NormalTok{ (b }\SpecialCharTok{==} \DecValTok{0}\NormalTok{)}
        \FunctionTok{return}\NormalTok{(}\DecValTok{0}\NormalTok{)}
\NormalTok{    z }\OtherTok{=}\NormalTok{ z }\SpecialCharTok{+}\NormalTok{ a}\SpecialCharTok{*}\NormalTok{b }\SpecialCharTok{+}\NormalTok{ a}\SpecialCharTok{/}\NormalTok{b}
\NormalTok{    z}
\NormalTok{\}}

\FunctionTok{do\_something}\NormalTok{(}\DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 11
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{do\_something}\NormalTok{(}\DecValTok{4}\NormalTok{,}\DecValTok{4}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 18
\end{verbatim}

\hypertarget{domain-of-variables-in-functions}{%
\subsubsection{Domain of variables in functions}\label{domain-of-variables-in-functions}}

When a function is invoked, a new memory frame is created for it.

Each memory frame is inside the call stack, the first frame corresponding to the global environment.

Each function call will create a local frame.

The names of the variables within a function are resolved in the following order:

\begin{itemize}
\tightlist
\item
  Local environment.
\item
  Parent environment (functions defined within functions).
\item
  \ldots{}
\item
  Global environment.
\end{itemize}

Thus, a variable that is defined within a function is not available outside the function.

\hypertarget{replicating-code-with-functions}{%
\subsubsection{Replicating code with functions}\label{replicating-code-with-functions}}

As in any programming environment, the functions are very useful in order to replicate code by specifying certain parameters. Remember the countdown example? Below we have converted the same code into a function to decide the initial value of this process.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{countdown }\OtherTok{=} \ControlFlowTok{function}\NormalTok{(}\AttributeTok{count =} \DecValTok{5}\NormalTok{)\{}
  \ControlFlowTok{while}\NormalTok{ (count }\SpecialCharTok{\textgreater{}=} \DecValTok{0}\NormalTok{)\{}
    \FunctionTok{print}\NormalTok{ (count)}
\NormalTok{    count }\OtherTok{=}\NormalTok{ count }\SpecialCharTok{{-}} \DecValTok{1}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

By default, the countdown starts in 5,

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{countdown}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 5
## [1] 4
## [1] 3
## [1] 2
## [1] 1
## [1] 0
\end{verbatim}

But we can change the \texttt{count} parameter, so it will start in the number we specify

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{countdown}\NormalTok{(}\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 3
## [1] 2
## [1] 1
## [1] 0
\end{verbatim}

\hypertarget{the-apply-family}{%
\subsection{\texorpdfstring{The \texttt{apply} Family}{The apply Family}}\label{the-apply-family}}

The \texttt{apply()} family pertains to the R base package and is populated with functions to manipulate slices of data from matrices, arrays, lists and dataframes in a repetitive way. These functions allow crossing the data in a number of ways and avoid explicit use of loop constructs. They act on an input list, matrix or array and apply a named function with one or several optional arguments.

The called function could be:

\begin{itemize}
\tightlist
\item
  An aggregating function, like for example the mean, or the sum (that return a number or scalar);
\item
  Other transforming or subsetting functions; and
\item
  Other vectorized functions, which yield more complex structures like lists, vectors, matrices, and arrays.
\end{itemize}

The \texttt{apply()} functions form the basis of more complex combinations and helps to perform operations with very few lines of code. More specifically, the family is made up of the \texttt{apply()}, \texttt{lapply()}, \texttt{sapply()}, \texttt{vapply()}, \texttt{mapply()}, \texttt{rapply()}, and \texttt{tapply()} functions.

But how and when should we use these?

Well, this depends on the structure of the data that you want to operate on and the format of the output that you need.

\hypertarget{apply-function}{%
\subsubsection{\texorpdfstring{\texttt{apply()} Function}{apply() Function}}\label{apply-function}}

Let's start with the godfather of the family, \texttt{apply()}, which operates on arrays. For simplicity, we will use 2D arrays, which are also known as matrices.

The R base manual tells you that it's called as follows: \texttt{apply(X,\ MARGIN,\ FUN,\ ...)} where:

\begin{itemize}
\tightlist
\item
  \texttt{X} is an array or a matrix if the dimension of the array is 2;
\item
  \texttt{MARGIN} is a variable defining how the function is applied: when \texttt{MARGIN=1}, it applies over rows, whereas with \texttt{MARGIN=2}, it works over columns. Note that when you use the construct \texttt{MARGIN=c(1,2)}, it applies to both rows and columns; and
\item
  \texttt{FUN}, which is the function that you want to apply to the data. It can be any R function, including a User Defined Function (UDF).
\end{itemize}

Let's construct a 5 x 6 matrix and imagine you want to sum the values of each column.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Construct a 5x6 matrix}
\NormalTok{X }\OtherTok{=} \FunctionTok{matrix}\NormalTok{(}\FunctionTok{rnorm}\NormalTok{(}\DecValTok{30}\NormalTok{), }\AttributeTok{nrow=}\DecValTok{5}\NormalTok{, }\AttributeTok{ncol=}\DecValTok{6}\NormalTok{)}

\CommentTok{\# Sum the values of each column with \textasciigrave{}apply()\textasciigrave{}}
\FunctionTok{apply}\NormalTok{(X, }\DecValTok{2}\NormalTok{, sum)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  3.3068149  0.7576652 -1.7653971  4.3518894  2.3963091  2.3626304
\end{verbatim}

Remember that in R, a matrix can be seen as a collection of line vectors when you cross the matrix from top to bottom (along the vertical line 1, which specifies the dimension or margin 1), or as a list of columns vectors, spanning the matrix left to right along the dimension or margin 2.

That means that the instruction you have just entered, depicted in figure 1, translates into: ``apply the function `sum' to the matrix X along margin 2 (by column), summing up the values of each column.

Note that, to avoid cluttering the picture, just one of the columns is highlighted.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Construct a 5x6 matrix}
\NormalTok{X }\OtherTok{=} \FunctionTok{matrix}\NormalTok{(}\FunctionTok{rnorm}\NormalTok{(}\DecValTok{30}\NormalTok{), }\AttributeTok{nrow=}\DecValTok{5}\NormalTok{, }\AttributeTok{ncol=}\DecValTok{6}\NormalTok{)}

\CommentTok{\# Sum the values of each column with \textasciigrave{}apply()\textasciigrave{}}
\FunctionTok{apply}\NormalTok{(X, }\DecValTok{2}\NormalTok{, sum)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] -0.03206613 -1.80367548  1.05338074  0.33361302 -1.38118072  4.71834634
\end{verbatim}

You end up with a line vector containing the sums of the values of each column.

The output of the above code, a line vector, would have also been given if you summed along the lines of the matrix. This is how R displays the result.

\hypertarget{the-lapply-function}{%
\subsubsection{\texorpdfstring{The \texttt{lapply()} Function}{The lapply() Function}}\label{the-lapply-function}}

You want to apply a given function to every element of a list and obtain a list as a result. When you execute \texttt{?lapply}, you see that the syntax looks like the \texttt{apply()} function.

The difference is that:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  It can be used for other objects like dataframes, lists or vectors; and
\item
  The output returned is a list (which explains the ``l'' in the function name), which has the same number of elements as the object passed to it.
\end{enumerate}

To see how this works, create a few matrices and extract from each a given column.

This is a quite common operation performed on real data when making comparisons or aggregations from different dataframes.

Again, you start by specifying the object of interest, the list \texttt{Mylist.} You use the standard R selection operator \texttt{{[}} and then omit the first parameter (which therefore translates into ``any'', that's why you see the two commas).

Next, you specify the second parameter, which is \texttt{2}: our margin is `column'. So you extract the second column from all the matrices within the list.

In the right-hand side of figure 2, you can see an alternative extraction: this time you omit the first parameter, and you get the first row from each of the matrices. Our toy example, depicted in the last figure can be coded as:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Create a list of matrices}
\NormalTok{A }\OtherTok{=} \FunctionTok{matrix}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{9}\NormalTok{, }\AttributeTok{nrow =} \DecValTok{3}\NormalTok{)}
\NormalTok{B }\OtherTok{=} \FunctionTok{matrix}\NormalTok{(}\DecValTok{4}\SpecialCharTok{:}\DecValTok{15}\NormalTok{, }\AttributeTok{nrow =} \DecValTok{4}\NormalTok{)}
\NormalTok{C }\OtherTok{=} \FunctionTok{cbind}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\DecValTok{8}\NormalTok{,}\DecValTok{9}\NormalTok{,}\DecValTok{10}\NormalTok{), }\FunctionTok{c}\NormalTok{(}\DecValTok{8}\NormalTok{,}\DecValTok{9}\NormalTok{,}\DecValTok{10}\NormalTok{))}

\NormalTok{MyList }\OtherTok{=} \FunctionTok{list}\NormalTok{(A,B,C)}

\CommentTok{\# Extract the 2nd column from \textasciigrave{}MyList\textasciigrave{} with the selection operator \textasciigrave{}[\textasciigrave{} with \textasciigrave{}lapply()\textasciigrave{}}
\FunctionTok{lapply}\NormalTok{(MyList,}\StringTok{"["}\NormalTok{, , }\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [[1]]
## [1] 4 5 6
## 
## [[2]]
## [1]  8  9 10 11
## 
## [[3]]
## [1]  8  9 10
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Extract the 1st row from \textasciigrave{}MyList\textasciigrave{}}
\FunctionTok{lapply}\NormalTok{(MyList,}\StringTok{"["}\NormalTok{, }\DecValTok{1}\NormalTok{, )}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [[1]]
## [1] 1 4 7
## 
## [[2]]
## [1]  4  8 12
## 
## [[3]]
## [1] 8 8
\end{verbatim}

A few notes to the code above:

\begin{itemize}
\tightlist
\item
  The \texttt{{[}} notation is the select operator. Remember, for example, that to extract all the elements of the third line of B requires: \texttt{B{[}3,{]}};
\item
  The \texttt{{[}{[}\ {]}{]}} notation expresses the fact that we are dealing with lists: {[}{[}2{]}{]} means the second element of the list. This is also shown in the output given by R;
\item
  The output is a list with as many elements as the element in the input; and
\item
  Note that you could also have extracted a single element for each matrice, like this: \texttt{lapply(MyList,"{[}",\ 1,\ 2)}
\end{itemize}

\hypertarget{the-sapply-function}{%
\subsubsection{\texorpdfstring{The \texttt{sapply()} Function}{The sapply() Function}}\label{the-sapply-function}}

The \texttt{sapply()} function works like \texttt{lapply()}, but it tries to simplify the output to the most elementary data structure that is possible. And indeed, \texttt{sapply()} is a `wrapper' function for \texttt{lapply()}.

Essentially, \texttt{sapply()} calls \texttt{lapply()} on its input and then applies the following algorithm:

\begin{itemize}
\tightlist
\item
  If the result is a list where every element is length 1, then a vector is returned
\item
  If the result is a list where every element is a vector of the same length (\textgreater{} 1), a matrix is returned.
\item
  If neither of the above simplifications can be performed then a list is returned
\end{itemize}

An example may help to understand this: let's say that you want to repeat the extraction operation of a single element as in the last example, but now take the first element of the second row (indexes 2 and 1) for each matrix.

Applying the \texttt{lapply()} function would give us a list unless you pass \texttt{simplify=FALSE} as a parameter to \texttt{sapply()}. Then, a list will be returned. See how it works in the code chunk below:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Return a list with \textasciigrave{}lapply()\textasciigrave{}}
\FunctionTok{lapply}\NormalTok{(MyList,}\StringTok{"["}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{1}\NormalTok{ )}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [[1]]
## [1] 2
## 
## [[2]]
## [1] 5
## 
## [[3]]
## [1] 9
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Return a vector with \textasciigrave{}sapply()\textasciigrave{}}
\FunctionTok{sapply}\NormalTok{(MyList,}\StringTok{"["}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{1}\NormalTok{ )}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 2 5 9
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Return a list with \textasciigrave{}sapply()\textasciigrave{}}
\FunctionTok{sapply}\NormalTok{(MyList,}\StringTok{"["}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{1}\NormalTok{, }\AttributeTok{simplify=}\NormalTok{F)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 2 5 9
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Return a vector with \textasciigrave{}unlist()\textasciigrave{}}
\FunctionTok{unlist}\NormalTok{(}\FunctionTok{lapply}\NormalTok{(MyList,}\StringTok{"["}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{1}\NormalTok{ ))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 2 5 9
\end{verbatim}

\hypertarget{apply-family-examples}{%
\subsection{\texorpdfstring{\texttt{apply} Family Examples}{apply Family Examples}}\label{apply-family-examples}}

Let's use the \texttt{mtcars} built-in dataset to see some examples:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{head}\NormalTok{(mtcars)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##                    mpg cyl disp  hp drat    wt  qsec vs am gear carb
## Mazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4
## Mazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4
## Datsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1
## Hornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1
## Hornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2
## Valiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1
\end{verbatim}

In this datset we can appreciate some characteristics of different cars. Imagine we want to obtain the average of each feature. We can use the \texttt{apply} function for that purpose:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{apply}\NormalTok{(mtcars, }\DecValTok{2}\NormalTok{, mean)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##        mpg        cyl       disp         hp       drat         wt       qsec 
##  20.090625   6.187500 230.721875 146.687500   3.596563   3.217250  17.848750 
##         vs         am       gear       carb 
##   0.437500   0.406250   3.687500   2.812500
\end{verbatim}

We could also obtain the mean of each call in all the features, but it doesn't make sense at all. Let's generate a list of four items to provide an example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{data }\OtherTok{=} \FunctionTok{list}\NormalTok{(}\AttributeTok{item1 =} \DecValTok{1}\SpecialCharTok{:}\DecValTok{4}\NormalTok{,}
            \AttributeTok{item2 =} \FunctionTok{rnorm}\NormalTok{(}\DecValTok{10}\NormalTok{),}
            \AttributeTok{item3 =} \FunctionTok{rnorm}\NormalTok{(}\DecValTok{20}\NormalTok{,}\DecValTok{1}\NormalTok{),}
            \AttributeTok{item4 =} \FunctionTok{rnorm}\NormalTok{(}\DecValTok{100}\NormalTok{,}\DecValTok{5}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

We can get the mean of each of the items we have in the list using the \texttt{lapply} function.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{lapply}\NormalTok{(data, mean)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## $item1
## [1] 2.5
## 
## $item2
## [1] 0.08497086
## 
## $item3
## [1] 1.052272
## 
## $item4
## [1] 4.877802
\end{verbatim}

The last slide provides a simple example where each list item is simply a vector of numeric values. However, consider the case where you have a list that contains data frames and you would like to loop through each list item and perform a function to the data frame. In this case we can embed an \texttt{apply} function within an \texttt{lapply} function.

For example, the following creates a list for R's built in beaver data sets. The lapply function loops through each of the two list items and uses apply to calculate the mean of the columns in both list items.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{beaver\_data }\OtherTok{=} \FunctionTok{list}\NormalTok{(}\AttributeTok{beaver1 =}\NormalTok{ beaver1, }
                    \AttributeTok{beaver2 =}\NormalTok{ beaver2)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{lapply}\NormalTok{(beaver\_data, }\ControlFlowTok{function}\NormalTok{(x) }\FunctionTok{apply}\NormalTok{(x, }\DecValTok{2}\NormalTok{, mean))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## $beaver1
##          day         time         temp        activ 
## 3.462018e+02 1.312018e+03 3.686219e+01 5.263158e-02 
## 
## $beaver2
##       day      time      temp     activ 
##  307.1300 1446.2000   37.5967    0.6200
\end{verbatim}

To illustrate the differences between \texttt{lapply} and \texttt{sapply} functions we can use the previous example using a list with the beaver data and compare the outputs:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{lapply}\NormalTok{(beaver\_data, }\ControlFlowTok{function}\NormalTok{(x) }\FunctionTok{round}\NormalTok{(}\FunctionTok{apply}\NormalTok{(x, }\DecValTok{2}\NormalTok{, mean), }\DecValTok{2}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## $beaver1
##     day    time    temp   activ 
##  346.20 1312.02   36.86    0.05 
## 
## $beaver2
##     day    time    temp   activ 
##  307.13 1446.20   37.60    0.62
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sapply}\NormalTok{(beaver\_data, }\ControlFlowTok{function}\NormalTok{(x) }\FunctionTok{round}\NormalTok{(}\FunctionTok{apply}\NormalTok{(x, }\DecValTok{2}\NormalTok{, mean), }\DecValTok{2}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##       beaver1 beaver2
## day    346.20  307.13
## time  1312.02 1446.20
## temp    36.86   37.60
## activ    0.05    0.62
\end{verbatim}

Finally, I would like to show a \texttt{tapply} example. We didn't dig into this function because we had already seen it in previous sessions, but it also deserves it's own applied example.

\textbf{Remember}: \texttt{tapply()} is used to apply a function over subsets of a vector. It is primarily used when we have the following circumstances:

\begin{itemize}
\tightlist
\item
  A dataset that can be broken up into groups (via categorical variables - aka factors)
\item
  We desire to break the dataset up into groups
\item
  Within each group, we want to apply a function
\end{itemize}

The arguments to tapply() are as follows:

\begin{itemize}
\tightlist
\item
  \texttt{x} is a vector
\item
  \texttt{INDEX} is a factor or a list of factors (or else they are coerced to factors)
\item
  \texttt{FUN} is a function to be applied
\item
  \texttt{...} contains other arguments to be passed FUN
\item
  \texttt{simplify}, should we simplify the result?
\end{itemize}

\begin{verbatim}
# syntax of tapply function
tapply(x, INDEX, FUN, ..., simplify = TRUE)
\end{verbatim}

To provide an example we'll use the built in mtcars dataset and calculate the mean of the \texttt{mpg} variable grouped by the \texttt{cyl} variable.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{tapply}\NormalTok{(mtcars}\SpecialCharTok{$}\NormalTok{mpg, mtcars}\SpecialCharTok{$}\NormalTok{cyl, mean)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##        4        6        8 
## 26.66364 19.74286 15.10000
\end{verbatim}

Now let's say you want to calculate the mean for each column in the mtcars dataset grouped by the cylinder categorical variable. To do this you can embed the \texttt{tapply} function within the \texttt{apply} function.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{apply}\NormalTok{(mtcars, }\DecValTok{2}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x) }\FunctionTok{tapply}\NormalTok{(x, mtcars}\SpecialCharTok{$}\NormalTok{cyl, mean))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##        mpg cyl     disp        hp     drat       wt     qsec        vs
## 4 26.66364   4 105.1364  82.63636 4.070909 2.285727 19.13727 0.9090909
## 6 19.74286   6 183.3143 122.28571 3.585714 3.117143 17.97714 0.5714286
## 8 15.10000   8 353.1000 209.21429 3.229286 3.999214 16.77214 0.0000000
##          am     gear     carb
## 4 0.7272727 4.090909 1.545455
## 6 0.4285714 3.857143 3.428571
## 8 0.1428571 3.285714 3.500000
\end{verbatim}

\hypertarget{the-pipe-operator}{%
\section{The pipe operator}\label{the-pipe-operator}}

In practice we often have to call functions in a sequence. Suppose for example you have a vector of numbers. Of those numbers you would like to first compute the absolute value. Then you would like to compute the logarithm of those absolute values. Last you would like to compute the mean of those numbers. In standard R we can write this as

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \SpecialCharTok{{-}}\DecValTok{5}\SpecialCharTok{:{-}}\DecValTok{1}
\FunctionTok{mean}\NormalTok{(}\FunctionTok{log}\NormalTok{(}\FunctionTok{abs}\NormalTok{(x)))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.9574983
\end{verbatim}

Such nested code where we apply multiple functions over the same line of code becomes cluttered and difficult to read.

For this reason the package \texttt{magrittr} introduces the so-called pipe operator \texttt{\%\textgreater{}\%} which makes the above code much more readable. Consider the same example using the pipe operator.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(magrittr)}
\NormalTok{x }\OtherTok{\textless{}{-}} \SpecialCharTok{{-}}\DecValTok{5}\SpecialCharTok{:{-}}\DecValTok{1}
\NormalTok{x }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{abs}\NormalTok{() }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{log}\NormalTok{() }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{mean}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.9574983
\end{verbatim}

The above code can be seen as follows: consider the vector \texttt{x} and apply the function \texttt{abs} over its entries. Then apply the function \texttt{log} over the resulting vector and last apply the function \texttt{mean}.

The code is equivalent to standard R but it is simpler to read. So sometimes it is preferrable to code using pipes instead of standard R syntax.

\hypertarget{plotting}{%
\section{Plotting}\label{plotting}}

R has great plotting capabilities. Details about plotting functions and a discussion of when different representations are most appropriate are beyond the scope of these notes. This is just to provide you with a list of functions:

\begin{itemize}
\item
  \texttt{barplot} creates a barplot: notice that you first need to construct a so-called contingency table using the function \texttt{table}.
\item
  \texttt{hist} creates an histogram;
\item
  \texttt{boxplot} creates a boxplot;
\item
  \texttt{plot} creates a scatterplot;
\end{itemize}

There are many functions to customize such plots, and again details can be found in the references given. A package which is often used to create nice data visualization is \texttt{ggplot2}.

\hypertarget{probability-basics}{%
\chapter{Probability Basics}\label{probability-basics}}

Our final aim is to be able to mimic real-world systems as close as possible. In most scenarios we will not know with certainty how things unfold. For instance, we will rarely know the times at which customers enter a shop or the time it will take an employee to complete a task. Let's think again at the donut shop example. The time it takes an employee to serve a costumer depends on the time it takes the customer to specify the order, the number and types of donuts requested, the type of payment etc. To an external observer all these possible causes of variation of serving times appear to be random and due to chance: they cannot be predicted with certainty.

For this reason we will in general assume a probabilistic model for the various components of a simulation. This chapter gives a review of possible models as well as their characteristics.

\hypertarget{discrete-random-variables}{%
\section{Discrete Random Variables}\label{discrete-random-variables}}

We start introducing discrete random variables. Here we will not enter in all the mathematical details and some concepts will be introduced only intuitively. However, some mathematical details will be given for some concepts.

In order to introduce discrete random variables, let's inspect each of the words:

\begin{itemize}
\item
  \emph{variable}: this means that there is some process that takes some value. It is a synonym of function as you have studied in other mathematics classes.
\item
  \emph{random}: this means that the variable takes values according to some probability distribution.
\item
  \emph{discrete}: this refers to the possible values that the variable can take. In this case it is a countable (possibly infinite) set of values.
\end{itemize}

In general we denote a random variable as \(X\) and its possible values as \(\mathbb{X}=\{x_1,x_2,x_3,\dots\}\). The set \(\mathbb{X}\) is called the sample space of \(X\). In real-life we do not know which value in the set \(\mathbb{X}\) the random variable will take.

Let's consider some examples.

\begin{itemize}
\item
  The number of donuts sold in a day in a shop is a discrete random variable which can take values \(\{0,1,2,3,\dots\}\), that is the non-negative integers. In this case the number of possible values is infinite.
\item
  The outcome of a COVID-19 test can be either positive or negative but in advance we do not know which one. So this can be denoted as a discrete random variable taking values in \(\{negative,positive\}\). It is customary to denote the elements of the sample space \(\mathbb{X}\) as numbers. For instance, we could let \(negative = 0\) and \(positive = 1\) and the sample space would be \(\mathbb{X}=\{0,1\}\).
\item
  The number shown on the face of a dice once thrown is a discrete random variable taking values in \(\mathbb{X}=\{1,2,3,4,5,6\}\).
\end{itemize}

\hypertarget{probability-mass-function}{%
\subsection{Probability Mass Function}\label{probability-mass-function}}

The outcome of a discrete random variable is in general unknown, but we want to associate to each outcome, that is to each element of \(\mathbb{X}\), a number describing its likelihood. Such a number is called a probability and it is in general denoted as \(P\).

The \emph{probability mass function} (or pmf) of a random variable \(X\) with sample space \(\mathbb{X}\) is defined as
\[
p(x)=P(X=x), \hspace{1cm} \mbox{for all } x\in\mathbb{X}
\]
So for any outcome \(x\in\mathbb{X}\) the pmf describes the likelihood of that outcome happening.

Recall that pmfs must obey two conditions:

\begin{itemize}
\item
  \(p(x)\geq 0\) for all \(x\in\mathbb{X}\);
\item
  \(\sum_{x\in\mathbb{X}}p(x)=1\).
\end{itemize}

So the pmf associated to each outcome is a non-negative number such that the sum of all these numbers is equal to one.

Let's consider an example at this stage. Suppose a biased dice is thrown such that the numbers 3 and 6 are twice as likely to appear than the other numbers. A pmf describing such a situation is the following:

\begin{longtable}[]{@{}ccccccc@{}}
\toprule
\(x\) & 1 & 2 & 3 & 4 & 5 & 6 \\
\midrule
\endhead
\(p(x)\) & 1/8 & 1/8 & 2/8 & 1/8 & 1/8 & 2/8 \\
\bottomrule
\end{longtable}

It is apparent that all numbers \(p(x)\) are non-negative and that their sum is equal to 1: so \(p(x)\) is a pmf. Figure \ref{fig:disc-pmf} gives a graphical visualization of such a pmf.

\begin{figure}
\centering
\includegraphics{bookdownproj_files/figure-latex/disc-pmf-1.pdf}
\caption{\label{fig:disc-pmf}PMF for the biased dice example}
\end{figure}

\hypertarget{cumulative-distribution-function}{%
\subsection{Cumulative Distribution Function}\label{cumulative-distribution-function}}

Whilst you should have been already familiar with the concept of pmf, the next concept may appear to be new. However, you have actually used it multiple times when computing Normal probabilities with the tables.

We now define what is usually called the \emph{cumulative distribution function} (or cdf) of a random variable \(X\). The cdf of \(X\) at the point \(x\in\mathbb{X}\) is
\[
F(x) = P(X \leq x) = \sum_{y \leq x} p(y)
\]
that is the probability that \(X\) is less or equal to \(x\) or equally the sum of the pmf of \(X\) for all values less than \(x\).

Let's consider the dice example to illustrate the idea of cdf and consider the following values \(x\):

\begin{itemize}
\item
  \(x=0\): we compute \(F(0) = P(X\leq 0 )= 0\) since \(X\) cannot take any values less or equal than zero;
\item
  \(x= 0.9\): we compute \(F(0.9)= P(X\leq 0.9) = 0\) using the same reasoning as before;
\item
  \(x = 1\): we compute \(F(1)= P(X\leq 1) = P(X=1) = 1/8\) since \(X\) can take the value 1 with probability 1/8;
\item
  \(x = 1.5\): we compute \(F(1.5) = P(X\leq 1.5) = P(X=1) = 1/8\) using the same reasoning as before;
\item
  \(x = 3.2\): we compute \(F(3.2)=P(X\leq 3.2)=P(X=1)+ P(X=2) + P(X=3)=1/8 + 1/8 + 2/8 = 0.5\) since \(X\) can take the values 1, 2 and 3 which are less than 3.2;
\end{itemize}

We can compute in a similar way the cdf for any value \(x\). A graphical visualization of the resulting CDF is given in Figure \ref{fig:disc-cdf}.

\begin{figure}
\centering
\includegraphics{bookdownproj_files/figure-latex/disc-cdf-1.pdf}
\caption{\label{fig:disc-cdf}CDF for the biased dice example}
\end{figure}

The plot highlights some properties of CDFs which can proved hold in general for any discrete CDF:

\begin{itemize}
\item
  it is a step function which is also non-decreasing;
\item
  on the left-hand-side it takes the value 0;
\item
  on the right-hand-side it takes the value 1.
\end{itemize}

\hypertarget{summaries}{%
\subsection{Summaries}\label{summaries}}

The pmf and the cdf fully characterize a discrete random variable \(X\). Often however we want to compress that information into a single number which still retains some aspect of the distribution of \(X\).

The \emph{expectation} or \emph{mean} of a random variable \(X\) denoted as \(E(X)\) is defined as
\[
E(X)=\sum_{x\in\mathbb{X}}xp(x)
\]
The expectation can be interpreted as the mean value of a large number of observations from the random variable \(X\). Consider again the example of the biased dice. The expectation is
\[
E(X)=1\cdot1/8 + 2\cdot1/8 + 3\cdot 2/8 + 4\cdot 1/8 + 5\cdot 1/8 + 6\cdot 2/8 = 3.75
\]
So if we were to throw the dice a large number of time, we would expect the average of the number shown to be 3.75.

The \emph{median} of the random variable \(X\) denoted as \(m(X)\) is defined as the value \(x\) such that \(P(X\leq x)\) is larger or equal to 0.5 and \(P(X\geq x)\) is larger or equal to 0.5. It is defined as the middle value of the distribution. For the dice example the median is the value 3: indeed \(P(X\leq 3 ) = P(X=1)+P(X=2)+P(X=3)=0.5 \geq 0.5\) and \(P(X\geq 3) = P(X=3) + P(X=4) + P(X=5) + P(X=6) = 0.75 \geq 0.5\).

The \emph{mode} of the random variable \(X\) is the value \(x\) such that \(p(x)\) is largest: it is the value of the random variable which is expected to happen most frequently. Notice that the mode may not be unique: in that case we say that the distribution of \(X\) is bimodal. The example of the biased dice as an instance of a bimodal distribution: the values 3 and 6 are the equally likely and they have the largest pmf.

The above three summaries are measures of \emph{centrality}: they describe the central tendency of \(X\). Next we consider measures of \emph{variability}: such measures will quantify the spread or the variation of the possible values of \(X\) around the mean.

The \emph{variance} of the discrete random variable \(X\) is the expectation of the squared difference between the random variable and its mean. Formally it is defined as
\[
V(X)=E((X-E(X))^2)=\sum_{x\in\mathbb{X}}(x-E(X))^2p(x)
\]
In general we will not compute variance by hand. The following R code computes the variance of the random variable associated to the biased dice.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \DecValTok{1}\SpecialCharTok{:}\DecValTok{6}  \CommentTok{\# outcomes of X}
\NormalTok{px }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\SpecialCharTok{/}\DecValTok{8}\NormalTok{,}\DecValTok{1}\SpecialCharTok{/}\DecValTok{8}\NormalTok{,}\DecValTok{2}\SpecialCharTok{/}\DecValTok{8}\NormalTok{,}\DecValTok{1}\SpecialCharTok{/}\DecValTok{8}\NormalTok{,}\DecValTok{1}\SpecialCharTok{/}\DecValTok{8}\NormalTok{,}\DecValTok{2}\SpecialCharTok{/}\DecValTok{8}\NormalTok{)  }\CommentTok{\# pmf of X}
\NormalTok{Ex }\OtherTok{\textless{}{-}} \FunctionTok{sum}\NormalTok{(x}\SpecialCharTok{*}\NormalTok{px)  }\CommentTok{\# Expectation of X}
\NormalTok{Vx }\OtherTok{\textless{}{-}} \FunctionTok{sum}\NormalTok{((x}\SpecialCharTok{{-}}\NormalTok{Ex)}\SpecialCharTok{\^{}}\DecValTok{2}\SpecialCharTok{*}\NormalTok{px)  }\CommentTok{\# Variance of X}
\NormalTok{Vx}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 2.9375
\end{verbatim}

The \emph{standard deviation} of the discrete random variable \(X\) is the square root of \(V(X)\).

\hypertarget{notable-discrete-variables}{%
\section{Notable Discrete Variables}\label{notable-discrete-variables}}

In the previous section we gave a generic definition of discrete random variables and discussed the conditions that a pmf must obey. We considered the example of a biased dice and constructed a pmf for that specific example.

There are situations that often happen in practice: for instance the case of experiments with binary outcomes. For such cases random variables with specific pmfs are given a name and their properties are well known and studied.

In this section we will consider three such distributions: Bernoulli, Binomial and Poisson.

\hypertarget{bernoulli-distribution}{%
\subsection{Bernoulli Distribution}\label{bernoulli-distribution}}

Consider an experiment or a real-world system where there can only be two outcomes:

\begin{itemize}
\item
  a toss of a coin: heads or tails;
\item
  the result of a COVID test: positive or negative;
\item
  the status of a machine: broken or working;
\end{itemize}

By default one outcome happens with some probability, that we denote as \(\theta\in [0,1]\) and the other with probability \(1-\theta\).

Such a situation is in general modeled using the so-called \emph{Bernoulli distribution} with parameter \(\theta\). One outcome is associated to the number 1 (usually referred to as sucess) and the other is associated to the number 0 (usually referred to as failure). So \(P(X=1)=p(1)=\theta\) and \(P(X=0)=p(0)=1-\theta\).

The above pmf can be more coincisely written as
\[
p(x)=\left\{
\begin{array}{ll}
\theta^x(1-\theta)^{1-x}, & x=0,1\\
0, & \mbox{otherwise}
\end{array}
\right.
\]
The mean and variance of the Bernoulli distribution can be easily computed as
\[
E(X)=0\cdot(1-\theta)+ 1\cdot\theta=\theta,
\]
and
\[
V(X)=(0-\theta)^2(1-\theta)+(1-\theta)^2\theta=\theta^2(1-\theta)+(1-\theta)^2\theta=\cdots = \theta(1-\theta)
\]

Figure \ref{fig:bernoulli} reports the pmf and the cdf of a Bernoulli random variable with parameter 0.3.

\begin{figure}
\centering
\includegraphics{bookdownproj_files/figure-latex/bernoulli-1.pdf}
\caption{\label{fig:bernoulli}PMF (left) and CDF (right) of a Bernoulli random variable with parameter 0.3}
\end{figure}

\hypertarget{binomial-distribution}{%
\subsection{Binomial Distribution}\label{binomial-distribution}}

The Bernoulli random variable is actually a very special case of the so-called \emph{Binomial} random variable. Consider experiments of the type discussed for Bernoullis: coin tosses, COVID tests etc. Now suppose that instead of having just one trial, each of these experiments are repeated multiple times. Consider the following assumptions:

\begin{itemize}
\item
  each experiment is repeated \(n\) times;
\item
  each time there is a probability of success \(\theta\);
\item
  the outcome of each experiment is independent of the others.
\end{itemize}

Let's think of tossing a coin \(n\) times. Then we would expect that the probability of showing heads is the same for all tosses and that the result of previous tosses does not affect others. So this situation appears to meet the above assumptions and can be modeled by what we call a Binomial random variable.

Formally, the random variable \(X\) is a Binomial random variable with parameters \(n\) and \(\theta\) if it denotes the number of successes of \(n\) independent Bernoulli random variables, all with parameter \(\theta\).

The pmf of a Binomial random variable with parameters \(n\) and \(\theta\) can be written as:
\[
p(x)=\left\{
\begin{array}{ll}
\binom{n}{x}\theta^{x}(1-\theta)^{n-x}, & x = 0,1,\dots,n\\
0, & \mbox{otherwise}
\end{array}
\right.
\]
Let's try and understand the formula by looking term by term.

\begin{itemize}
\item
  if \(X=x\) there are \(x\) successes and each success has probability \(\theta\) - so \(\theta^x\) counts the overall probability of successes
\item
  if \(X=x\) there are \(n-x\) failures and each failure has probability \(1-\theta\) - so \((1-\theta)^{n-x}\) counts the overall probability of failures
\item
  failures and successes can appear according to many orders. To see this, suppose that \(x=1\): there is only one success out of \(n\) trials. This could have been the first attempt, the second attempt or the \(n\)-th attempt. The term \(\binom{n}{x}\) counts all possible ways the outcome \(x\) could have happened.
\end{itemize}

The Bernoulli distribution can be seen as a special case of the Binomial where the parameter \(n\) is fixed to 1.

We will not show why this is the case but the expectation and the variance of the Binomial random variable with parameters \(n\) and \(\theta\) can be derived as
\[
E(X)=np, \hspace{2cm} V(X)=np(1-p)
\]
The formulae for the Bernoulli can be retrieved by setting \(n=1\).

Figure \ref{fig:binom} shows the pmf of two Binomial distributions both with parameter \(n=10\) and with \(\theta=0.3\) (left) and \(\theta=0.8\). For the case \(\theta=0.3\) we can see that it is more likely that there are a small number of successes, whilst for \(\theta=0.8\) a large number of successes is more likely.

\begin{figure}
\centering
\includegraphics{bookdownproj_files/figure-latex/binom-1.pdf}
\caption{\label{fig:binom}PMF of a Binomial random variable with parameters n = 10 and theta = 0.3 (left) and theta = 0.8 (right)}
\end{figure}

R provides a straightforward implementation of the Binomial distribution through the functions \texttt{dbinom} for the pmf and \texttt{pbinom} for the cdf. They require three arguments:

\begin{itemize}
\item
  first argument is the value at which to compute the pmf or the cdf;
\item
  \texttt{size} is the parameter \(n\) of the Binomial;
\item
  \texttt{prob} is the parameter \(\theta\) of the Binomial.
\end{itemize}

So for instance

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{dbinom}\NormalTok{(}\DecValTok{3}\NormalTok{, }\AttributeTok{size =} \DecValTok{10}\NormalTok{, }\AttributeTok{prob =} \FloatTok{0.5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.1171875
\end{verbatim}

returns \(P(X=3)=p(3)\) for a Binomial random variable with parameter \(n=10\) and \(\theta = 0.5\).

Similarly,

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{pbinom}\NormalTok{(}\DecValTok{8}\NormalTok{, }\AttributeTok{size =} \DecValTok{20}\NormalTok{, }\AttributeTok{prob =} \FloatTok{0.2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.9900182
\end{verbatim}

returns \(P(X\leq 8) = F(8)\) for a Binomial random variable with parameter \(n=20\) and \(\theta = 0.2\).

\hypertarget{poisson-distribution}{%
\subsection{Poisson Distribution}\label{poisson-distribution}}

The last class of discrete random variables we discuss is the so-called \emph{Poisson} distribution. Whilst for Bernoulli and Binomial we had an interpretation of why the pmf took its specific form by associating it to independent binary experiments each with an equal probability of success, for the Poisson there is no such an interpretation.

A discrete random variable \(X\) has a Poisson distribution with parameter \(\lambda\) if its pmf is
\[
p(x)=\left\{
\begin{array}{ll}
\frac{e^{-\lambda}\lambda^x}{x!}, & x = 0,1,2,3,\dots\\
0, & \mbox{otherwise}
\end{array}
\right.
\]
where \(\lambda > 0\).

So the sample space of a Poisson random variable is the set of all non-negative integers.

One important characteristic of the Poisson distribution is that its mean and variance are equal to the parameter \(\lambda\), that is
\[
E(X)= V(X) = \lambda.
\]

Figure @ref\{fig:poisson\} gives an illustration of the form of the pmf of the Poisson distribution for two parameter choices: \(\lambda=1\) (left) and \(\lambda = 4\) (right). The x-axis is shown until \(x=10\) but recall that the Poisson is defined over all non-negative integers. For the case \(\lambda=1\) we can see that the outcomes 0 and 1 have the largest probability - recall that \(E(X)=0\). For the case \(\lambda = 4\) the outcomes \(x = 2,3,4,5\) have the largest probability.

\begin{figure}
\centering
\includegraphics{bookdownproj_files/figure-latex/poisson-1.pdf}
\caption{\label{fig:poisson}PMF of a Poisson random variable with parameter 1 (left) and 4 (right)}
\end{figure}

R provides a straightforward implementation of the Poisson distribution through the functions \texttt{dpois} for the pmf and \texttt{ppois} for the cdf. They require three arguments:

\begin{itemize}
\item
  first argument is the value at which to compute the pmf or the cdf;
\item
  \texttt{lambda} is the parameter \(\lambda\) of the Poisson;
\end{itemize}

So for instance

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{dpois}\NormalTok{(}\DecValTok{3}\NormalTok{, }\AttributeTok{lambda =} \DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.06131324
\end{verbatim}

returns \(P(X=3)=p(3)\) for a Poisson random variable with parameter \(\lambda = 1\).

Similarly,

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ppois}\NormalTok{(}\DecValTok{8}\NormalTok{, }\AttributeTok{lambda =} \DecValTok{4}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.9786366
\end{verbatim}

returns \(P(X\leq 8) = F(8)\) for a Poisson random variable with parameter \(\lambda = 4\).

\hypertarget{some-examples}{%
\subsection{Some Examples}\label{some-examples}}

We next consider two examples to see in practice the use of the Binomial and Poisson distributions.

\hypertarget{probability-of-marriage}{%
\subsubsection{Probability of Marriage}\label{probability-of-marriage}}

A recent survey indicated that 82\% of single women aged 25 years old will be married in their lifetime. Compute

\begin{itemize}
\item
  the probability of at most 3 women will be married in a sample of 20;
\item
  the probability of at least 90 women will be married in sample of 100;
\item
  the probability of two or three women in a sample of 20 will never be married.
\end{itemize}

The above situation can be modeled by a Binomial random variable where the parameter \(n\) depends on the question and \(\theta = 0.82\).

The first question requires us to compute \(P(X\leq 3)= F(3)\) where \(X\) is Binomial with parameters \(n=20\) and \(\theta =0.82\). Using R

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{pbinom}\NormalTok{(}\DecValTok{3}\NormalTok{, }\AttributeTok{size =} \DecValTok{10}\NormalTok{, }\AttributeTok{prob =} \FloatTok{0.82}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.0004400767
\end{verbatim}

The second question requires us to compute \(P(X\geq 90)\) where \(X\) is a Binomial random variable with parameters \(n=100\) and \(\theta = 0.82\). Notice that
\[
P(X\geq 90) = 1 - P(X< 90) = 1 - P(X\leq 89) = 1 - F(89).
\]
Using R

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{1} \SpecialCharTok{{-}} \FunctionTok{pbinom}\NormalTok{(}\DecValTok{89}\NormalTok{, }\AttributeTok{size =} \DecValTok{100}\NormalTok{,  }\AttributeTok{prob =} \FloatTok{0.82}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.02003866
\end{verbatim}

For the third question, notice that saying two women out of 20 will never be married is equal to 18 out of 20 will be married. Therefore we need to compute \(P(X=17) + P(X=18)= p(17) + p(18)\) where \(X\) is a Binomial random variable with parameters \(n=20\) and \(\theta = 0.82\). Using R

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sum}\NormalTok{(}\FunctionTok{dbinom}\NormalTok{(}\DecValTok{17}\SpecialCharTok{:}\DecValTok{18}\NormalTok{, }\AttributeTok{size =} \DecValTok{20}\NormalTok{, }\AttributeTok{prob =} \FloatTok{0.82}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.4007631
\end{verbatim}

\hypertarget{the-bad-stuntman}{%
\subsubsection{The Bad Stuntman}\label{the-bad-stuntman}}

A stuntman injures himself an average of three times a year. Use the Poisson probability formula to calculate the probability that he will be injured:

\begin{itemize}
\item
  4 times a year
\item
  Less than twice this year.
\item
  More than three times this year.
\end{itemize}

The above situation can be modeled as a Poisson distribution \(X\) with parameter \(\lambda = 3\).

The first question requires us to compute \(P(X=4)\) which using R can be computed as

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{dpois}\NormalTok{(}\DecValTok{4}\NormalTok{, }\AttributeTok{lambda =}\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.1680314
\end{verbatim}

The second question requires us to compute \(P(X<2) = P(X=0)+P(X=1)= F(1)\) which using R can be computed as

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ppois}\NormalTok{(}\DecValTok{1}\NormalTok{,}\AttributeTok{lambda=}\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.1991483
\end{verbatim}

The third question requires us to compute \(P(X>3) = 1 - P(X\leq 2) = 1 - F(2)\) which using R can be computed as

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{1} \SpecialCharTok{{-}} \FunctionTok{ppois}\NormalTok{(}\DecValTok{2}\NormalTok{, }\AttributeTok{lambda =} \DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.5768099
\end{verbatim}

\hypertarget{continuous-random-variables}{%
\section{Continuous Random Variables}\label{continuous-random-variables}}

Our attention now turns to continuous random variables. These are in general more technical and less intuitive than discrete ones. You should not worry about all the technical details, since these are in general not important, and focus on the interpretation.

A continuous random variable \(X\) is a random variable whose sample space \(\mathbb{X}\) is an interval or a collection of intervals. In general \(\mathbb{X}\) may coincide with the set of real numbers \(\mathbb{R}\) or some subset of it. Examples of continuous random variables:

\begin{itemize}
\item
  the pressure of a tire of a car: it can be any positive real number;
\item
  the current temperature in the city of Madrid: it can be any real number;
\item
  the height of the students of Simulation and Modeling to understand change: it can be any real number.
\end{itemize}

Whilst for discrete random variables we considered summations over the elements of \(\mathbb{X}\), i.e.~\(\sum_{x\in\mathbb{X}}\), for continuous random variables we need to consider integrals over appropriate intervals.

You should be more or less familiar with these from previous studies of calculus. But let's give an example. Consider the function \(f(x)=x^2\) computing the squared of a number \(x\). Suppose we are interested in this function between the values -1 and 1, which is plotted by the red line in Figure \ref{fig:x-sq}. Consider the so-called integral \(\int_{-1}^{1}x^2dx\): this coincides with the area delimited by the function and the x-axis. In Figure \ref{fig:x-sq} the blue area is therefore equal to \(\int_{-1}^{1}x^2dx\).

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ggplot}\NormalTok{(}\AttributeTok{data =} \FunctionTok{data.frame}\NormalTok{(}\AttributeTok{x =} \FunctionTok{seq}\NormalTok{(}\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{,}\DecValTok{1}\NormalTok{,}\FloatTok{0.01}\NormalTok{), }\AttributeTok{y =} \FunctionTok{seq}\NormalTok{(}\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{,}\DecValTok{1}\NormalTok{,}\FloatTok{0.01}\NormalTok{)}\SpecialCharTok{\^{}}\DecValTok{2}\NormalTok{), }\FunctionTok{aes}\NormalTok{(x,y)) }\SpecialCharTok{+} \FunctionTok{geom\_line}\NormalTok{(}\AttributeTok{lwd =} \FloatTok{1.3}\NormalTok{, }\AttributeTok{col=} \StringTok{"red"}\NormalTok{) }\SpecialCharTok{+} \FunctionTok{geom\_area}\NormalTok{(}\AttributeTok{alpha=}\FloatTok{0.6}\NormalTok{, }\AttributeTok{fill =} \StringTok{"lightskyblue2"}\NormalTok{) }\SpecialCharTok{+}  \FunctionTok{theme\_bw}\NormalTok{() }
\end{Highlighting}
\end{Shaded}

\begin{figure}

{\centering \includegraphics[width=0.5\linewidth]{bookdownproj_files/figure-latex/x-sq-1} 

}

\caption{Plot of the squared function and the area under its curve}\label{fig:x-sq}
\end{figure}

We will not be interested in computing integrals ourselves, so if you do not know/remember how to do it, there is no problem!

\hypertarget{probability-density-function}{%
\subsection{Probability Density Function}\label{probability-density-function}}

Discrete random variable are easy to work with in the sense that there exists a function, that we called probability mass function, such that \(p(x)=P(X=x)\), that is the value of that function in the point \(x\) is exactly the probability that \(X=x\).

Therefore we may wonder if this is true for a continuous random variable too. Sadly, the answer is no and probabilities for continuous random variables are defined in a slightly more involved way.

Let \(X\) be a continuous random variable with sample space \(\mathbb{X}\). The probability that \(X\) takes values in the interval \([a,b]\) is given by
\[
P(a\leq X \leq b) = \int_{a}^bf(x)dx
\]
where \(f(x)\) is called the \emph{probability density function} (pdf in short). Pdfs, just like pmfs must obey two conditions:

\begin{itemize}
\item
  \(f(x)\geq 0\) for all \(x\in\mathbb{X}\);
\item
  \(\int_{x\in\mathbb{X}}f(x)dx=1\).
\end{itemize}

So in the discrete case the pmf is defined exactly as the probability. In the continuous case the pdf is the function such that its integral is the probability that random variable takes values in a specific interval.

As a consequence of this definition notice that for any specific value \(x_0\in\mathbb{X}\), \(P(X=x_0)=0\) since
\[
\int_{x_0}^{x_0}f(x)dx = 0.
\]

Let's consider an example. The waiting time of customers of a donuts shop is believed to be random and to follow a random variable whose pdf is
\[
f(x) = \left\{
\begin{array}{ll}
\frac{1}{4}e^{-x/4}, & x\geq 0\\
0, & \mbox{otherwise}
\end{array}
\right.
\]

The pdf is drawn in Figure \ref{fig:exp} by the red line. One can see that \(f(x)\geq 0\) for all \(x\geq 0\) and one could also compute that it integrates to one.

Therefore the probability that the waiting time is between any two values \((a,b)\) can be computed as
\[
\int_a^b\frac{1}{4}e^{-x/4}dx.
\]
In particular if we were interested in the probability that the waiting time is between two and five minutes, corresponding to the shaded area in Figure \ref{fig:exp}, we could compute it as
\[
P(2<X<5)=\int_2^5f(x)dx=\int_{2}^5\frac{1}{4}e^{-x/4}dx= 0.32
\]

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{data }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{(}\AttributeTok{x=}\FunctionTok{seq}\NormalTok{(}\FloatTok{0.01}\NormalTok{,}\DecValTok{15}\NormalTok{,}\FloatTok{0.05}\NormalTok{),}\AttributeTok{y=}\FunctionTok{dexp}\NormalTok{(}\FunctionTok{seq}\NormalTok{(}\FloatTok{0.01}\NormalTok{,}\DecValTok{15}\NormalTok{,}\FloatTok{0.05}\NormalTok{),}\DecValTok{1}\SpecialCharTok{/}\DecValTok{4}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Warning: Removed 240 rows containing missing values (position_stack).
\end{verbatim}

\begin{figure}

{\centering \includegraphics[width=0.5\linewidth]{bookdownproj_files/figure-latex/exp-1} 

}

\caption{Probability density function for the waiting time in the donut shop example}\label{fig:exp}
\end{figure}

Notice that since \(P(X=x_0)=0\) for any \(x_0\in\mathbb{X}\), we also have that
\[
P(a\leq X \leq b)=P(a < X \leq b) = P(a\leq X < b) = P(a<X<b).
\]

\hypertarget{cumulative-distribution-function-1}{%
\subsection{Cumulative Distribution Function}\label{cumulative-distribution-function-1}}

For a continuous random variable \(X\) the cumulative distribution function (cdf) is equally defined as
\[
F(x) = P(X \leq x),
\]
where now
\[
P(X \leq x) = P(X < x) = \int_{-\infty}^xf(t)dt.
\]
so the summation is substituted by an integral.

Let's consider again the donut shop example as an illustration. The cdf is defined as
\[
F(x)=\int_{-\infty}^xf(t)dt = \int_{-\infty}^x\frac{1}{4}e^{-x/4}.
\]
This integral can be solved and \(F(x)\) can be calculated as
\[
F(x)= 1- e^{-x/4},
\]
which is plotted in Figure \ref{fig:expcdf}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{seq}\NormalTok{(}\SpecialCharTok{{-}}\DecValTok{2}\NormalTok{,}\DecValTok{20}\NormalTok{,}\FloatTok{0.5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{figure}

{\centering \includegraphics[width=0.5\linewidth]{bookdownproj_files/figure-latex/expcdf-1} 

}

\caption{Cumulative distribution function for the waiting time at the donut shop}\label{fig:expcdf}
\end{figure}

We can notice that the cdf has similar properties as in the discrete case: it is non-decreasing, on the left-hand side is zero and on the right-hand side tends to zero.

In the continuous case, one can prove that cdfs and pdfs are related as
\[
f(x)=\frac{d}{dx}F(x).
\]

\hypertarget{summaries-1}{%
\subsection{Summaries}\label{summaries-1}}

Just as for discrete random variables, we may want to summarize some features of a continuous random variable into a unique number. The same set of summaries exists for continuous random variables, which are almost exactly defined as in the discrete case (integrals are used instead of summations).

\begin{itemize}
\item
  \emph{mean}: the mean of a continuous random variable \(X\) is defined as
  \[
   E(X) = \int_{-\infty}^{+\infty}xf(x)dx
   \]
\item
  \emph{median}: the median of a continuous random variable \(X\) is defined as the value \(x\) such that \(P(X\leq x) = 0.5\) or equally \(F(x)=0.5\).
\item
  \emph{mode}: the mode of a continuous random variable \(X\) is defined the value \(x\) such that \(f(x)\) is largest.
\item
  \emph{variance}: the variance of a continuous random variable \(X\) is defined as
  \[
   V(X)=\int_{-\infty}^{+\infty}(x-E(X))^2f(x)dx
   \]
\item
  \emph{standard deviation}: the standard deviation of a continuous random variable \(X\) is defined as \(\sqrt{V(X)}\).
\end{itemize}

\hypertarget{notable-continuous-distribution}{%
\section{Notable Continuous Distribution}\label{notable-continuous-distribution}}

As in the discrete case, there are some types of continuous random variables that are used frequently and therefore are given a name and their proprieties are well-studied.

\hypertarget{uniform-distribution}{%
\subsection{Uniform Distribution}\label{uniform-distribution}}

The first, and simplest, continuous random variable we study is the so-called (continuous) \emph{uniform} distribution. We say that a random variable \(X\) is uniformly distributed on the interval \([a,b]\) if its pdf is
\[
f(x)=\left\{ 
\begin{array}{ll}
\frac{1}{b-a}, & a\leq x \leq b\\
0, & \mbox{otherwise} 
\end{array}
\right.
\]
This is plotted in Figure \ref{fig:unipdf} for choices of parameters \(a=2\) and \(b=6\)

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\FunctionTok{seq}\NormalTok{(}\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{,}\FloatTok{0.01}\NormalTok{),}\FunctionTok{seq}\NormalTok{(}\DecValTok{2}\NormalTok{,}\DecValTok{6}\NormalTok{,}\FloatTok{0.01}\NormalTok{),}\FunctionTok{seq}\NormalTok{(}\DecValTok{6}\NormalTok{,}\DecValTok{9}\NormalTok{,}\FloatTok{0.01}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{figure}

{\centering \includegraphics[width=0.5\linewidth]{bookdownproj_files/figure-latex/unipdf-1} 

}

\caption{Probability density function for a uniform random variable with parameters a = 2 and b = 6}\label{fig:unipdf}
\end{figure}

By looking at the pdf we see that it is a flat, constant line between the values \(a\) and \(b\). This implies that the probability that \(X\) takes values between two values \(x_0\) and \(x_1\) only dependens on the length of the interval \((x_0,x_1)\).

Its cdf can be derived as
\[
F(x)=\left\{
\begin{array}{ll}
0, & x<a\\
\frac{x-a}{b-a}, & a\leq x \leq b\\
1, & x>b
\end{array}
\right.
\]
and this is plotted in Figure \ref{fig:unicdf}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\FunctionTok{seq}\NormalTok{(}\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{,}\FloatTok{0.01}\NormalTok{),}\FunctionTok{seq}\NormalTok{(}\DecValTok{2}\NormalTok{,}\DecValTok{6}\NormalTok{,}\FloatTok{0.01}\NormalTok{),}\FunctionTok{seq}\NormalTok{(}\DecValTok{6}\NormalTok{,}\DecValTok{9}\NormalTok{,}\FloatTok{0.01}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{figure}

{\centering \includegraphics[width=0.5\linewidth]{bookdownproj_files/figure-latex/unicdf-1} 

}

\caption{Cumulative distribution function for a uniform random variable with parameters a = 2 and b = 6}\label{fig:unicdf}
\end{figure}

The mean and variance of a uniform can be derived as
\[
E(X)=\frac{a+b}{2}, \hspace{1cm} V(X)=\frac{(b-a)^2}{12}.
\]
So the mean is equal to the middle point of the interval \((a,b)\).

The uniform distribution will be fundamental in simulation. We will see that the starting point to simulate random numbers from any distribution will require the simulation of random numbers uniformly distributed between 0 and 1.

R provides an implementation of the uniform random variable with the functions \texttt{dunif} and \texttt{punif} whose details are as follows:

\begin{itemize}
\item
  the first argument is the value at which to compute the function;
\item
  the second argument, \texttt{min}, is the parameter \(a\), by default equal to zero;
\item
  the third argument, \texttt{max}, is the parameter \(b\), by default equal to one.
\end{itemize}

So for instance

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{dunif}\NormalTok{(}\DecValTok{5}\NormalTok{, }\AttributeTok{min =} \DecValTok{2}\NormalTok{, }\AttributeTok{max =} \DecValTok{6}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.25
\end{verbatim}

computes the pdf at the point 5 of a uniform random variable with parameters \(a=2\) and \(b=6\).

Conversely,

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{punif}\NormalTok{(}\FloatTok{0.5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.5
\end{verbatim}

computes the cdf at the point 0.5 of a uniform random variable with parameters \(a=0\) and \(b=1\).

\hypertarget{exponential-distribution}{%
\subsection{Exponential Distribution}\label{exponential-distribution}}

The second class of continuous random variables we will study are the so-called \emph{exponential} random variables. We have actually already seen such a random variable in the donut shop example. More generally, we say that a continuous random variable \(X\) is exponential with parameter \(\lambda>0\) if its pdf is
\[
f(x) = \left\{
\begin{array}{ll}
\lambda e^{-\lambda x}, & x\geq 0\\
0, & \mbox{otherwise}
\end{array}
\right.
\]

Figure \ref{fig:exppdf1} reports the pdf of exponential random variables for various choices of the parameter \(\lambda\).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{values }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\FloatTok{0.25}\NormalTok{,}\DecValTok{1}\NormalTok{,}\FloatTok{2.5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{figure}

{\centering \includegraphics[width=0.5\linewidth]{bookdownproj_files/figure-latex/exppdf1-1} 

}

\caption{Probability density function for exponential random variables}\label{fig:exppdf1}
\end{figure}

Exponential random variables are very often used in dynamic simulations since they are very often used to model interarrival times in process: for instance the time between arrivals of customers at the donut shop.

Its cdf can be derived as
\[
F(x)=\left\{
\begin{array}{ll}
0, & x <0\\
1-e^{-\lambda x}, & x\geq 0
\end{array}
\right.
\]
and is reported in Figure \ref{fig:expcdf1} for the same choices of parameters.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{values }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\FloatTok{0.25}\NormalTok{,}\DecValTok{1}\NormalTok{,}\FloatTok{2.5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{figure}

{\centering \includegraphics[width=0.5\linewidth]{bookdownproj_files/figure-latex/expcdf1-1} 

}

\caption{Cumulative distribution function for exponential random variables}\label{fig:expcdf1}
\end{figure}

The mean and the variance of exponential random variables can be computed as

\[
E(X)=\frac{1}{\lambda}, \hspace{1cm} V(X)=\frac{1}{\lambda^2}
\]

R provides an implementation of the uniform random variable with the functions \texttt{dexp} and \texttt{pexp} whose details are as follows:

\begin{itemize}
\item
  the first argument is the value at which to compute the function;
\item
  the second argument, \texttt{rate}, is the parameter \(\lambda\), by default equal to one;
\end{itemize}

So for instance

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{dexp}\NormalTok{(}\DecValTok{2}\NormalTok{, }\AttributeTok{rate =} \DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.007436257
\end{verbatim}

computes the pdf at the point 2 of an exponential random variable with parameter \(\lambda =3\).

Conversely

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{pexp}\NormalTok{(}\DecValTok{4}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.9816844
\end{verbatim}

computes the cdf at the point 4 of an exponential random variable with parameter \(\lambda =1\).

\hypertarget{normal-distribution}{%
\subsection{Normal Distribution}\label{normal-distribution}}

The last class of continuous random variables we consider is the so-called \emph{Normal} or \emph{Gaussian} random variable. They are the most used and well-known random variable in statistics and we will see why this is the case.

A continuous random variable \(X\) is said to have a Normal distribution with mean \(\mu\) and variance \(\sigma^2\) if its pdf is
\[
f(x) = \frac{1}{\sqrt{2\pi\sigma^2}}\exp\left(-\frac{1}{2}\frac{(x-\mu)^2}{\sigma^2}\right).
\]
Recall that
\[
E(X)=\mu, \hspace{1cm} V(X)=\sigma^2,
\]
and so the parameters have a straightforward interpretation in terms of mean and variance.

Figure \ref{fig:norm} shows the form of the pdf of the Normal distribution for various choices of the parameters. On the left we have Normal pdfs for \(\sigma^2=1\) and various choices of \(\mu\): we can see that \(\mu\) shifts the plot on the x-axis. On the right we have Normal pdfs for \(\mu=1\) and various choices of \(\sigma^2\): we can see that all distributions are centered around the same value while they have a different spread/variability.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mu }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{,}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{figure}

{\centering \includegraphics[width=0.5\linewidth]{bookdownproj_files/figure-latex/norm-1} 

}

\caption{Probability density function for normal random variables}\label{fig:norm}
\end{figure}

The form of the Normal pdf is the well-known so-called bell-shaped function. We can notice some properties:

\begin{itemize}
\item
  it is symmetric around the mean: the function on the left-hand side and on the right-hand side of the mean is mirrored. This implies that the median is equal to the mean ;
\item
  the maximum value of the pdf occurs at the mean. This implies that the mode is equal to the mean (and therefore also the median).
\end{itemize}

The cdf of the Normal random variable with parameters \(\mu\) and \(\sigma^2\) is
\[
F(x) = P(X\leq x)=\int_{-\infty}^{+\infty}\frac{1}{\sqrt{2\pi\sigma^2}}\exp\left(-\frac{1}{2}\frac{(x-\mu)^2}{\sigma^2}\right)dx
\]

The cdf of the Normal for various choices of parameters is reported in Figure \ref{fig:pnorm}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mu }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{,}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{figure}

{\centering \includegraphics[width=0.5\linewidth]{bookdownproj_files/figure-latex/pnorm-1} 

}

\caption{Cumulative distribution function for normal random variables}\label{fig:pnorm}
\end{figure}

Unfortunately it is not possible to solve such an integral (as for example for the Uniform and the Exponential), and in general it is approximated using some numerical techniques. This is surprising considering that the Normal distribution is so widely used!!!

However, notice that we would need to compute such an approximation for every possible value of \((\mu,\sigma^2)\), depending on the distribution we want to use. This is unfeasible to do in practice.

There is a trick here, that you must have used multiple times already. We can transform a Normal \(X\) with parameters \(\mu\) and \(\sigma^2\) to the so-called \emph{standard Normal} random variable \(Z\), and viceversa, using the relationship:
\begin{equation}
 \label{eq:standard}
Z = \frac{X-\mu}{\sigma}, \hspace{1cm} X= \mu + \sigma Z.
\end{equation}
It can be shown that \(Z\) is a Normal random variable with parameter \(\mu=0\) and \(\sigma^2=1\).

The values of the cdf of the standard Normal random variable then need to be computed only once since \(\mu\) and \(\sigma^2\) are fixed. You have seen these numbers many many times in what are usually called the tables of the Normal distribution.

As a matter of fact you have also computed many times the cdf of a generic Normal random variable. First you computed \(Z\) using equation \eqref{eq:standard} and then looked at the Normal tables to derive that number.

Let's give some details about the standard Normal. Its pdf is
\[
\phi(z)=\frac{1}{\sqrt{2\pi}}\exp\left(-z^2/2\right).
\]
It can be seen that it is the same as the one of the Normal by setting \(\mu=0\) and \(\sigma^2=1\). Such a function is so important that it is given its own symbol \(\phi\).

The cdf is
\[
\Phi(z)=\int_{-\infty}^z\frac{1}{\sqrt{2\pi}}\exp\left(-x^2/2\right)dx
\]
Again this cannot be computed exactly, there is no closed-form expression. This is why you had to look at the tables instead of using a simple formula. The cdf of the standard Normal is also so important that it is given its own symbol \(\phi\).

Instead of using the tables, we can use R to tell us the values of Normal probabilities. R provides an implementation of the Normal random variable with the functions \texttt{dnorm} and \texttt{pnorm} whose details are as follows:

\begin{itemize}
\item
  the first argument is the value at which to compute the function;
\item
  the second argument, \texttt{mean}, is the parameter \(\mu\), by default equal to zero;
\item
  the third argument, \texttt{sd}, is the standard deviation, that is \(\sqrt{\sigma^2}\), by default equal to one.
\end{itemize}

So for instance

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{dnorm}\NormalTok{(}\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.004431848
\end{verbatim}

computes the value of the standard Normal pdf at the value three.

Similarly,

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{pnorm}\NormalTok{(}\FloatTok{0.4}\NormalTok{,}\DecValTok{1}\NormalTok{,}\FloatTok{0.5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.1150697
\end{verbatim}

compute the value of the Normal cdf with parameters \(\mu=1\) and \(\sqrt{\sigma^2}=0.5\) at the value 0.4.

\hypertarget{the-central-limit-theorem}{%
\section{The Central Limit Theorem}\label{the-central-limit-theorem}}

As a final topic in probability we will briefly discuss why the Normal distribution is so important and widely known. The reason behind this is the existence of a theorem, called the \emph{Central Limit Theorem} which is perhaps the most important theorem in probability which has far-reaching consequences in the world of statistics.

Let's first state theorem. Suppose you have random variables \(X_1,\dots, X_n\) which have the following properties:

\begin{itemize}
\item
  they are all independent of each other;
\item
  they all have the same mean \(\mu\);
\item
  the all have the same standard deviation \(\sigma^2\).
\end{itemize}

Consider the random variable
\[
\bar{X}_n= \frac{X_1+\cdots X_n}{n}.
\]
Then it holds that
\[
\lim_{n\rightarrow + \infty} \frac{\bar{X}_n-\mu}{\sigma/\sqrt{n}} = Z
\]
where \(Z\) is the standard normal random variable.

We can also state the theorem as
\[
\lim_{n\rightarrow + \infty} \bar{X}_n = Y
\]
where \(Y\) is a Normal random variable with mean \(\mu\) and variance \(\sigma^2/n\).

The interpretation of the Central Limit Theorem is as follows. The sample mean \(\bar{X}_n\) of independent random variables with the same mean and variance can be approximated by a Normal distribution, if the sample size \(n\) is large. Notice that we made no assumption whatsoever about the distribution of the \(X_i\)'s and still we were able to deduce the distribution of the sample mean.

The existence of this theorem is the reason why you used so often Normal probabilities to construct confidence intervals or to carry out tests of hypothesis. As you will continue study statistics, you will see that the assumption of Normality of data is made most often and is justified by the central limit theorem.

\hypertarget{random-number-generation}{%
\chapter{Random Number Generation}\label{random-number-generation}}

At the hearth of any simulation model there is the capability of creating numbers that mimic those we would expect in real life. In simulation modeling we will assume that specific processes will be distributed according to a specific random variable. For instance we will assume that an employee in a donut shop takes a random time to serve customers distributed according to a Normal random variable with mean \(\mu\) and variance \(\sigma^2\). In order to then carry out a simulation the computer will need to generate random serving times. This corresponds to simulating number that are distributed according to a specific distribution.

Let's consider an example. Suppose you managed to generate two sequences of numbers, say \texttt{x1} and \texttt{x2}. Your objective is to simulate numbers from a Normal distribution. The histograms of the two sequences are reported in Figure \ref{fig:seq} together with the estimated shape of the density. Clearly the sequence \texttt{x1} could be following a Normal distribution, since it is bell-shaped and reasonably symmetric. On the other hand, the sequence \texttt{x2} is not symmetric at all and does not resembles the density of a Normal.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p }\OtherTok{\textless{}{-}} \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{data.frame}\NormalTok{(}\AttributeTok{x1=}\FunctionTok{rnorm}\NormalTok{(}\DecValTok{700}\NormalTok{)), }\FunctionTok{aes}\NormalTok{(}\AttributeTok{x=}\NormalTok{x1))}\SpecialCharTok{+}
   \FunctionTok{geom\_histogram}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{y=}\NormalTok{..density..), }\AttributeTok{colour=}\StringTok{"black"}\NormalTok{, }\AttributeTok{fill=}\StringTok{"white"}\NormalTok{)}\SpecialCharTok{+}
 \FunctionTok{geom\_density}\NormalTok{(}\AttributeTok{alpha=}\NormalTok{.}\DecValTok{2}\NormalTok{, }\AttributeTok{fill=}\StringTok{"\#FF6666"}\NormalTok{)  }\SpecialCharTok{+} \FunctionTok{theme\_bw}\NormalTok{() }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
\end{verbatim}

\begin{figure}

{\centering \includegraphics[width=0.5\linewidth]{bookdownproj_files/figure-latex/seq-1} 

}

\caption{Histograms of two sequences of randomly generated numbers}\label{fig:seq}
\end{figure}

In this chapter we will learn how to characterize randomness in a computer and how to generate numbers that appear to be random realizations of a specific random variable. We will also learn how to check if a sequence of values can be a random realization from a specific random variable.

\hypertarget{properties-of-random-numbers}{%
\section{Properties of Random Numbers}\label{properties-of-random-numbers}}

The first step to simulate numbers from a distribution is to be able to independently simulate random numbers \(u_1,u_2,\dots,u_N\) from a continuous uniform distribution between zero and one. From the previous chapter, you should remember that such a random variables has pdf
\[
f(x)=\left\{
\begin{array}{ll}
1, & 0\leq x \leq 1\\
0, &\mbox{otherwise}
\end{array}
\right.
\]
and cdf
\[
F(x)=\left\{
\begin{array}{ll}
0, & x<0\\
x, & 0\leq x \leq 1\\
1, &\mbox{otherwise}
\end{array}
\right.
\]
These two are plotted in Figure \ref{fig:uplot}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\FunctionTok{seq}\NormalTok{(}\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{,}\DecValTok{0}\NormalTok{,}\FloatTok{0.01}\NormalTok{),}\FunctionTok{seq}\NormalTok{(}\DecValTok{0}\NormalTok{,}\DecValTok{1}\NormalTok{,}\FloatTok{0.01}\NormalTok{),}\FunctionTok{seq}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{,}\FloatTok{0.01}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{figure}

{\centering \includegraphics[width=0.5\linewidth]{bookdownproj_files/figure-latex/uplot-1} 

}

\caption{Pdf (left) and cdf (right) of the continuous uniform between zero and one.}\label{fig:uplot}
\end{figure}

Its expectation is 1/2 and its variance is 1/12.

This implies that if we were to divide the interval \([0,1]\) into \(n\) sub-intervals of equal length, then we would expect in each interval to have \(N/n\) observations, where \(N\) is the total number of observations.

Figure \ref{fig:uhist} shows the histograms of two sequences of numbers between zero and one: whilst the one on the left resembles the pdf of a uniform distribution, the one on the right clearly does not (it is far from being flat) and therefore it is hard to believe that such numbers follow a uniform distribution.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p }\OtherTok{\textless{}{-}} \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{data.frame}\NormalTok{(}\AttributeTok{x1=}\FunctionTok{runif}\NormalTok{(}\DecValTok{10000}\NormalTok{)), }\FunctionTok{aes}\NormalTok{(}\AttributeTok{x=}\NormalTok{x1))}\SpecialCharTok{+}
   \FunctionTok{geom\_histogram}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{y=}\NormalTok{..density..),}\AttributeTok{binwidth=}\FloatTok{0.1}\NormalTok{,}\AttributeTok{center =} \FloatTok{0.05}\NormalTok{, }\AttributeTok{colour=}\StringTok{"black"}\NormalTok{, }\AttributeTok{fill=}\StringTok{"white"}\NormalTok{)  }\SpecialCharTok{+} \FunctionTok{theme\_bw}\NormalTok{() }
\end{Highlighting}
\end{Shaded}

\begin{figure}

{\centering \includegraphics[width=0.5\linewidth]{bookdownproj_files/figure-latex/uhist-1} 

}

\caption{Histograms from two sequences of numbers between zero and one.}\label{fig:uhist}
\end{figure}

The second requirement the numbers \(u_1,\dots,u_N\) need to respect is independence. This means that the probability of observing a value in a particular sub-interval of \((0,1)\) is independent of the previous values drawn.

Consider the following sequence of numbers:
\[
\begin{array}{cccccccccc}
0.25 & 0.72 & 0.18 & 0.63 & 0.49 & 0.88 & 0.23 & 0.78 & 0.02 & 0.52
\end{array}
\]
We can notice that numbers below and above 0.5 are alternating in the sequence. We would therefore believe that after a number less than 0.5 it is much more likely to observe a number above it. This breaks the assumption of independence.

\hypertarget{pseudo-random-numbers}{%
\section{Pseudo Random Numbers}\label{pseudo-random-numbers}}

We will investigate ways to simulate numbers using algorithms in a computer. For this reason such numbers are usually called \emph{pseudo-random} numbers. Pseudo means false, in the sense that the number are not really random! They are generated according to a deterministic algorithm whose aim is to imitate as closely as possible what randomness would look like. In particular, for numbers \(u_1,\dots,u_N\) it means that they should look like independence instances of a Uniform distribution between zero and one.

Possible departures from ideal numbers are:

\begin{itemize}
\item
  the numbers are not uniformly distributed;
\item
  the mean of the numbers might not be 1/2;
\item
  the variance of the numbers might not be 1/12;
\item
  the numbers might be discrete-valued instead of continuous;
\item
  independence might not hold.
\end{itemize}

We already looked at examples of departures from the assumptions, but we will later study how to assess these departures more formally.

Before looking at how we can construct pseudo-random numbers, let's discuss some important properties/considerations that need to be taken into account when generating pseudo-random numbers:

\begin{itemize}
\item
  the random generation should be very fast. In practice, we want to use random numbers to do other computations (for example simulate a little donut shop) and such computations might be computationally intensive: if random generation were to be slow, we would not be able to perform them.
\item
  the cycle of random generated numbers should be long. The cycle is the length of the sequence before numbers start to repeat themselves.
\item
  the random numbers should be repeatable. Given a starting point of the algorithm, it should be possible to repeat the exact same sequence of numbers. This is fundamental for debugging and for reproducibility.
\item
  the method should be applicable in any programming language/platform.
\item
  and of course most importantly, the random numbers should be independent and uniformly distributed.
\end{itemize}

Repeatability of the pseudo-random numbers is worth further consideration. It is fundamental in science to be able to reproduce experiments so that the validity of results can be assessed. In R there is a specific function that allows us to do this, which is called \texttt{set.seed}. It is customary to choose as starting point of an algorithm the current year. So henceforth you will see the command:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{2021}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

This ensures that every time the code following \texttt{set.seed} is run, the same results will be observed. We will give below examples of this.

\hypertarget{generating-pseudo-random-numbers}{%
\section{Generating Pseudo-Random Numbers}\label{generating-pseudo-random-numbers}}

The literature on generating pseudo-random numbers is now extremely vast and it is not our purpose to review it, neither for you to learn how such algorithms work.

\hypertarget{generating-pseudo-random-numbers-in-r}{%
\subsection{Generating Pseudo-Random Numbers in R}\label{generating-pseudo-random-numbers-in-r}}

R has all the capabilities to generate such numbers. This can be done with the function \texttt{runif}, which takes one input: the number of observations to generate. So for instance:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{2021}\NormalTok{)}
\FunctionTok{runif}\NormalTok{(}\DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] 0.4512674 0.7837798 0.7096822 0.3817443 0.6363238 0.7013460 0.6404389
##  [8] 0.2666797 0.8154215 0.9829869
\end{verbatim}

generates ten random numbers between zero and one. Notice that if we repeat the same code we get the same result since we fixed the so-called \emph{seed} of the simulation.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{2021}\NormalTok{)}
\FunctionTok{runif}\NormalTok{(}\DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] 0.4512674 0.7837798 0.7096822 0.3817443 0.6363238 0.7013460 0.6404389
##  [8] 0.2666797 0.8154215 0.9829869
\end{verbatim}

Conversely, if we were to simply run the code \texttt{runif(10)} we would get a different result.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{runif}\NormalTok{(}\DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] 0.02726706 0.83749040 0.60324073 0.56745337 0.82005281 0.25157128
##  [7] 0.50549403 0.86753810 0.95818157 0.54569770
\end{verbatim}

\hypertarget{linear-congruential-method}{%
\subsection{Linear Congruential Method}\label{linear-congruential-method}}

Although we will use the functions already implemented in R, it is useful to at least introduce one of the most classical algorithms to simulate random numbers, called the \emph{linear congruential method}.
This produces a sequence of integers \(x_1,x_2,x_3\) between 0 and \(m-1\) using the recursion:
\[
x_{i}=(ax_{i-1}+c)\mod m, \hspace{1cm} \mbox{for } i = 1,2,\dots
\]
Some comments:

\begin{itemize}
\item
  \(\mod m\) is the remainder of the integer division by \(m\). For instance \(5 \mod 2\) is one and \(4\mod 2\) is zero.
\item
  therefore, the algorithm generates integers between 0 and \(m-1\).
\item
  there are three parameters that need to be chosen \(a, c\) and \(m\).
\item
  the value \(x_0\) is the \emph{seed} of the algorithm.
\end{itemize}

Random numbers between zero and one can be derived by setting
\[
u_i= x_i/m.
\]

It can be shown that the method works well for specific choices of \(a\), \(c\) and \(m\), which we will not discuss here.

Let's look at an implementation.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lcm }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(N, x0, a, c, m)\{}
\NormalTok{   x }\OtherTok{\textless{}{-}} \FunctionTok{rep}\NormalTok{(}\DecValTok{0}\NormalTok{,N)}
\NormalTok{   x[}\DecValTok{1}\NormalTok{] }\OtherTok{\textless{}{-}}\NormalTok{ x0}
   \ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{2}\SpecialCharTok{:}\NormalTok{N) x[i] }\OtherTok{\textless{}{-}}\NormalTok{ (a}\SpecialCharTok{*}\NormalTok{x[i}\DecValTok{{-}1}\NormalTok{]}\SpecialCharTok{+}\NormalTok{c)}\SpecialCharTok{\%\%}\NormalTok{m}
\NormalTok{   u }\OtherTok{\textless{}{-}}\NormalTok{ x}\SpecialCharTok{/}\NormalTok{m}
   \FunctionTok{return}\NormalTok{(u)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{lcm}\NormalTok{(}\AttributeTok{N =} \DecValTok{8}\NormalTok{, }\AttributeTok{x0 =} \DecValTok{4}\NormalTok{, }\AttributeTok{a =} \DecValTok{13}\NormalTok{, }\AttributeTok{c =} \DecValTok{0}\NormalTok{, }\AttributeTok{m =} \DecValTok{64}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.0625 0.8125 0.5625 0.3125 0.0625 0.8125 0.5625 0.3125
\end{verbatim}

We can see that this specific choice of parameters is quite bad: it has cycle 4! After 4 numbers the sequence repeats itself and we surely would not like to use this in practice.

In general you should not worry of these issues, R does things properly for you!

\hypertarget{testing-randomness}{%
\section{Testing Randomness}\label{testing-randomness}}

Now we turn to the following question: given a sequence of numbers \(u_1,\dots,u_N\) how can we test if they are independent realizations of a Uniform random variable between zero and one?

We therefore need to check if the distribution of the numbers is uniform and if they are actually independent.

\hypertarget{testing-uniformity}{%
\subsection{Testing Uniformity}\label{testing-uniformity}}

A simple first method to check if the numbers are uniform is to create an histogram of the data and to see if the histogram is reasonably flat. We already saw how to assess this, but let's check if \texttt{runif} works well. Simple histograms can be created in \texttt{R} using \texttt{hist} (or if you want you can use \texttt{ggplot}).

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{2021}\NormalTok{)}
\NormalTok{u }\OtherTok{\textless{}{-}} \FunctionTok{runif}\NormalTok{(}\DecValTok{5000}\NormalTok{)}
\FunctionTok{hist}\NormalTok{(u)}
\end{Highlighting}
\end{Shaded}

\begin{figure}

{\centering \includegraphics[width=0.5\linewidth]{bookdownproj_files/figure-latex/hist-1} 

}

\caption{Histogram of a sequence of uniform numbers}\label{fig:hist}
\end{figure}

We can see that the histogram is reasonably flat and therefore the assumption of uniformity seems to hold.

Although the histogram is quite informative, it is not a fairly formal method. We could on the other hand look at tests of hypotheses of this form:
\begin{align*}
H_0: & \;\;u_i \mbox{ is uniform between zero and one, } i=1,2,\dots\\
H_a: & \;\;u_i \mbox{ is not uniform between zero and one, } i=1,2,\dots\\
\end{align*}

The null hypothesis is thus that the numbers are indeed uniform, whilst the alternative states that the numbers are not. If we reject the null hypothesis, which happens if the p-value of the test is very small (or smaller than a critical value \(\alpha\) of our choice), then we would believe that the sequence of numbers is not uniform.

There are various ways to carry out such a test, but we will consider here only one: the so-called \emph{Kolmogorov-Smirnov Test}. We will not give all details of this test, but only its interpretation and implementation.

In order to understand how the test works we need to briefly introduce the concept of \emph{empirical cumulative distribution function} or \emph{ecdf}. The ecdf \(\hat{F}\) is the cumulative distribution function computed from a sequence of \(N\) numbers as
\[
\hat{F}(t)= \frac{\mbox{numbers in the sequence }\leq t}{N}
\]

Let's consider the following example.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{data }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{(}\AttributeTok{u=} \FunctionTok{c}\NormalTok{(}\FloatTok{0.1}\NormalTok{,}\FloatTok{0.2}\NormalTok{,}\FloatTok{0.4}\NormalTok{,}\FloatTok{0.8}\NormalTok{,}\FloatTok{0.9}\NormalTok{))}
\FunctionTok{ggplot}\NormalTok{(data,}\FunctionTok{aes}\NormalTok{(u)) }\SpecialCharTok{+} \FunctionTok{stat\_ecdf}\NormalTok{(}\AttributeTok{geom =} \StringTok{"step"}\NormalTok{) }\SpecialCharTok{+} \FunctionTok{theme\_bw}\NormalTok{() }\SpecialCharTok{+} \FunctionTok{ylab}\NormalTok{(}\StringTok{"ECDF"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{figure}

{\centering \includegraphics[width=0.5\linewidth]{bookdownproj_files/figure-latex/ecdf-1} 

}

\caption{Ecdf of a simple sequence of numbers}\label{fig:ecdf}
\end{figure}

For instance, since there are 3 numbers out of 5 in the vector \texttt{u} that are less than 0.7, then \(\hat{F}(0.7)=3/5\).

The idea behind the Kolmogorov-Smirnov test is to quantify how similar the ecdf computed from a sequence of data is to the one of the uniform distribution which is represented by a straight line (see Figure \ref{fig:uplot}).

As an example consider Figure \ref{fig:Kol}. The step functions are computed from two different sequences of numbers between one and zero, whilst the straight line is the cdf of the uniform distribution. By looking at the plots, we would more strongly believe that the sequence in the left plot is uniformly distributed, since the step function is much more closer to the theoretical straight line.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{2021}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{figure}

{\centering \includegraphics{bookdownproj_files/figure-latex/Kol-1} 

}

\caption{Comparison between ecdf and cdf of the uniform for two sequences of numbers}\label{fig:Kol}
\end{figure}

The Kolmogorov-Smirnov test formally embeds this idea of similarity between the ecdf and the cdf of the uniform in a test of hypothesis. The function \texttt{ks.test} implements this test in R. For the two sequences in Figure @ref\{fig:Kol\} \texttt{u1} (left plot) and \texttt{u2} (right plot), the test can be implemented as following:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ks.test}\NormalTok{(u1,}\StringTok{"punif"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 
##  One-sample Kolmogorov-Smirnov test
## 
## data:  u1
## D = 0.11499, p-value = 0.142
## alternative hypothesis: two-sided
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ks.test}\NormalTok{(u2,}\StringTok{"punif"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 
##  One-sample Kolmogorov-Smirnov test
## 
## data:  u2
## D = 0.56939, p-value < 2.2e-16
## alternative hypothesis: two-sided
\end{verbatim}

From the results that the p-value of the test for the sequence \texttt{u1} is 0.142 and so we would not reject the null hypothesis that the sequence is uniformly distributed. On the other hand the p-value for the test over the sequence \texttt{u2} has an extremely small p-value therefore suggesting that we reject the null hypothesis and conclude that the sequence is not uniformly distributed. This confirms our intuition by looking at the plots in Figure \ref{fig:Kol}.

\hypertarget{testing-independence}{%
\subsection{Testing Independence}\label{testing-independence}}

The second requirement that a sequence of pseudo-random numbers must have is independence. We already saw an example of when this might happen: a high number was followed by a low number and vice versa.

We will consider tests of the form:

\begin{align*}
H_0: & \;\;u_1,\dots,u_N \mbox{ are independent }\\
H_a: & \;\;u_1,\dots,u_N \mbox{ are not independent }
\end{align*}

So the null hypothesis is that the sequence is of independent numbers against the alternative that they are not. If the p-value of such a test is small we would then reject the null-hypothesis of independence.

In order to devise such a test, we need to come up with a way to quantify how dependent numbers in a sequence are with each other. Again, there are many ways one could do this, but we consider here only one.

You should already be familiar with the idea of \emph{correlation}: this tells you how to variables are linearly dependent of each other. There is a similar idea which extends in a way correlation to the case when it is computed between a sequence of numbers and itself, which is called \emph{autocorrelation}. We will not give the details about this, but just the interpretation (you will learn a lot more about this in Time Series).

Let's briefly recall the idea behind correlation. Suppose you have two sequences of numbers \(u_1,\dots,u_N\) and \(w_1,\dots,w_N\). To compute the correlation you would look at the pairs \((u_1,w_1),(u_2,w_2),\dots, (u_N,w_N)\) and assess how related the numbers within a pair \((u_i,w_i)\) are. Correlation, which is a number between -1 and 1, assesses how related the sequences are: the closer the number is to one in absolute value, the stronger the relationship.

Now however we have just one sequence of numbers \(u_1,\dots,u_N\). So for instance we could look at pairs \((u_1,u_2), (u_2,u_3), \dots, (u_{N-1},u_{N})\) which consider two consecutive numbers and compute their correlation. Similarly we could compute the correlation between \((u_1,u_{1+k}), (u_2,u_{2+k}),\dots, (u_{N-k},u_N)\) between each number in the sequence and the one k-positions ahead. This is what we call \emph{autocorrelation of lag k}.

If autocorrelations of various lags are close to zero, this gives an indication that the data is independent. If on the other hand, the autocorrelation at some lags is large, then there is an indication of dependence in the sequence of random numbers. Autocorrelations are computed and plotted in \texttt{R} using \texttt{acf} and reported in Figure \ref{fig:acf}.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{2021}\NormalTok{)}
\NormalTok{u1 }\OtherTok{\textless{}{-}} \FunctionTok{runif}\NormalTok{(}\DecValTok{200}\NormalTok{)}
\FunctionTok{acf}\NormalTok{(u1)}
\end{Highlighting}
\end{Shaded}

\begin{figure}

{\centering \includegraphics[width=0.5\linewidth]{bookdownproj_files/figure-latex/acf-1} 

}

\caption{Autocorrelations for a sequence of random uniform numbers}\label{fig:acf}
\end{figure}

The bars in Figure \ref{fig:acf} are the autocorrelations at various lags, whilst the dashed blue lines are confidence bands: if a bar is within the bands it means that we cannot reject the hypothesis that the autocorrelation of the associated lag is equal to zero. Notice that the first bar is lag 0: it computes the correlation for the sample \((u_1,u_1),(u_2,u_2),\dots,(u_N,u_N)\) and therefore it is always equal to one. You should never worry about this bar. Since all the bars are within the confidence bands, we believe that all autocorrelations are not different from zero and consequently that the data is independent (it was indeed generated using `runif``).

Figure \ref{fig:acf2} reports the autocorrelations of a sequence of numbers which is not independent. Although the histogram shows that the data is uniformly distributed, we would not believe that the sequence is of independent numbers since autocorrelations are very large and outside the bands.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{u2 }\OtherTok{\textless{}{-}} \FunctionTok{rep}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{,}\AttributeTok{each =} \DecValTok{4}\NormalTok{,}\AttributeTok{times =} \DecValTok{10}\NormalTok{)}\SpecialCharTok{/}\DecValTok{10} \SpecialCharTok{+} \FunctionTok{rnorm}\NormalTok{(}\DecValTok{400}\NormalTok{,}\DecValTok{0}\NormalTok{,}\FloatTok{0.02}\NormalTok{) }
\NormalTok{u2 }\OtherTok{\textless{}{-}}\NormalTok{ (u2 }\SpecialCharTok{{-}} \FunctionTok{min}\NormalTok{(u2))}\SpecialCharTok{/}\NormalTok{(}\FunctionTok{max}\NormalTok{(u2)}\SpecialCharTok{{-}}\FunctionTok{min}\NormalTok{(u2))}
\FunctionTok{par}\NormalTok{(}\AttributeTok{mfrow=}\FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{))}
\FunctionTok{hist}\NormalTok{(u2)}
\FunctionTok{acf}\NormalTok{(u2)}
\end{Highlighting}
\end{Shaded}

\begin{figure}

{\centering \includegraphics{bookdownproj_files/figure-latex/acf2-1} 

}

\caption{Histogram and autocorrelations of a sequence of uniform numbers which are not independent}\label{fig:acf2}
\end{figure}

A test of hypothesis for independence can be created by checking if any of the autocorrelations up to a specific lag are different from zero. This is implemented in the function \texttt{Box.test} in R. The first input is the sequence of numbers to consider, the second is the largest lag we want to consider. Let's compute it for the two sequences \texttt{u1} and \texttt{u2} above.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{Box.test}\NormalTok{(u1, }\AttributeTok{lag =} \DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 
##  Box-Pierce test
## 
## data:  u1
## X-squared = 4.8518, df = 5, p-value = 0.4342
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{Box.test}\NormalTok{(u2, }\AttributeTok{lag =} \DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 
##  Box-Pierce test
## 
## data:  u2
## X-squared = 807.1, df = 5, p-value < 2.2e-16
\end{verbatim}

Here we chose a lag up to 5 (it is usually not useful to consider larger lags). The test confirms our observations of the autocorrelations. For the sequence \texttt{u1} generated with \texttt{runif} the test has a high p-value and therefore we cannot reject the hypothesis of independence. For the second sequence \texttt{u2} which had very large autocorrelations the p-value is very small and therefore we reject the hypothesis of independence.

\hypertarget{random-variate-generation}{%
\section{Random Variate Generation}\label{random-variate-generation}}

Up to this point we have investigated how to generate numbers between 0 and 1 and how to assess the quality of those randomly generated numbers.

For simulation models we want to be more generally able to simulate observations that appear to be realizations of random variables with known distributions. We now study how this can be done. But before this, let's see how R implements random variate generation.

\hypertarget{random-generation-in-r}{%
\subsection{Random Generation in R}\label{random-generation-in-r}}

In the next few sections we will learn results that allow for the simulation of random observations from generic distributions. No matter how the methods work, they have a very simple and straightforward implementation in R.

We have already learned that we can simulate observations from the uniform between zero and one using the code \texttt{runif(N)} where \texttt{N} is the number of observations to simulate. We can notice that it is similar to the commands \texttt{dunif} and \texttt{punif} we have already seen for the pdf and cdf of the uniform.

Not surprisingly we can generate observations from any random variable using the syntax \texttt{r} followed by the naming of the variable chosen. So for instance:

\begin{itemize}
\item
  \texttt{runif} generates random observations from the Uniform;
\item
  \texttt{rnorm} generates random observations from the Normal;
\item
  \texttt{rexp} generates random observations from the Exponential;
\item
  \texttt{rbinom} generates random observations from the Binomial;
\item
  \texttt{rpois} generates random observations from the Poisson;
\end{itemize}

Each of these functions takes as first input the number of observations that we want to simulate. They then have additional inputs that can be given, which depend on the random variable chosen and are the same that we saw in the past.

So for instance

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{rnorm}\NormalTok{(}\DecValTok{10}\NormalTok{, }\AttributeTok{mean =} \DecValTok{1}\NormalTok{, }\AttributeTok{sd =} \DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

generates ten observations from a Normal distribution with mean 1 and standard deviation 2.

\hypertarget{the-inverse-transform-method}{%
\subsection{The Inverse Transform Method}\label{the-inverse-transform-method}}

The simplest method to simulate observations from generic random variables is the so-called \emph{inverse transform method}.

Suppose we are interested in a random variable \(X\) whose cdf is \(F\). We must assume that \(F\) is:

\begin{itemize}
\item
  known and written in closed-form;
\item
  continuous;
\item
  strictly increasing.
\end{itemize}

Then one can prove that
\[
X = F^{-1}(U),
\]
where \(F^{-1}\) is the inverse of \(F\) and \(U\) is a continuous uniform distribution between zero and one.

The above results gives us the following algorithm to simulate observations from a random variable \(X\) with distribution \(F\):

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  compute the inverse \(F^{-1}\) of \(F\);
\item
  generate independent random observations \(u_1,u_2,\dots,u_N\) from a Uniform between zero and one;
\item
  compute \(x_1=F^{-1}(u_1), x_2=F^{-1}(u_2),\dots,x_N=F^{-1}(u_n)\).
\end{enumerate}

Then \(x_1,x_2,\dots,x_N\) are independent random observations of the random variable \(X\).

So the above algorithm can be applied to generate observations from continuous random variables with a cdf in closed-form. Therefore, for instance the above algorithm cannot be straightforwardly used for Normals. However it can be used to simulate Exponential and Uniform distributions. Furthermore, it cannot be directly used to simulate discrete random variables. A simple adaptation of this method, which we will not see here, can however be used for discrete random variables.

\hypertarget{simulating-exponentials}{%
\subsubsection{Simulating Exponentials}\label{simulating-exponentials}}

Recall that if \(X\) is Exponential with parameter \(\lambda\) then its cdf is
\[
F(x)= 1- e^{-\lambda x}, \hspace{1cm} \mbox{for } x\geq 0
\]
Suppose we want to simulate observations \(x_1,\dots,x_N\) from such a distribution.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  First we need to compute the inverse of \(F\). This means solving the equation:
  \[
  1-e^{-\lambda x} = u
  \]
  for \(x\). This can be done following the steps:
  \begin{eqnarray*}
  1-e^{-\lambda x} &=& u\\
  e^{-\lambda x} &=& 1 - u\\
  -\lambda x &=& \log(1-u)\\
  x &=& -\frac{1}{\lambda}\log(1-u)
  \end{eqnarray*}
  So \(F^{-1}(u)=-\log(1-u)/\lambda\).
\item
  Second we need to simulate random uniform observations using \texttt{runif}.
\item
  Last, we apply the inverse function to the randomly simulated observations.
\end{enumerate}

Let's give the R code.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{2021}\NormalTok{)}
\CommentTok{\# Define inverse function}
\NormalTok{invF }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(u,lambda) }\SpecialCharTok{{-}}\FunctionTok{log}\NormalTok{(}\DecValTok{1}\SpecialCharTok{{-}}\NormalTok{u)}\SpecialCharTok{/}\NormalTok{lambda}
\CommentTok{\# Simulate 5 uniform observations}
\NormalTok{u }\OtherTok{\textless{}{-}} \FunctionTok{runif}\NormalTok{(}\DecValTok{5}\NormalTok{)}
\CommentTok{\# Compute the inverse }
\FunctionTok{invF}\NormalTok{(u, }\AttributeTok{lambda =} \DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.3000720 0.7657289 0.6183896 0.2404265 0.5057456
\end{verbatim}

First we defined the inverse function of an Exponential with parameter \texttt{lambda} in \texttt{invF}. Then we simulated five observations from a uniform. Last we applied the function \texttt{invF} for a parameter \texttt{lambda} equal to two. The output are therefore five observations from an Exponential random variable with parameter 2.

\hypertarget{simulating-generic-uniforms}{%
\subsubsection{Simulating Generic Uniforms}\label{simulating-generic-uniforms}}

We know how to simulate uniformly between 0 and 1, but we do not know how to simulate uniformly between two generic values \(a\) and \(b\).

Recall that the cdf of the uniform distribution between \(a\) and \(b\) is
\[
F(x)=\frac{x-a}{b-a}, \hspace{2cm} \mbox{for } a\leq x \leq b
\]
The inverse transform method requires the inverse of \(F\), which using simple algebra can be computed as
\[
F^{-1}(u)=a + (b-a)u
\]
So given a sequence \(u_1,\dots,u_N\) of random observations from a Uniform between 0 and 1, we can simulate numbers at uniform between \(a\) and \(b\) by computing
\[
x_1 = a + (b-a)u_1,\dots, x_N=a+(b-a)u_N
\]
In R:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{2021}\NormalTok{)}
\NormalTok{a }\OtherTok{\textless{}{-}} \DecValTok{2}
\NormalTok{b }\OtherTok{\textless{}{-}} \DecValTok{6}
\NormalTok{a }\SpecialCharTok{+}\NormalTok{ (b}\SpecialCharTok{{-}}\NormalTok{a)}\SpecialCharTok{*}\FunctionTok{runif}\NormalTok{(}\DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 3.805069 5.135119 4.838729 3.526977 4.545295
\end{verbatim}

The code simulates five observations from a Uniform between two and six. This can be equally achieved by simply using:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{2021}\NormalTok{)}
\FunctionTok{runif}\NormalTok{(}\DecValTok{5}\NormalTok{, }\AttributeTok{min =} \DecValTok{2}\NormalTok{, }\AttributeTok{max =} \DecValTok{6}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 3.805069 5.135119 4.838729 3.526977 4.545295
\end{verbatim}

Notice that since we fixed the seed, the two methods return exactly the same sequence of numbers.

\hypertarget{simulating-bernoulli-and-binomial}{%
\subsection{Simulating Bernoulli and Binomial}\label{simulating-bernoulli-and-binomial}}

Bernoulli random variables represent binary experiments with a probability of success equal to \(\theta\). A simple simulation algorithm to simulate one Bernoulli observation is:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  generate \(u\) uniformly between zero and one;
\item
  if \(u< \theta\) set \(x=0\), otherwise \(x=1\).
\end{enumerate}

We will not prove that this actually works, but it intuitively does. Let's code it in R.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{2021}\NormalTok{)}
\NormalTok{theta }\OtherTok{\textless{}{-}} \FloatTok{0.5}
\NormalTok{u }\OtherTok{\textless{}{-}} \FunctionTok{runif}\NormalTok{(}\DecValTok{5}\NormalTok{)}
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{ifelse}\NormalTok{(u }\SpecialCharTok{\textless{}}\NormalTok{ theta, }\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{)}
\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0 1 1 0 1
\end{verbatim}

So here we simulated five observations from a Bernoulli with parameter 0.5: the toss of a fair coin. Three times the coin showed head, and twice tails.

From this comment, it is easy to see how to simulate one observation from a Binomial: by simply summing the randomly generated observations from Bernoullis. So if we were to sum the five numbers above, we would get one random observations from a Binomial with parameter \(n=5\) and \(\theta=0.5\).

\hypertarget{simulating-other-distributions}{%
\subsection{Simulating Other Distributions}\label{simulating-other-distributions}}

There are many other algorithms that allow to simulate specific as well as generic random variables. Since these are a bit more technical we will not consider them here, but it is important for you to know that we now can simulate basically any random variable you are interested in!

\hypertarget{testing-generic-simulation-sequences}{%
\section{Testing Generic Simulation Sequences}\label{testing-generic-simulation-sequences}}

In previous sections we spent a lot of effort in assesing if a sequence of numbers could have been a random sequence of independent numbers from a Uniform distribution between zero and one.

Now we will look at the same question, but considering generic distributions we might be interested in. Recall that we had to check two aspects:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  if the random sequence had the same distribution as the theoretical one (in previous sections Uniform between zero and one);
\item
  if the sequence was of independent numbers
\end{enumerate}

We will see that the tools to perform these steps are basically the same.

\hypertarget{testing-distribution-fit}{%
\subsection{Testing Distribution Fit}\label{testing-distribution-fit}}

There are various ways to check if the random sequence of observations has the same distribution as the theoretical one.

\hypertarget{histogram}{%
\subsubsection{Histogram}\label{histogram}}

First, we could construct an histogram of the data sequence and compare it to the theoretical distribution. Suppose we have a sequence of numbers \texttt{x1} that we want to assess if it simulated from a Standard Normal distribution.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x1 }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{(}\AttributeTok{x1 =}\FunctionTok{rnorm}\NormalTok{(}\DecValTok{500}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ggplot}\NormalTok{(x1, }\FunctionTok{aes}\NormalTok{(x1)) }\SpecialCharTok{+}
   \FunctionTok{geom\_line}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{y =}\NormalTok{ ..density.., }\AttributeTok{colour =} \StringTok{\textquotesingle{}Empirical\textquotesingle{}}\NormalTok{), }\AttributeTok{stat =} \StringTok{\textquotesingle{}density\textquotesingle{}}\NormalTok{) }\SpecialCharTok{+}
   \FunctionTok{stat\_function}\NormalTok{(}\AttributeTok{fun =}\NormalTok{ dnorm, }\FunctionTok{aes}\NormalTok{(}\AttributeTok{colour =} \StringTok{\textquotesingle{}Normal\textquotesingle{}}\NormalTok{)) }\SpecialCharTok{+}      
   \FunctionTok{geom\_histogram}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{y =}\NormalTok{ ..density..), }\AttributeTok{alpha =} \FloatTok{0.4}\NormalTok{) }\SpecialCharTok{+}      
   \FunctionTok{scale\_colour\_manual}\NormalTok{(}\AttributeTok{name =} \StringTok{\textquotesingle{}Density\textquotesingle{}}\NormalTok{, }\AttributeTok{values =} \FunctionTok{c}\NormalTok{(}\StringTok{\textquotesingle{}red\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}blue\textquotesingle{}}\NormalTok{)) }\SpecialCharTok{+}
   \FunctionTok{theme\_bw}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
\end{verbatim}

\begin{figure}

{\centering \includegraphics[width=0.5\linewidth]{bookdownproj_files/figure-latex/normhist-1} 

}

\caption{Histogram of the sequence x1 together with theoretical pdf of the standard Normal}\label{fig:normhist}
\end{figure}

Figure \ref{fig:normhist} reports the histogram of the sequence \texttt{x1} together with a smooth estimate of the histogram, often called density plot, in the red line. The blue line denotes the theoretical pdf of the standard Normal distribution. We can see that the sequence seems to follow quite closely a Normal distribution and therefore we could be convinced that the numbers are indeed Normal.

Let's consider a different sequence \texttt{x2}. Figure \ref{fig:exphist} clearly shows that there is a poor fit between the sequence and the standard Normal distribution. So we would in general not believe that these observations came from a Standard Normal.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x2 }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{(}\AttributeTok{x2 =}\FunctionTok{rnorm}\NormalTok{(}\DecValTok{500}\NormalTok{,}\FloatTok{0.5}\NormalTok{,}\FloatTok{0.6}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ggplot}\NormalTok{(x2, }\FunctionTok{aes}\NormalTok{(x2)) }\SpecialCharTok{+}
   \FunctionTok{geom\_line}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{y =}\NormalTok{ ..density.., }\AttributeTok{colour =} \StringTok{\textquotesingle{}Empirical\textquotesingle{}}\NormalTok{), }\AttributeTok{stat =} \StringTok{\textquotesingle{}density\textquotesingle{}}\NormalTok{) }\SpecialCharTok{+}
   \FunctionTok{stat\_function}\NormalTok{(}\AttributeTok{fun =}\NormalTok{ dnorm, }\FunctionTok{aes}\NormalTok{(}\AttributeTok{colour =} \StringTok{\textquotesingle{}Normal\textquotesingle{}}\NormalTok{)) }\SpecialCharTok{+}      
   \FunctionTok{geom\_histogram}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{y =}\NormalTok{ ..density..), }\AttributeTok{alpha =} \FloatTok{0.4}\NormalTok{) }\SpecialCharTok{+}      
   \FunctionTok{scale\_colour\_manual}\NormalTok{(}\AttributeTok{name =} \StringTok{\textquotesingle{}Density\textquotesingle{}}\NormalTok{, }\AttributeTok{values =} \FunctionTok{c}\NormalTok{(}\StringTok{\textquotesingle{}red\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}blue\textquotesingle{}}\NormalTok{)) }\SpecialCharTok{+}
   \FunctionTok{theme\_bw}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
\end{verbatim}

\begin{figure}

{\centering \includegraphics[width=0.5\linewidth]{bookdownproj_files/figure-latex/exphist-1} 

}

\caption{Histogram of the sequence x2 together with theoretical pdf of the standard Normal}\label{fig:exphist}
\end{figure}

\hypertarget{empirical-cumulative-distribution-function}{%
\subsubsection{Empirical Cumulative Distribution Function}\label{empirical-cumulative-distribution-function}}

We have already seen for uniform numbers that we can use the empirical cdf to assess if a sequence of numbers is uniformly distributed. We can use the exact same method for any other distribution.

Figure \ref{fig:normecdf} reports the ecdf of the sequence of numbers \texttt{x1} (in red) together with the theoretical cdf of the standard Normal (in blue). We can see that the two functions match closely and therefore we could assume that the sequence is distributed as a standard Normal.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ggplot}\NormalTok{(x1, }\FunctionTok{aes}\NormalTok{(x1)) }\SpecialCharTok{+}
   \FunctionTok{stat\_ecdf}\NormalTok{(}\AttributeTok{geom =} \StringTok{"step"}\NormalTok{,}\FunctionTok{aes}\NormalTok{(}\AttributeTok{colour =} \StringTok{\textquotesingle{}Empirical\textquotesingle{}}\NormalTok{)) }\SpecialCharTok{+}
   \FunctionTok{stat\_function}\NormalTok{(}\AttributeTok{fun =}\NormalTok{ pnorm,}\FunctionTok{aes}\NormalTok{(}\AttributeTok{colour =} \StringTok{\textquotesingle{}Theoretical\textquotesingle{}}\NormalTok{)) }\SpecialCharTok{+}
   \FunctionTok{theme\_bw}\NormalTok{() }\SpecialCharTok{+}      
   \FunctionTok{scale\_colour\_manual}\NormalTok{(}\AttributeTok{name =} \StringTok{\textquotesingle{}Density\textquotesingle{}}\NormalTok{, }\AttributeTok{values =} \FunctionTok{c}\NormalTok{(}\StringTok{\textquotesingle{}red\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}blue\textquotesingle{}}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{figure}

{\centering \includegraphics[width=0.5\linewidth]{bookdownproj_files/figure-latex/normecdf-1} 

}

\caption{Empirical cdf the sequence x1 together with theoretical cdf of the standard Normal}\label{fig:normecdf}
\end{figure}

Figure \ref{fig:expecdf} reports the same plot but for the sequence \texttt{x2}. The two lines strongly differ and therefore it cannot be assume that the sequence is distributed as a standard Normal.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ggplot}\NormalTok{(x2, }\FunctionTok{aes}\NormalTok{(x2)) }\SpecialCharTok{+}
   \FunctionTok{stat\_ecdf}\NormalTok{(}\AttributeTok{geom =} \StringTok{"step"}\NormalTok{,}\FunctionTok{aes}\NormalTok{(}\AttributeTok{colour =} \StringTok{\textquotesingle{}Empirical\textquotesingle{}}\NormalTok{)) }\SpecialCharTok{+}
   \FunctionTok{stat\_function}\NormalTok{(}\AttributeTok{fun =}\NormalTok{ pnorm,}\FunctionTok{aes}\NormalTok{(}\AttributeTok{colour =} \StringTok{\textquotesingle{}Theoretical\textquotesingle{}}\NormalTok{)) }\SpecialCharTok{+}
   \FunctionTok{theme\_bw}\NormalTok{() }\SpecialCharTok{+}      
   \FunctionTok{scale\_colour\_manual}\NormalTok{(}\AttributeTok{name =} \StringTok{\textquotesingle{}Density\textquotesingle{}}\NormalTok{, }\AttributeTok{values =} \FunctionTok{c}\NormalTok{(}\StringTok{\textquotesingle{}red\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}blue\textquotesingle{}}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{figure}

{\centering \includegraphics[width=0.5\linewidth]{bookdownproj_files/figure-latex/expecdf-1} 

}

\caption{Empirical cdf the sequence x2 together with theoretical cdf of the standard Normal}\label{fig:expecdf}
\end{figure}

\hypertarget{qq-plot}{%
\subsubsection{QQ-Plot}\label{qq-plot}}

A third visualization of the distribution of a sequence of numbers is the so called \emph{QQ-plot}. You may have already seen this when checking if the residuals of a linear regression follow a Normal distribution. But more generally, qq-plots can be used to check if a sequence of numbers is distributed according to any distribution.

We will not the details about how these are constructed but just their interpretation and implementation. Let's consider Figure \ref{fig:qqnorm}. The plot is composed of a series of points, where each point is associated to a number in our random sequence, and a line, which describes the theoretical distribution we are targeting. The closest the points and the line are, the better the fit to that distribution.

In particular, in Figure \ref{fig:qqnorm} we are checking if the sequence \texttt{x1} is distributed according to a standard Normal (represented by the straight line). Since the points are placed almost in a straight line over the theoretical line of the standard Normal, we can assume the sequence to be Normal.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ggplot}\NormalTok{(x1, }\FunctionTok{aes}\NormalTok{(}\AttributeTok{sample =}\NormalTok{ x1)) }\SpecialCharTok{+}
   \FunctionTok{stat\_qq}\NormalTok{(}\AttributeTok{distribution =}\NormalTok{ qnorm) }\SpecialCharTok{+}
   \FunctionTok{stat\_qq\_line}\NormalTok{(}\AttributeTok{distribution =}\NormalTok{ qnorm) }\SpecialCharTok{+}
   \FunctionTok{theme\_bw}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{figure}

{\centering \includegraphics[width=0.5\linewidth]{bookdownproj_files/figure-latex/qqnorm-1} 

}

\caption{QQ-plot for the sequence x1 checking against the standard Normal}\label{fig:qqnorm}
\end{figure}

Figure \ref{fig:qqexp} reports the qq-plot for the sequence \texttt{x2} to check if the data can be following a standard Normal. We can see that the points do not differ too much from the straight line and in this case we could assume the data to be Normal (notice that the histograms and the cdf strongly suggested that this sequence was not Normal).

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ggplot}\NormalTok{(x2, }\FunctionTok{aes}\NormalTok{(}\AttributeTok{sample =}\NormalTok{ x2)) }\SpecialCharTok{+}
   \FunctionTok{stat\_qq}\NormalTok{(}\AttributeTok{distribution =}\NormalTok{ qnorm) }\SpecialCharTok{+}
   \FunctionTok{stat\_qq\_line}\NormalTok{(}\AttributeTok{distribution =}\NormalTok{ qnorm) }\SpecialCharTok{+}
   \FunctionTok{theme\_bw}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{figure}

{\centering \includegraphics[width=0.5\linewidth]{bookdownproj_files/figure-latex/qqexp-1} 

}

\caption{QQ-plot for the sequence x2 checking against the standard Normal}\label{fig:qqexp}
\end{figure}

Notice that the form of the qq-plot does not only depend on the sequence of numbers we are considering, but also on the distribution we are testing it against. Figure \ref{fig:qqnorm} reports the qq-plot for the sequence \texttt{x1} when checked against an Exponential random variable with parameter \(\lambda =3\). Given that the sequence also includes negative numbers, it does not make sense to check if it is distributed as an Exponential (since it can only model non-negative data), but this is just an illustration.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ggplot}\NormalTok{(x1, }\FunctionTok{aes}\NormalTok{(}\AttributeTok{sample =}\NormalTok{ x1)) }\SpecialCharTok{+}
   \FunctionTok{stat\_qq}\NormalTok{(}\AttributeTok{distribution =}\NormalTok{ qexp, }\AttributeTok{dparams =}\NormalTok{ (}\AttributeTok{rate =} \DecValTok{3}\NormalTok{)) }\SpecialCharTok{+}
   \FunctionTok{stat\_qq\_line}\NormalTok{(}\AttributeTok{distribution =}\NormalTok{ qexp, }\AttributeTok{dparams =}\NormalTok{ (}\AttributeTok{rate =} \DecValTok{3}\NormalTok{)) }\SpecialCharTok{+}
   \FunctionTok{theme\_bw}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{figure}

{\centering \includegraphics[width=0.5\linewidth]{bookdownproj_files/figure-latex/qqnorm1-1} 

}

\caption{QQ-plot for the sequence x1 checking against an Exponential}\label{fig:qqnorm1}
\end{figure}

\hypertarget{formal-testing}{%
\subsubsection{Formal Testing}\label{formal-testing}}

The above plots are highly informative since they provide insights into the shape of the data distribution, but these are not formal. Again, we can carry out tests of hypothesis to check if data is distributed as a specific random variable, just like we did for the Uniform.

Again, there are many tests one could use, but here we focus only on the Kolmogorov-Smirnov Test which checks how close the empirical and the theoretical cdfs are. It is implemented in the \texttt{ks.test} R function.

Let's check if the sequences \texttt{x1} and \texttt{x2} are distributed as a standard Normal.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ks.test}\NormalTok{(x1,pnorm)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 
##  One-sample Kolmogorov-Smirnov test
## 
## data:  x1
## D = 0.041896, p-value = 0.3439
## alternative hypothesis: two-sided
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ks.test}\NormalTok{(x2,pnorm)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 
##  One-sample Kolmogorov-Smirnov test
## 
## data:  x2
## D = 0.2997, p-value < 2.2e-16
## alternative hypothesis: two-sided
\end{verbatim}

The conclusion is that \texttt{x1} is distributed as a standard Normal since the p-value of the test is large and for instance bigger than 0.10. On the other hand, the p-value for the Kolmogorov-Smirnov test over the sequence \texttt{x2} has a very small p-value thus leading us to reject the null hypothesis that the sequence is Normally distributed.

Notice that we can add extra inputs to the function. For instance we can check if \texttt{x1} is distributed as a Normal with \texttt{mean\ =\ 2} and \texttt{sd\ =\ 2} using:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ks.test}\NormalTok{(x1, pnorm, }\AttributeTok{mean =} \DecValTok{2}\NormalTok{, }\AttributeTok{sd =} \DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 
##  One-sample Kolmogorov-Smirnov test
## 
## data:  x1
## D = 0.54604, p-value < 2.2e-16
## alternative hypothesis: two-sided
\end{verbatim}

The p-value is small and therefore we would reject the null hypothesis that the sequence is distributed as a Normal with mean two and standard deviation two.

\hypertarget{testing-independence-1}{%
\subsection{Testing Independence}\label{testing-independence-1}}

The other step in assessing if a sequence of numbers is pseudo-random is checking if independence holds. We have already learned that one possible way to do this is by computing the auto-correlation function with the R function \texttt{acf}. Let's compute the auto-correlations of various lags for the sequences \texttt{x1} and \texttt{x2}, reported in Figure \ref{fig:acf12}. We can see that for \texttt{x2} all bars are within the confidence bands (recall that the first bar for lag \(k=0\) should not be considered). For \texttt{x1} the bar corresponding to lag 1 is slightly outside the confidence bands, indicating that there may be some dependence.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{acf}\NormalTok{(x1)}
\FunctionTok{acf}\NormalTok{(x2)}
\end{Highlighting}
\end{Shaded}

\begin{figure}

{\centering \includegraphics[width=0.5\linewidth]{bookdownproj_files/figure-latex/acf12-1} \includegraphics[width=0.5\linewidth]{bookdownproj_files/figure-latex/acf12-2} 

}

\caption{Autocorrelations for the sequences x1 and x2.}\label{fig:acf12}
\end{figure}

Let's run the Box test to assess if the assumption of independence is tenable for both sequences.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{Box.test}\NormalTok{(x1, }\AttributeTok{lag =} \DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 
##  Box-Pierce test
## 
## data:  x1
## X-squared = 8.4212, df = 5, p-value = 0.1345
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{Box.test}\NormalTok{(x2, }\AttributeTok{lag =} \DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 
##  Box-Pierce test
## 
## data:  x2
## X-squared = 4.2294, df = 5, p-value = 0.5169
\end{verbatim}

In both cases the p-values are larger than 0.10, thus we would not reject the null hypothesis of independence for both sequences. Recall that \texttt{x1} is distributed as a standard Normal, whilst \texttt{x2} is not.

For the sequence \texttt{x1} we observed that one bar was slightly outside the confidence bands: this sometimes happens even when data is actually (pseudo-) random - I created \texttt{x1} using \texttt{rnorm}. The autocorrelations below are an instance of a case where independence is not tenable since we see that multiple bars are outside the confidence bands.

\begin{center}\includegraphics[width=0.5\linewidth]{bookdownproj_files/figure-latex/unnamed-chunk-429-1} \end{center}

\hypertarget{monte-carlo-simulation}{%
\chapter{Monte Carlo Simulation}\label{monte-carlo-simulation}}

The previous chapters laid the foundations of probability and statistics that now allow us to carry out meaningful simulation experiments. In this chapter we start looking at non-dynamic simulations which are often referred to as \emph{Monte Carlo simulations}.

\hypertarget{what-does-monte-carlo-simulation-mean}{%
\section{What does Monte Carlo simulation mean?}\label{what-does-monte-carlo-simulation-mean}}

The definition of the Monte Carlo concept can be a bit confusing. For this reason, we will take \emph{Sawilowsky's} example and distinguish between: Simulation, Monte Carlo method and Monte Carlo simulation.

\begin{itemize}
\item
  A \textbf{Simulation} is a fictitious representation of reality. For example: Drawing one pseudo-random uniform variable from the interval {[}0,1{]} can be used to simulate the tossing of a coin. If the value is less than or equal to 0.50 designate the outcome as heads, but if the value is greater than 0.50 designate the outcome as tails. This is a simulation, but not a Monte Carlo simulation.
\item
  A \textbf{Monte Carlo method} is a technique that can be used to solve a mathematical or statistical problem. For example: Pouring out a box of coins on a table, and then computing the ratio of coins that land heads versus tails is a Monte Carlo method of determining the behavior of repeated coin tosses, but it is not a simulation.
\item
  A \textbf{Monte Carlo simulation} uses repeated sampling to obtain the statistical properties of some phenomenon (or behavior). For example: drawing a large number of pseudo-random uniform variables from the interval {[}0,1{]} at one time, or once at many different times, and assigning values less than or equal to 0.50 as heads and greater than 0.50 as tails, is a Monte Carlo simulation of the behavior of repeatedly tossing a coin.
\end{itemize}

The main idea behind this method is that a phenomenon is simulated multiple times on a computer using random-number generation based and the results are aggregated to provide statistical summaries associated to the phenomenon.

Sawilowsky lists the characteristics of a high-quality Monte Carlo simulation:

\begin{itemize}
\item
  the (pseudo-random) number generator has certain characteristics (e.g.~a long ``period'' before the sequence repeats)
\item
  the (pseudo-random) number generator produces values that pass tests for randomness
\item
  there are enough samples to ensure accurate results
\item
  the algorithm used is valid for what is being modeled
\item
  it simulates the phenomenon in question.
\end{itemize}

\hypertarget{a-bit-of-history}{%
\section{A bit of history}\label{a-bit-of-history}}

There were several approaches to the Monte Carlo method in the early 20th century, but it was in the mid-1940s during the Manhattan Project at ``Los Alamos'' that this method was first intentionally developed by Stanislaw Ulam and John von Neumann for early work relating to the development of nuclear weapons.

Below you can read a quote from Stanislaw Ulam in which he explains how he came up with this simple but powerful method:

\begin{quote}
The first thoughts and attempts I made to practice {[}the Monte Carlo Method{]} were suggested by a question which occurred to me in 1946 as I was convalescing from an illness and playing solitaires. The question was what are the chances that a Canfield solitaire laid out with 52 cards will come out successfully? After spending a lot of time trying to estimate them by pure combinatorial calculations, I wondered whether a more practical method than ``abstract thinking'' might not be to lay it out say one hundred times and simply observe and count the number of successful plays. This was already possible to envisage with the beginning of the new era of fast computers, and I immediately thought of problems of neutron diffusion and other questions of mathematical physics, and more generally how to change processes described by certain differential equations into an equivalent form interpretable as a succession of random operations. Later {[}in 1946{]}, I described the idea to John von Neumann, and we began to plan actual calculations.
\end{quote}

Being secret, the work of von Neumann and Ulam required a code name. A colleague of von Neumann and Ulam, Nicholas Metropolis, suggested using the name Monte Carlo, which refers to the Monte Carlo Casino in Monaco where Ulam's uncle would borrow money from relatives to gamble.

\hypertarget{steps-of-monte-carlo-simulation}{%
\section{Steps of Monte Carlo simulation}\label{steps-of-monte-carlo-simulation}}

Monte Carlo methods vary, but tend to follow a particular pattern:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Define a domain of possible inputs
\item
  Generate inputs randomly from a probability distribution over the domain
\item
  Perform a deterministic computation on the inputs
\item
  Aggregate the results
\end{enumerate}

To better understand how Monte Carlo simulation works we will develop a classic experiment: The \(\pi\) number estimation.

\(\pi\) is the mathematical constant, which is equal to 3.14159265\ldots, defined as the ratio of a circle's circumference to its diameter. It has been calculated in hundreds of different ways over the years. Today, with computational advances, a very useful way is through Monte Carlo Simulation.

Consider a circle with radius \(r\), which is fixed and known.

\begin{center}\includegraphics[width=0.25\linewidth]{images/Circle-radio} \end{center}

Imagine that this circle is circumscribed within a square, which therefore has side \(2r\) (also equal to the diameter).

\begin{center}\includegraphics[width=0.25\linewidth]{images/Circle-square} \end{center}

What is the probability that if I choose a random point inside the square, it will also be inside the circle? If I choose any random point within the square, it can be inside the circle or just inside the square. A very simple way to compute this probability is the ratio between the area of the circle and the area of the square.

\[
P(point\ inside\ the\ circle) = \frac{area\ of\ the\ circle}{area\ of\ the\ square}=\frac{\pi r^2}{2r\times 2r}=\frac{\pi}{4}
\]

The probability that a random selected point in the square is in the circle is \(\pi/4\). This means that if I were to replicate the selection of a random point in the square a large number of times, I could count the proportion of points inside the circle, multiply it by four and that would give me an approximation of \(\pi\).

We will create a Monte Carlo experiment in R which implements the ideas above. We will carry out the experiment in 5 steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Generate 2 random numbers between -1 and 1 in total 100 times (\(x\) and \(y\)).
\item
  Calculate \(x^2 + y^2\) (This is the circumference equation).

  \begin{itemize}
  \tightlist
  \item
    If the value is less than 1, the case will be inside the circle
  \item
    If the value is greater than 1, the case will be outside the circle.
  \end{itemize}
\item
  Calculate the proportion of points inside the circle and multiply it by four to approximate the \(\pi\) value.
\item
  Repeat the experiment a thousand times, to get different approximations to \(\pi\).
\item
  Calculate the average of the previous 1000 experiments to give a final value estimate.
\end{enumerate}

\hypertarget{estimating-pi-step-1}{%
\subsection{\texorpdfstring{Estimating \(\pi\): step 1}{Estimating \textbackslash pi: step 1}}\label{estimating-pi-step-1}}

Generate two random numbers between -1 and 1, 100 times:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{2021}\NormalTok{)}
\NormalTok{nPoints }\OtherTok{\textless{}{-}} \DecValTok{100}
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{runif}\NormalTok{(nPoints,}\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{,}\DecValTok{1}\NormalTok{)}
\NormalTok{y }\OtherTok{\textless{}{-}} \FunctionTok{runif}\NormalTok{(nPoints,}\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{,}\DecValTok{1}\NormalTok{)}
\FunctionTok{head}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] -0.09746527  0.56755957  0.41936446 -0.23651148  0.27264754  0.40269205
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{head}\NormalTok{(y)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] -0.38312966 -0.42837094 -0.97592119  0.76677917  0.03488941 -0.53043372
\end{verbatim}

So both \texttt{x} and \texttt{y} are vectors of length 100 storing numbers between -1 and 1.

\hypertarget{estimating-pi-step-2}{%
\subsection{\texorpdfstring{Estimating \(\pi\): step 2}{Estimating \textbackslash pi: step 2}}\label{estimating-pi-step-2}}

Calculate the circumference equation.

\begin{itemize}
\tightlist
\item
  If the value is less than 1, the case will be inside the circle
\item
  If the value is greater than 1, the case will be outside the circle.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{result }\OtherTok{\textless{}{-}} \FunctionTok{ifelse}\NormalTok{(x}\SpecialCharTok{\^{}}\DecValTok{2} \SpecialCharTok{+}\NormalTok{ y}\SpecialCharTok{\^{}}\DecValTok{2} \SpecialCharTok{\textless{}=} \DecValTok{1}\NormalTok{, }\ConstantTok{TRUE}\NormalTok{, }\ConstantTok{FALSE}\NormalTok{)}
\FunctionTok{head}\NormalTok{(result)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  TRUE  TRUE FALSE  TRUE  TRUE  TRUE
\end{verbatim}

The vector \texttt{result} has in i-th position \texttt{TRUE} if \texttt{x{[}i{]}\^{}2\ +\ y{[}i{]}\^{}2\ \textless{}=\ 1}, that is if the associated point is within the circle. We can see that out of the first six simulated points, only one is outside the circle.

\hypertarget{estimating-pi-step-3}{%
\subsection{\texorpdfstring{Estimating \(\pi\): step 3}{Estimating \textbackslash pi: step 3}}\label{estimating-pi-step-3}}

Calculate the proportion of points inside the circle and multiply it by four to approximate the \(\pi\) value.

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{4}\SpecialCharTok{*}\FunctionTok{sum}\NormalTok{(result)}\SpecialCharTok{/}\NormalTok{nPoints}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 2.92
\end{verbatim}

So using our 100 simulated points, we came up with an approximation of 2.92 for the value of \(\pi\). Of course this number depends on the random numbers that were generated. If we were to repeat it, we would get a different approximation.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{1988}\NormalTok{)}
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{runif}\NormalTok{(nPoints,}\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{,}\DecValTok{1}\NormalTok{)}
\NormalTok{y }\OtherTok{\textless{}{-}} \FunctionTok{runif}\NormalTok{(nPoints,}\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{,}\DecValTok{1}\NormalTok{)}
\NormalTok{result }\OtherTok{\textless{}{-}} \FunctionTok{ifelse}\NormalTok{(x}\SpecialCharTok{\^{}}\DecValTok{2} \SpecialCharTok{+}\NormalTok{ y}\SpecialCharTok{\^{}}\DecValTok{2} \SpecialCharTok{\textless{}=} \DecValTok{1}\NormalTok{, }\ConstantTok{TRUE}\NormalTok{, }\ConstantTok{FALSE}\NormalTok{)}
\DecValTok{4}\SpecialCharTok{*}\FunctionTok{sum}\NormalTok{(result)}\SpecialCharTok{/}\NormalTok{nPoints}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 3.08
\end{verbatim}

\hypertarget{estimating-pi-step-4}{%
\subsection{\texorpdfstring{Estimating \(\pi\): step 4}{Estimating \textbackslash pi: step 4}}\label{estimating-pi-step-4}}

Repeat the experiment a thousand times, to get different approximations to \(\pi\).

We could do this by coding a \texttt{for} cycle, but we will take advantage of some features already implemented in R. In order to do this however, we first need to define a function which repeats our estimation of \(\pi\) given 100 random points.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{piVal }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(}\AttributeTok{nPoints =} \DecValTok{100}\NormalTok{)\{}
\NormalTok{  x }\OtherTok{\textless{}{-}} \FunctionTok{runif}\NormalTok{(nPoints,}\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{,}\DecValTok{1}\NormalTok{)}
\NormalTok{  y }\OtherTok{\textless{}{-}} \FunctionTok{runif}\NormalTok{(nPoints,}\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{,}\DecValTok{1}\NormalTok{)}
\NormalTok{  result }\OtherTok{\textless{}{-}} \FunctionTok{ifelse}\NormalTok{(x}\SpecialCharTok{\^{}}\DecValTok{2}\SpecialCharTok{+}\NormalTok{y}\SpecialCharTok{\^{}}\DecValTok{2} \SpecialCharTok{\textless{}=} \DecValTok{1}\NormalTok{, }\ConstantTok{TRUE}\NormalTok{, }\ConstantTok{FALSE}\NormalTok{)}
  \DecValTok{4}\SpecialCharTok{*}\FunctionTok{sum}\NormalTok{(result)}\SpecialCharTok{/}\NormalTok{nPoints}
\NormalTok{\}}

\FunctionTok{set.seed}\NormalTok{(}\DecValTok{2021}\NormalTok{)}
\FunctionTok{piVal}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 2.92
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{1988}\NormalTok{)}
\FunctionTok{piVal}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 3.08
\end{verbatim}

So we can see that the function works since it gives us the same output as the code above.

Now we can use the function \texttt{replicate} in R, to replicate the experiment 1000 times, or to put it differently, to compute the function \texttt{piVal} 1000 times. \texttt{replicate} takes two inputs:

\begin{itemize}
\item
  \texttt{n}: the number of times we want to replicate the experimet;
\item
  \texttt{expr}: the function we want to be replicated
\end{itemize}

Therefore the following code replicates the experiment:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{2021}\NormalTok{)}
\NormalTok{N }\OtherTok{\textless{}{-}} \DecValTok{1000}
\NormalTok{pis }\OtherTok{\textless{}{-}} \FunctionTok{replicate}\NormalTok{(N, }\FunctionTok{piVal}\NormalTok{())}
\FunctionTok{head}\NormalTok{(pis)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 2.92 3.20 3.16 3.08 3.20 2.76
\end{verbatim}

We can see that the first entry of the vector \texttt{pis} is indeed \texttt{pis{[}1{]}} which is the same value we obtained running the function ourselves (in both cases we fixed the same seed).

\hypertarget{estimating-pi-step-5}{%
\subsection{\texorpdfstring{Estimating \(\pi\): step 5}{Estimating \textbackslash pi: step 5}}\label{estimating-pi-step-5}}

Calculate the average of the previous 1000 experiments to give a final value estimate.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{mean}\NormalTok{(pis)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 3.13828
\end{verbatim}

The average gives us a good approximation of \(\pi\).

A boxplot can give us a visualization of the results.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{boxplot}\NormalTok{(pis)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.5\linewidth]{bookdownproj_files/figure-latex/unnamed-chunk-439-1} \end{center}

The boxplot importantly tells us two things:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  if we were to take the average of the 1000 approximatations of \(\pi\) we would get a value close to the true value (look at the horizontal line within the box).
\item
  if we were to choose a value for \(\pi\) based on a single simulation, then we could pick values between 2.48 and 3.6.
\end{enumerate}

\hypertarget{estimating-pi-conclusions}{%
\subsection{\texorpdfstring{Estimating \(\pi\): conclusions}{Estimating \textbackslash pi: conclusions}}\label{estimating-pi-conclusions}}

One thing you might wonder now is the following. Why did we replicate the experiment 1000 times and each time took only 100 points. Could have we not taken a much larger number of points only once (for example \(1000\times 100\))?

On one hand that would have clearly given us a good approximation, using the same total number of simulated points. Indeed

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{2021}\NormalTok{)}
\FunctionTok{piVal}\NormalTok{(}\DecValTok{1000}\SpecialCharTok{*}\DecValTok{100}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 3.1416
\end{verbatim}

which is very close to the true value.

However this approach does not give us any information about uncertainty or about how good our approximation is. We have just one single value. On the other hand, using replication we have 1000 possible approximations of \(\pi\) and we can construct intervals of plausible values. For instance, we would believe that the true value \(\pi\) is with 95\% probability in the interval

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{c}\NormalTok{(}\FunctionTok{sort}\NormalTok{(pis)[}\DecValTok{25}\NormalTok{],}\FunctionTok{sort}\NormalTok{(pis)[}\DecValTok{975}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 2.84 3.44
\end{verbatim}

which includes 95\% of the central approximations of \(\pi\). Such intervals are in spirit similar to the confidence intervals you should be familiar with, but there are some technicalities that makes them different (which we will not discuss here).

\hypertarget{the-sample-function}{%
\section{\texorpdfstring{The \texttt{sample} function}{The sample function}}\label{the-sample-function}}

We have now carried out our first Monte Carlo experiment!! We will carry out others in the rest of this chapter and interpret their results. There is one function, the \texttt{sample} function which we will often use.

In the previous chapter we discussed how to simulate numbers distributed according to a specific random variable. One possible class of numbers we may want to simulate in some situations are integers. Suppose for example you want to simulate a game of dice: then we must be able to simulate in R one number from the set \(\{1,2,3,4,5,6\}\) where each has the same probability of appearing. We have not introduced yet a function that does this.

For this specific purpose there is the function \texttt{sample}. This takes four inputs:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \texttt{x}: a vector of values we want to sample from.
\item
  \texttt{size}: the size of the sample we want.
\item
  \texttt{replace}: if \texttt{TRUE} sampling is done with replacement. That is if a value has been selected, it can be selected again. By default equal to \texttt{FALSE}
\item
  \texttt{prob}: a vector of the same length of \texttt{x} giving the probabilities that the elements of \texttt{x} are selected. By defaul equal to a uniform probability.
\end{enumerate}

So for instance if we wanted to simulate ten tosses of a fair dice we can write.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{2021}\NormalTok{)}
\FunctionTok{sample}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{6}\NormalTok{, }\AttributeTok{size =} \DecValTok{10}\NormalTok{, }\AttributeTok{replace =} \ConstantTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] 6 6 2 4 4 6 6 3 6 6
\end{verbatim}

Notice that the vector \texttt{x} does not necessarily needs to be numeric. It could be a vector of characters. For instance, let's simulate the toss of 5 coins, where the probability of heads is 2/3 and the probability of tails is 1/3.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{2021}\NormalTok{)}
\FunctionTok{sample}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\StringTok{"heads"}\NormalTok{,}\StringTok{"tails"}\NormalTok{), }\AttributeTok{size =} \DecValTok{5}\NormalTok{, }\AttributeTok{replace =} \ConstantTok{TRUE}\NormalTok{, }\AttributeTok{prob =} \FunctionTok{c}\NormalTok{(}\DecValTok{2}\SpecialCharTok{/}\DecValTok{3}\NormalTok{,}\DecValTok{1}\SpecialCharTok{/}\DecValTok{3}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "heads" "tails" "tails" "heads" "heads"
\end{verbatim}

\hypertarget{a-game-of-chance}{%
\section{A game of chance}\label{a-game-of-chance}}

For the rest of this chapter we will develop various Monte Carlo simulations. We start simulating a little game of chance.

Peter and Paul play a simple game involving repeated tosses of a fair coin. In a given toss, if heads is observed, Peter wins 1€ from Paul; otherwise if tails is tossed, Peter gives 1€ to Paul. If Peter starts with zero euros, we are interested in his fortune as the game is played for 50 tosses.

We can simulate this game using the R \texttt{sample()} function. Peter's winning on a particular toss will be 1€ or -1€ with equal probability. His winnings on 50 repeated tosses can be considered to be a sample of size 50 selected with replacement from the set \{1€, -1€\}.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{2021}\NormalTok{)}
\NormalTok{win }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{,}\DecValTok{1}\NormalTok{),}\AttributeTok{size =} \DecValTok{50}\NormalTok{, }\AttributeTok{replace =} \ConstantTok{TRUE}\NormalTok{)}
\FunctionTok{head}\NormalTok{(win)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] -1  1  1  1 -1  1
\end{verbatim}

For this particular game Peter lost the first game, then won the second, the third and the fourth and so on.

Suppose Peter is interested in his cumulative winnings as he plays this game. The function \texttt{cumsum()} computes the cumulative winnings of the individual values and we store the cumulative values in a vector named \texttt{cumul.win}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{cumul.win }\OtherTok{\textless{}{-}} \FunctionTok{cumsum}\NormalTok{(win) }
\NormalTok{cumul.win}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] -1  0  1  2  1  2  3  4  5  6  5  6  7  6  5  4  3  2  3  2  3  4  3  4  3
## [26]  2  3  4  5  6  5  6  5  6  7  6  7  6  7  6  5  4  5  6  5  4  5  6  7  8
\end{verbatim}

So at the end of this specific game Peter won 8€. Figure \ref{fig:cumwin} reports Peter's fortune as the game evolved. We can notice that Peter was in the lead throughout almost the whole game.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{plot}\NormalTok{(}\FunctionTok{cumsum}\NormalTok{(win), }\AttributeTok{type=}\StringTok{"l"}\NormalTok{ ,}\AttributeTok{ylim=}\FunctionTok{c}\NormalTok{(}\SpecialCharTok{{-}}\DecValTok{25}\NormalTok{, }\DecValTok{25}\NormalTok{))}
\FunctionTok{abline}\NormalTok{(}\AttributeTok{h=}\DecValTok{0}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{figure}

{\centering \includegraphics[width=0.5\linewidth]{bookdownproj_files/figure-latex/cumwin-1} 

}

\caption{Peter's fortune throughout one simulated game.}\label{fig:cumwin}
\end{figure}

Of course this is the result of a single simulation and the outcome may be totally different than the one we saw. Figure \ref{fig:mcumwin} reports four simulated games: we can see that in the first one Peter wins, in the second he almost breaks even, whilst in the third and fourth he clearly loses.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{2021}\NormalTok{)}
\FunctionTok{par}\NormalTok{(}\AttributeTok{mfrow=}\FunctionTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{2}\NormalTok{))}
\ControlFlowTok{for}\NormalTok{(j }\ControlFlowTok{in} \DecValTok{1}\SpecialCharTok{:}\DecValTok{4}\NormalTok{)\{}
  \FunctionTok{plot}\NormalTok{(}\FunctionTok{cumsum}\NormalTok{(}\FunctionTok{sample}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{),}\AttributeTok{size=}\DecValTok{50}\NormalTok{,}\AttributeTok{replace=}\ConstantTok{TRUE}\NormalTok{)),}\AttributeTok{type=}\StringTok{"l"}\NormalTok{ ,}\AttributeTok{ylim=}\FunctionTok{c}\NormalTok{(}\SpecialCharTok{{-}}\DecValTok{25}\NormalTok{, }\DecValTok{25}\NormalTok{), }\AttributeTok{ylab=}\StringTok{"Outcome"}\NormalTok{)}
  \FunctionTok{abline}\NormalTok{(}\AttributeTok{h=}\DecValTok{0}\NormalTok{)\}}
\end{Highlighting}
\end{Shaded}

\begin{figure}

{\centering \includegraphics[width=0.8\linewidth]{bookdownproj_files/figure-latex/mcumwin-1} 

}

\caption{Outcome of four simulated game of chances.}\label{fig:mcumwin}
\end{figure}

Suppose we are interested in the following question.

\begin{itemize}
\tightlist
\item
  What is the probability that Peter breaks even at the end of the game?
\end{itemize}

Evidently we cannot cannot answer by simply looking at the outputs of the previous simulations. We need to do a formal Monte Carlo study. In this type of experiment, we simulate the random process and compute the statistic of interest. By repeating the random process many times, we obtain a collection of values of the statistic, which can then be used to approximate probabilities or expectations that answer the questions.

As you may recall from the estimation of \(\pi\) experiment, we first need to write a function that simulates the experiment. In particular we need to write a function which outputs Peter's winning at the end of the game. To make this function more general, we define \texttt{n} to be the number of tosses and let the default value of \texttt{n} be 50.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{peter.paul }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(}\AttributeTok{n=}\DecValTok{50}\NormalTok{)\{}
  \FunctionTok{sum}\NormalTok{(}\FunctionTok{sample}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{), }\AttributeTok{size=}\NormalTok{n, }\AttributeTok{replace=}\ConstantTok{TRUE}\NormalTok{))}
\NormalTok{\}}
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{2021}\NormalTok{)}
\FunctionTok{peter.paul}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 8
\end{verbatim}

The output is the same as the previous code, so it seems that our function works correctly.

Let's replicate the experiment many times.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{2021}\NormalTok{)}
\NormalTok{experiment }\OtherTok{\textless{}{-}} \FunctionTok{replicate}\NormalTok{(}\DecValTok{1000}\NormalTok{,}\FunctionTok{peter.paul}\NormalTok{())}
\FunctionTok{head}\NormalTok{(experiment)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]   8  -2 -12 -12 -14   8
\end{verbatim}

So the vector \texttt{experiment} stores Peter's final fortune in 1000 games. Since Peter's fortune is an integer-value variable, it is convenient to summarize it using the \texttt{table} function.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{table}\NormalTok{(experiment)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## experiment
## -22 -20 -18 -16 -14 -12 -10  -8  -6  -4  -2   0   2   4   6   8  10  12  14  16 
##   1   2   7   7  16  30  42  66  58 101 116 102 110 103  70  60  44  26  15  14 
##  18  20 
##   4   6
\end{verbatim}

A graphical representation of the table is also useful.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{plot}\NormalTok{(}\FunctionTok{table}\NormalTok{(experiment))}
\end{Highlighting}
\end{Shaded}

\includegraphics{bookdownproj_files/figure-latex/unnamed-chunk-449-1.pdf}
So we can see that Peter breaks even 102 out of 1000 times. Furthermore the plot shows us that most commonly Peter will win/lose little money and that big wins/losses are unlikely.

To conclude our experiment we need to calculate our estimated probability of Peter breaking even. Clearly this is equal to 102/1000= 0.102. In R:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sum}\NormalTok{(experiment}\SpecialCharTok{==}\DecValTok{0}\NormalTok{)}\SpecialCharTok{/}\DecValTok{1000}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.102
\end{verbatim}

Notice that we could have also answered this question exactly. The event Peter breaking even coincides with a number of successes \(n/2\) in a Binomial experiment with parameters \(n=50\) and \(\theta = 0.5\). This can be computed in R as

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{dbinom}\NormalTok{(}\DecValTok{25}\NormalTok{, }\AttributeTok{size =} \DecValTok{50}\NormalTok{, }\AttributeTok{prob =} \FloatTok{0.5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.1122752
\end{verbatim}

So our approximation is already quite close to the true value. We would get even closer by replicating the experiment a larger number of times.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{2021}\NormalTok{)}
\NormalTok{experiment }\OtherTok{\textless{}{-}} \FunctionTok{replicate}\NormalTok{(}\DecValTok{10000}\NormalTok{,}\FunctionTok{peter.paul}\NormalTok{())}
\FunctionTok{length}\NormalTok{(experiment[experiment}\SpecialCharTok{==}\DecValTok{0}\NormalTok{])}\SpecialCharTok{/}\DecValTok{1000}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1.096
\end{verbatim}

\hypertarget{takeaways}{%
\section{Takeaways}\label{takeaways}}

Throughout this session we have understood:

\begin{itemize}
\tightlist
\item
  What the Monte Carlo method is, and how it differs from Monte Carlo simulation.
\item
  The history of the creation of the Monte Carlo method
\item
  To generate random numbers and random variables with R
\item
  To establish a seed
\item
  To conduct a simulation experiment using the Monte Carlo method.
\end{itemize}

\hypertarget{monte-carlo-methods-for-inference}{%
\chapter{Monte Carlo methods for inference}\label{monte-carlo-methods-for-inference}}

Monte Carlo Methods may refer to any statistical or numerical method where simulation is used. When we talk about Monte Carlo methods for inference we just look at these inference processes. In this way, we can use Monte Carlo to estimate:

\begin{itemize}
\tightlist
\item
  Parameters of sampling
\item
  Distribution of a statistic
\item
  Mean squared error (MSE)
\item
  Percentiles
\item
  Other measures of interest.
\end{itemize}

In statistical inference there is uncertainty in any estimate. The methods we are going to see use repeated sampling from a given probability model, known as parametric bootstrap. We simulate the stochastic process that generated the data, repeatedly drawing samples under identical conditions. Other MC methods known as nonparametric use repeated sampling from an observed sample.

\hypertarget{monte-carlo-for-estimation}{%
\section{Monte Carlo for estimation}\label{monte-carlo-for-estimation}}

Let's begin with simply estimating a probability. Sometimes this is referred to as computing an expectation of a random variable. If you have a random variable \(X\) with a density function \(f_X(x)\) and we want to compute the expectation of a function \(g(x)\) which models the probability of \(f_X(x)\), (or the area under the curve of \(f_X(x)\)), then \(g(x)\) can be expressed as the integral of \(f_X(x)\).

\hypertarget{sam-and-annie-from-sleepless-in-seattle}{%
\subsection{Sam and Annie from `Sleepless in Seattle'}\label{sam-and-annie-from-sleepless-in-seattle}}

We can take a look to the \href{https://www.youtube.com/watch?v=L4Ll-xXjjXc}{Sleepless in Seattle} video to understand the problem. It is a 1993 American romantic comedy.

Now, let \(A\) and \(S\) represent Sam's and Annie's arrival times at the Empire State Building, where we measure the arrival time as the number of hours after noon. We assume:

\begin{itemize}
\tightlist
\item
  \(A\) and \(S\) are independent and uniformly distributed
\item
  Annie arrives somewhere between 10:30 and midnight
\item
  Sam arrives somewhere between 10:00 and 11:30PM.
\end{itemize}

Our Questions are:

\begin{enumerate}
\def\labelenumi{\arabic{enumi})}
\tightlist
\item
  What is the probability that Annie arrives before Sam?
\item
  What is expected difference in arrival times?
\end{enumerate}

We start simulating a large number of values from distribution of \((A,S)\) say, \texttt{1000}, where \(A\) and \(S\) are independent:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{2021}\NormalTok{)}
\NormalTok{sam }\OtherTok{=} \FunctionTok{runif}\NormalTok{(}\DecValTok{1000}\NormalTok{, }\DecValTok{10}\NormalTok{, }\FloatTok{11.5}\NormalTok{)}
\NormalTok{annie }\OtherTok{=} \FunctionTok{runif}\NormalTok{(}\DecValTok{1000}\NormalTok{, }\FloatTok{10.5}\NormalTok{, }\DecValTok{12}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

We want the probability \(P(A < S)\) which is estimated by the proportion of simulated pairs \((a,s)\) where \(a\) is smaller than \(s\)

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{prob }\OtherTok{=} \FunctionTok{sum}\NormalTok{(annie }\SpecialCharTok{\textless{}}\NormalTok{ sam) }\SpecialCharTok{/} \DecValTok{1000}
\NormalTok{prob}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.223
\end{verbatim}

The estimated probability that Annie arrives before Sam is 0.223, and the \emph{standard error} of this estimation is:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sqrt}\NormalTok{(prob }\SpecialCharTok{*}\NormalTok{ (}\DecValTok{1} \SpecialCharTok{{-}}\NormalTok{ prob) }\SpecialCharTok{/} \DecValTok{1000}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.01316324
\end{verbatim}

In the next plot we can see that the shaded region shows the area in which \(A < S\)

\includegraphics{bookdownproj_files/figure-latex/unnamed-chunk-456-1.pdf}

Now, what is the expected difference in the arrival times? Annie is more likely to arrive later, so we model \(E(A-S)\)

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{difference }\OtherTok{=}\NormalTok{ annie }\SpecialCharTok{{-}}\NormalTok{ sam}
\end{Highlighting}
\end{Shaded}

Now we can estimate the mean of the differences using Monte Carlo methods

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{estimatedMean }\OtherTok{=} \FunctionTok{mean}\NormalTok{(difference)}
\NormalTok{estimatedMean}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.5079882
\end{verbatim}

The estimated standard error is the standard desviation of the difference divided by the square root of the simulation sample size:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{SE }\OtherTok{=} \FunctionTok{sd}\NormalTok{(difference) }\SpecialCharTok{/} \FunctionTok{sqrt}\NormalTok{(}\DecValTok{1000}\NormalTok{)}
\FunctionTok{c}\NormalTok{(}\StringTok{"Mean"} \OtherTok{=}\NormalTok{ estimatedMean, }\StringTok{"Standard Error"} \OtherTok{=}\NormalTok{ SE)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##           Mean Standard Error 
##     0.50798819     0.01972754
\end{verbatim}

So we estimate that Annie will arrive 0.508 hours after Sam arrives. Since standard error is only 0.02 hours, we can be 95\% confident that the true difference is between 0.528 and 0.488 hours

\hypertarget{general-case-with-standard-normal-distributions}{%
\section{General Case with Standard Normal Distributions}\label{general-case-with-standard-normal-distributions}}

In probability theory and statistics, a collection of random variables is independent and identically distributed (iid) if each random variable has the same probability distribution as the others and all are mutually independent. Following, we are going to perform a Monte Carlo simulation to check two main iid properties:

\begin{itemize}
\tightlist
\item
  The expected value of absolute difference is: \(E(|X-Y|)=\frac{2}{\sqrt{\pi}}\)
\item
  The variance of absolute difference is: \(V(|X-Y|) = 2- \frac{4}{\pi}\)
\end{itemize}

We generate a large number of random samples of size 2 from a standard normal distribution, then compute the replicate pairs' differences, and then the mean of those differences:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{2021}\NormalTok{)}
\NormalTok{n }\OtherTok{=} \DecValTok{10000}
\NormalTok{g }\OtherTok{=} \FunctionTok{numeric}\NormalTok{(n)}

\ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{1}\SpecialCharTok{:}\NormalTok{n) \{}
\NormalTok{  x }\OtherTok{=} \FunctionTok{rnorm}\NormalTok{(}\DecValTok{2}\NormalTok{)}
\NormalTok{  g[i] }\OtherTok{=} \FunctionTok{abs}\NormalTok{(x[}\DecValTok{1}\NormalTok{] }\SpecialCharTok{{-}}\NormalTok{ x[}\DecValTok{2}\NormalTok{])}
\NormalTok{\}}

\NormalTok{estMean }\OtherTok{=} \FunctionTok{mean}\NormalTok{(g)}
\NormalTok{expectedValue }\OtherTok{=} \DecValTok{2}\SpecialCharTok{/}\FunctionTok{sqrt}\NormalTok{(pi)}
\NormalTok{diffMeanExpectation }\OtherTok{=} \FunctionTok{abs}\NormalTok{(estMean}\SpecialCharTok{{-}}\NormalTok{expectedValue)}

\FunctionTok{c}\NormalTok{(}\StringTok{"Estimated Mean"} \OtherTok{=}\NormalTok{ estMean, }\StringTok{"Expected Value"} \OtherTok{=}\NormalTok{ expectedValue, }\StringTok{"Difference"} \OtherTok{=}\NormalTok{ diffMeanExpectation)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Estimated Mean Expected Value     Difference 
##     1.11782094     1.12837917     0.01055823
\end{verbatim}

Next, we can see a plot that represents the results.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(ggplot2)}

\NormalTok{dataPlot }\OtherTok{=} \FunctionTok{c}\NormalTok{(estMean, expectedValue, diffMeanExpectation)}
\FunctionTok{barplot}\NormalTok{(dataPlot, }\AttributeTok{main =} \StringTok{"Statistics"}\NormalTok{, }\AttributeTok{border=}\StringTok{"red"}\NormalTok{, }\AttributeTok{col=}\StringTok{"blue"}\NormalTok{, }\AttributeTok{density=}\DecValTok{12}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{bookdownproj_files/figure-latex/unnamed-chunk-461-1.pdf}

\hypertarget{the-taxi-problem-comparing-estimators}{%
\section{The taxi problem (comparing estimators)}\label{the-taxi-problem-comparing-estimators}}

Finally, we will see a case in which we want to compare two different estimators. Imagine that a person is walking through the streets of a city and notices the following numbers of 5 taxis that pass by: 34,100,65,81,120. Can he/she make an intelligent guess at the number of taxis in the city?: Is a problem of statistical inference where population is collection of taxis driven in city and one wishes to know unknown number of taxis \(N\).

Assume taxis are numbered from \(1\) to \(N\), each equally likely to be observed and consider two possible estimates:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  The largest taxi number observed
\item
  Twice the sample mean.
\end{enumerate}

Which is a better estimator of the number of taxis \(N\)? We will compare these two estimators using a Monte Carlo Simulation:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Simulate taxi numbers from a uniform distribution with a known number of taxis \(N\) and compute the two estimates.
\item
  Repeat many times and obtain two empirical sampling distributions.
\item
  Then we can compare the two estimators by examining various properties of their respective sampling distributions
\end{enumerate}

The \texttt{taxi()} function will implement a single simulation. We have two arguments:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  The actual number of taxis \texttt{N}.
\item
  The sample size \texttt{n}.
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{taxi }\OtherTok{=} \ControlFlowTok{function}\NormalTok{(N, n)\{}
\NormalTok{  y }\OtherTok{=} \FunctionTok{sample}\NormalTok{(N, }\AttributeTok{size=}\NormalTok{n, }\AttributeTok{replace=}\ConstantTok{TRUE}\NormalTok{)}
\NormalTok{  estimate1 }\OtherTok{=} \FunctionTok{max}\NormalTok{(y)}
\NormalTok{  estimate2 }\OtherTok{=} \DecValTok{2} \SpecialCharTok{*} \FunctionTok{mean}\NormalTok{(y)}
  \FunctionTok{c}\NormalTok{(}\AttributeTok{estimate1=}\NormalTok{estimate1, }\AttributeTok{estimate2=}\NormalTok{estimate2)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The \texttt{sample()} function simulates the observed taxi numbers and values of the two estimates are stored in variables \texttt{estimate1} and \texttt{estimate2}. Let's say actual number of taxis in city is \texttt{100} and we observe numbers of \texttt{n=5} taxis.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{2021}\NormalTok{)}
\FunctionTok{taxi}\NormalTok{(}\DecValTok{100}\NormalTok{, }\DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## estimate1 estimate2 
##      58.0      64.4
\end{verbatim}

We get values \texttt{estimate1=58} and \texttt{estimate2=64.4}

Let's simulate sampling process 1000 times. We are going to create a matrix with two rows (\texttt{estimate1} and \texttt{estimate2}), and \texttt{1000} columns. This colums will hold the estimated values of \texttt{estimate1} and \texttt{estimate2} for \texttt{1000} simulated experiments.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{2021}\NormalTok{)}
\NormalTok{EST }\OtherTok{=} \FunctionTok{replicate}\NormalTok{(}\DecValTok{1000}\NormalTok{, }\FunctionTok{taxi}\NormalTok{(}\DecValTok{100}\NormalTok{, }\DecValTok{5}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

Here we are looking for ``unbiasedness'', which means that the average value of the estimator must be equal to the parameter. We know that the number of taxis is 100. So we can calculate the mean standard error for our estimators as follows:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{c}\NormalTok{(}\FunctionTok{mean}\NormalTok{(EST[}\StringTok{"estimate1"}\NormalTok{, ]) }\SpecialCharTok{{-}}\DecValTok{100}\NormalTok{, }\FunctionTok{sd}\NormalTok{(EST[}\StringTok{"estimate1"}\NormalTok{, ]) }\SpecialCharTok{/} \FunctionTok{sqrt}\NormalTok{(}\DecValTok{1000}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] -15.7170000   0.4511901
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{c}\NormalTok{(}\FunctionTok{mean}\NormalTok{(EST[}\StringTok{"estimate2"}\NormalTok{, ]) }\SpecialCharTok{{-}}\DecValTok{100}\NormalTok{, }\FunctionTok{sd}\NormalTok{(EST[}\StringTok{"estimate2"}\NormalTok{, ]) }\SpecialCharTok{/} \FunctionTok{sqrt}\NormalTok{(}\DecValTok{1000}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1.4248000 0.8360629
\end{verbatim}

Seems that \texttt{estimate2} is ``less biased'', but we can also compare them with respect to the mean distance from the parameter \texttt{N} (mean absolute error). Now, we are going to compute the mean absolute error and draw a boxplot:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{absolute.error }\OtherTok{=} \FunctionTok{abs}\NormalTok{(EST }\SpecialCharTok{{-}} \DecValTok{100}\NormalTok{)}
\FunctionTok{boxplot}\NormalTok{(}\FunctionTok{t}\NormalTok{(absolute.error))}
\end{Highlighting}
\end{Shaded}

\includegraphics{bookdownproj_files/figure-latex/unnamed-chunk-467-1.pdf}

In this case, seems that \texttt{estimate1} has smaller estimation errors. We can also find the sample mean of the absolute errors and its standard error:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{c}\NormalTok{(}\FunctionTok{mean}\NormalTok{(absolute.error[}\StringTok{"estimate1"}\NormalTok{, ]), }\FunctionTok{sd}\NormalTok{(absolute.error[}\StringTok{"estimate1"}\NormalTok{, ]) }\SpecialCharTok{/} \FunctionTok{sqrt}\NormalTok{(}\DecValTok{1000}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 15.7170000  0.4511901
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{c}\NormalTok{(}\FunctionTok{mean}\NormalTok{(absolute.error[}\StringTok{"estimate2"}\NormalTok{, ]), }\FunctionTok{sd}\NormalTok{(absolute.error[}\StringTok{"estimate2"}\NormalTok{, ]) }\SpecialCharTok{/} \FunctionTok{sqrt}\NormalTok{(}\DecValTok{1000}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 21.463200  0.489799
\end{verbatim}

Again, the \texttt{estimate1} looks better than the \texttt{estimate2}.

\hypertarget{discrete-events-simulation-with-r}{%
\chapter{Discrete Events Simulation with R}\label{discrete-events-simulation-with-r}}

We are not going to explore this subject in depth, but at the end of this chapter we will understand what the discrete events simulation consists of, and we will carry out an example in R. Unlike Monte Carlo methods, which allow us to simulate events based on variables that change constantly over time, the discrete events simulation will help us to model the behavior of systems based on a sequence of discrete events over time. Remember that for both cases we use stochastic models.

Recall that different types of simulation apply depending on the nature of the system under consideration. A common model taxonomy classifies simulation problems along three main dimensions:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  deterministic vs.~stochastic
\item
  static vs.~dynamic (depending on whether they require a time component)
\item
  continuous vs.~discrete (depending on how the system changes).
\end{enumerate}

For instance, Monte Carlo methods are well-known examples of static stochastic simulation techniques. On the other hand, discrete-event simulation (DES) is a specific technique for modelling stochastic, dynamic and discretely evolving systems. As opposed to continuous simulation, which typically uses smoothly-evolving equational models, DES is characterized by sudden state changes at precise points of (simulated) time.

Customers arriving at a bank, products being manipulated in a supply chain, or packets traversing a network are common examples of such systems. The discrete nature of a given system arises as soon as its behavior can be described in terms of events, which is the most fundamental concept in DES. An event is an instantaneous occurrence that may change the state of the system, while, between events, all the state variables remain constant.

There are several world views, or programming styles, for DES (Banks 2005):

\begin{itemize}
\tightlist
\item
  In the \textbf{activity-oriented} approach, a model consists of sequences of activities, or operations, waiting to be executed depending on some conditions. The simulation clock advances in fixed time increments. At each step, the whole list of activities is scanned, and their conditions, verified. Despite its simplicity, the simulation performance is too sensitive to the election of such a time increment.
  -Instead, the \textbf{event-oriented} approach completely bypasses this issue by maintaining a list of scheduled events ordered by time of occurrence. Then, the simulation just consists in jumping from event to event, sequentially executing the associated routines.
\item
  Finally, the \textbf{process-oriented} approach refines the latter with the addition of interacting processes, whose activation is triggered by events. In this case, the modeller defines a set of processes, which correspond to entities or objects of the real system, and their life cycle.
\end{itemize}

In this course we will use the \texttt{simmer} package to perform our DES. \texttt{simmer} (Ucar and Smeets 2019a) is a DES package for R which enables high-level \textbf{process-oriented} modelling, in line with other modern simulators. But in addition, it exploits the novel concept of \textbf{trajectory}: a common path in the simulation model for entities of the same type. In other words, a trajectory consist of a list of standardized actions which defines the life cycle of equivalent processes. This design pattern is flexible and simple to use. It is important to note that \texttt{simmer} package uses pipes in order to simplify the structure of the simulation.

\hypertarget{simmer-terminology}{%
\section{\texorpdfstring{\texttt{simmer} terminology}{simmer terminology}}\label{simmer-terminology}}

In this course we have already used some DES-specific terminology, e.g., event, state, entity, process or attribute. But there are, however, some simmer-specific terms, and some elements that require further explanation to understand the package architecture.

\begin{itemize}
\item
  \textbf{Resource}: A passive entity, as it is commonly understood in standard DES terminology. However, simmer resources are conceived with queuing systems in mind, and therefore they comprise two internal self-managed parts:

  \begin{itemize}
  \tightlist
  \item
    Server: which, conceptually, represents the resource itself. It has a specified capacity and can be seized and released.
  \item
    Queue: A priority queue of a certain size.
  \end{itemize}
\item
  \textbf{Manager}: An active entity, i.e., a process, that has the ability to adjust properties of a resource (capacity and queue size) at run-time.
\item
  \textbf{Source}: A process responsible for creating new arrivals with a given inter-arrival time pattern and inserting them into the simulation model.
\item
  \textbf{Arrival}: A process capable of interacting with resources or other entities of the simulation model. It may have some attributes and prioritization values associated and, in general, a limited lifetime. Upon creation, every arrival is attached to a given trajectory.
\item
  \textbf{Trajectory}: An inter-linkage of activities constituting a recipe for arrivals attached to it, i.e., an ordered set of actions that must be executed. The simulation model is ultimately represented by a set of trajectories.
\item
  \textbf{Activity}: The individual unit of action that allows arrivals to interact with resources and other entities, perform custom routines while spending time in the system, move back and forth through the trajectory dynamically, and much more.
\end{itemize}

The \texttt{R} API (Application Programming Interface) exposed by \texttt{simmer} comprises two main elements: the \textbf{simmer environment} (or simulation environment) and the \textbf{trajectory object}.

\hypertarget{the-trajectory-object}{%
\section{The Trajectory Object}\label{the-trajectory-object}}

A trajectory can be defined as a recipe and consists of an ordered set of activities. The \texttt{trajectory()} method instantiates the object, and activities can be appended using the \texttt{\%\textgreater{}\%} operator:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(simmer)}
\FunctionTok{library}\NormalTok{(magrittr)}

\NormalTok{traj0 }\OtherTok{\textless{}{-}} \FunctionTok{trajectory}\NormalTok{() }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{log\_}\NormalTok{(}\StringTok{"Entering the trajectory"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{timeout}\NormalTok{(}\DecValTok{10}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{log\_}\NormalTok{(}\StringTok{"Leaving the trajectory"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

The trajectory above illustrates the two most basic activities available: displaying a message (\texttt{log\_()}) and spending some time in the system (\texttt{timeout()}).

An arrival attached to this trajectory will execute the activities in the given order, i.e., it will display ``Entering the trajectory'', then it will spend 10 units of (simulated) time, and finally it will display ``Leaving the trajectory''.

The example uses fixed parameters: a string and a numeric value respectively. However, at least the main parameter for all activities can also be what we will call a dynamical parameter, i.e., a function.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{traj1 }\OtherTok{\textless{}{-}} \FunctionTok{trajectory}\NormalTok{() }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{log\_}\NormalTok{(}\ControlFlowTok{function}\NormalTok{() }\StringTok{"Entering the trajectory"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{timeout}\NormalTok{(}\DecValTok{10}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{log\_}\NormalTok{(}\ControlFlowTok{function}\NormalTok{() }\StringTok{"Leaving the trajectory"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Let's check what happens if we print the trajectory:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{traj1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## trajectory: anonymous, 3 activities
## { Activity: Log          | message: function(), level: 0 }
## { Activity: Timeout      | delay: 10 }
## { Activity: Log          | message: function(), level: 0 }
\end{verbatim}

We see the three activities we have created in our trajectory: message + delay + message. There are many activities available. We will briefly review them by categorizing them into different topics.

\begin{itemize}
\tightlist
\item
  \textbf{Arrival properties}: Arrivals are able to store attributes and modify these using \texttt{set\_attribute()}. Arrivals also hold a set of three prioritization values for accessing resources, \texttt{priority}, \texttt{preemptible} and \texttt{restart}, and we can use them inside the \texttt{set\_priorization()} function.
\item
  \textbf{Interaction with resources}: The two main activities for interacting with resources are \texttt{seize()} and \texttt{release()}. In their most basic usage, they seize/release a given amount of a resource specified by name.
\item
  \textbf{Interaction with sources}: There are four activities specifically intended to modify arrival sources. An arrival may \texttt{activate()} or \texttt{deactivate()} a source, but also modify with \texttt{set\_trajectory()} the trajectory to which it attaches the arrivals created, or set a new inter-arrival distribution with \texttt{set\_source()}.
\item
  \textbf{Branching}: A branch is a point in a trajectory in which one or more sub-trajectories may be followed. Two types of branching are supported in \texttt{simmer.} The \texttt{branch()} activity places the arrival in one of the sub-trajectories depending on some condition evaluated in a dynamical parameter called option. On the other hand, the \texttt{clone()} activity is a parallel branch. It does not take any option.
\item
  \textbf{Loops}: There is a mechanism, \texttt{rollback()}, for going back in a trajectory and thus executing loops over a number of activities. This activity causes the arrival to step back a given amount of activities a number of times.
\item
  \textbf{Batching}: Batching consists of collecting a number of arrivals before they can continue their path in the trajectory as a unit 2 . This means that if, for instance, 10 arrivals in a batch try to seize a unit of a certain resource, only one unit may be seized, not 10.
\item
  \textbf{Asynchronous programming}: There are a number of methods enabling asynchronous events. The \texttt{send()} activity broadcasts one or more \textbf{signals} to all the arrivals subscribed to them. Signals can be triggered immediately or after some \textbf{delay}. Arrivals are able to block and \texttt{wait()} until a certain signal is received.
\item
  \textbf{Reneging}: Besides being rejected while trying to seize a resource, arrivals are also able to leave the trajectory at any moment, synchronously or asynchronously. Namely, reneging means that an arrival abandons the trajectory at a given moment. The most simple activity enabling this is \texttt{leave}, which immediately triggers the action given some probability.
\end{itemize}

\hypertarget{the-simulation-enviroment}{%
\section{The Simulation Enviroment}\label{the-simulation-enviroment}}

The simulation environment manages resources and sources, and controls the simulation execution. The \texttt{simmer()} method instantiates the object, after which resources and sources can be appended using the \texttt{\%\textgreater{}\%} operator:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{env }\OtherTok{\textless{}{-}} \FunctionTok{simmer}\NormalTok{() }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{add\_resource}\NormalTok{(}\StringTok{"res\_name"}\NormalTok{, }\DecValTok{1}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{add\_generator}\NormalTok{(}\StringTok{"arrival"}\NormalTok{, traj0, }\ControlFlowTok{function}\NormalTok{() }\DecValTok{25}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{print}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## simmer environment: anonymous | now: 0 | next: 0
## { Monitor: in memory }
## { Resource: res_name | monitored: TRUE | server status: 0(1) | queue status: 0(Inf) }
## { Source: arrival | monitored: 1 | n_generated: 0 }
\end{verbatim}

Then, the simulation can be executed, or \texttt{run()}, until a stop time:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{env }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{run}\NormalTok{(}\AttributeTok{until =} \DecValTok{30}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 25: arrival0: Entering the trajectory
\end{verbatim}

\begin{verbatim}
## simmer environment: anonymous | now: 30 | next: 35
## { Monitor: in memory }
## { Resource: res_name | monitored: TRUE | server status: 0(1) | queue status: 0(Inf) }
## { Source: arrival | monitored: 1 | n_generated: 2 }
\end{verbatim}

There are a number of methods for extracting information, such as the simulation time (\texttt{now()}), future scheduled events (\texttt{peek()}), and getters for obtaining resources' and sources' parameters (capacity, queue size, server count and queue count; number of arrivals generated so far). There are also several setters available for resources and sources (capacity, queue size; trajectory, distribution).

\begin{itemize}
\item
  \textbf{Resources}: A simmer resource comprises two internal self-managed parts: a \textbf{server} and a \textbf{priority queue}. Three main parameters define a resource: \texttt{name} of the resource, \texttt{capacity} of the server and \texttt{queue\_size} (0 means no queue). Resources are monitored, non-preemptive and assumes a first-in-first-out (FIFO) policy by default.
\item
  \textbf{Sources}: Three main parameters define a source: a \texttt{name\_prefix} for each generated arrival, a \texttt{trajectory} to attach them to and a source of inter-arrival times. There are two kinds of source: \textbf{generators} and \textbf{data sources}. A generator (\texttt{add\_generator} method) is a dynamic source that draws inter-arrival times from a user-provided function. The \texttt{add\_dataframe} method allows the user to set up a data source which draws arrivals from a provided data frame.
\end{itemize}

\hypertarget{monitoring-and-data-retrieval}{%
\section{Monitoring and data retrieval}\label{monitoring-and-data-retrieval}}

There are three methods for obtaining monitored data about arrivals, resources and attributes. They can be applied to a single simulation environment or to a list of environments, and the returning object is always a data frame.

\begin{itemize}
\tightlist
\item
  \texttt{get\_mon\_arrivals()}: Returns timing information per arrival: \texttt{name} of the arrival, \texttt{start\_time}, \texttt{end\_time}, \texttt{activity\_time} (time not spent in resource queues) and a flag, \texttt{finished}, that indicates whether the arrival exhausted its activities (or was rejected). By default, this information is referred to the arrivals' entire lifetime, but it may be obtained on a per-resource basis by specifying \texttt{per\_resource\ =\ TRUE}.
\item
  \texttt{get\_mon\_resources()}: Returns state changes in resources.
\item
  \texttt{get\_mon\_attributes()}: Returns state changes in attributes.
\end{itemize}

\hypertarget{simmer-example}{%
\section{\texorpdfstring{\texttt{simmer} Example}{simmer Example}}\label{simmer-example}}

Let's see an example in R of discrete event simulation in which we simulate the behavior of patients in a hospital.

First we have to load the \texttt{simmer} and \texttt{magrittr} libraries to do the simulation

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(simmer)}
\FunctionTok{library}\NormalTok{(magrittr)}
\end{Highlighting}
\end{Shaded}

With the \texttt{simmer} library we create a simulation environment that we are going to call \texttt{outpatient\ clinic}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{env }\OtherTok{=} \FunctionTok{simmer}\NormalTok{(}\StringTok{"outpatient clinic"}\NormalTok{)}
\NormalTok{env}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## simmer environment: outpatient clinic | now: 0 | next: 
## { Monitor: in memory }
\end{verbatim}

Second, we create the patient's trajectory. We do this using the \texttt{trajectory} function of the \texttt{simmer} library.

Within this path we create the activities of the entities in the trajectory using the \texttt{seize} and \texttt{release} functions. Among these functions we introduce the time that each patient takes to carry out each event, that would correspond with the activity of the entities.

For example, in the case of the nurse, we seize the entity with the function \texttt{seize}, we give it a time limit of 15 minutes (we do this simulating a random number with a normal distribution of mean 15 and standard deviation 1), and we release the entity with the function \texttt{release}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{patient }\OtherTok{=} \FunctionTok{trajectory}\NormalTok{(}\StringTok{"patients path"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{seize}\NormalTok{(}\StringTok{"nurse"}\NormalTok{, }\DecValTok{1}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{timeout}\NormalTok{(}\ControlFlowTok{function}\NormalTok{() }\FunctionTok{rnorm}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{15}\NormalTok{)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{release}\NormalTok{(}\StringTok{"nurse"}\NormalTok{, }\DecValTok{1}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  
  \FunctionTok{seize}\NormalTok{(}\StringTok{"doctor"}\NormalTok{, }\DecValTok{1}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{timeout}\NormalTok{(}\ControlFlowTok{function}\NormalTok{() }\FunctionTok{rnorm}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{20}\NormalTok{)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{release}\NormalTok{(}\StringTok{"doctor"}\NormalTok{, }\DecValTok{1}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  
  \FunctionTok{seize}\NormalTok{(}\StringTok{"administration"}\NormalTok{, }\DecValTok{1}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{timeout}\NormalTok{(}\ControlFlowTok{function}\NormalTok{() }\FunctionTok{rnorm}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{5}\NormalTok{)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{release}\NormalTok{(}\StringTok{"administration"}\NormalTok{, }\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Thirdly, we add the number of elements of the system using the \texttt{add\_resource} function.

In this case we introduce in the system two elements of the nurse type, three of the doctor type and two of the administration type.

We also generate the patient entity that will interact with the whole system using the \texttt{add\_generator} function. We will generate a patient every five minutes with a standard deviation of 0.5 minutes.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{env }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{add\_resource}\NormalTok{(}\StringTok{"nurse"}\NormalTok{, }\DecValTok{2}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{add\_resource}\NormalTok{(}\StringTok{"doctor"}\NormalTok{, }\DecValTok{3}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{add\_resource}\NormalTok{(}\StringTok{"administration"}\NormalTok{, }\DecValTok{2}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{add\_generator}\NormalTok{(}\StringTok{"patient"}\NormalTok{, patient, }\ControlFlowTok{function}\NormalTok{() }\FunctionTok{rnorm}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{5}\NormalTok{,}\FloatTok{0.5}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## simmer environment: outpatient clinic | now: 0 | next: 0
## { Monitor: in memory }
## { Resource: nurse | monitored: TRUE | server status: 0(2) | queue status: 0(Inf) }
## { Resource: doctor | monitored: TRUE | server status: 0(3) | queue status: 0(Inf) }
## { Resource: administration | monitored: TRUE | server status: 0(2) | queue status: 0(Inf) }
## { Source: patient | monitored: 1 | n_generated: 0 }
\end{verbatim}

We finally launch the simulation for 540 minutes. When the simulation is finished we can see how our resources are working in the simulated system.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{env }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{run}\NormalTok{(}\AttributeTok{until=}\DecValTok{540}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## simmer environment: outpatient clinic | now: 540 | next: 540.960538344821
## { Monitor: in memory }
## { Resource: nurse | monitored: TRUE | server status: 2(2) | queue status: 34(Inf) }
## { Resource: doctor | monitored: TRUE | server status: 3(3) | queue status: 0(Inf) }
## { Resource: administration | monitored: TRUE | server status: 1(2) | queue status: 0(Inf) }
## { Source: patient | monitored: 1 | n_generated: 108 }
\end{verbatim}

It is very easy to replicate a simulation multiple times using standard R functions.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{envs }\OtherTok{\textless{}{-}} \FunctionTok{lapply}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{100}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(i) \{}
  \FunctionTok{simmer}\NormalTok{(}\StringTok{"outpatient clinic"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{add\_resource}\NormalTok{(}\StringTok{"nurse"}\NormalTok{, }\DecValTok{2}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{add\_resource}\NormalTok{(}\StringTok{"doctor"}\NormalTok{, }\DecValTok{3}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{add\_resource}\NormalTok{(}\StringTok{"administration"}\NormalTok{, }\DecValTok{2}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{add\_generator}\NormalTok{(}\StringTok{"patient"}\NormalTok{, patient, }\ControlFlowTok{function}\NormalTok{() }\FunctionTok{rnorm}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{5}\NormalTok{,}\FloatTok{0.5}\NormalTok{)) }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{run}\NormalTok{(}\DecValTok{540}\NormalTok{)}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

This package provides some basic visualization tools to help you take a glance at your simulations quickly. There are three types of plot implemented with different metrics available:

\begin{itemize}
\tightlist
\item
  Plot of resources. Two metrics available:

  \begin{itemize}
  \tightlist
  \item
    the usage of a resource over the simulation time frame.
  \item
    the utilization of specified resources in the simulation.
  \end{itemize}
\item
  Plot of arrivals. Three metrics available:

  \begin{itemize}
  \tightlist
  \item
    activity time.
  \item
    waiting time.
  \item
    flow time.
  \end{itemize}
\item
  Plot of trayectories
\end{itemize}

With this graphs we can have a look at the overall resource utilization. The top and bottom of the error bars show respectively the 25th and 75th percentile of the utilization across all the replications. The top of the bar shows the median utilization.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(simmer.plot)}

\NormalTok{resources }\OtherTok{\textless{}{-}} \FunctionTok{get\_mon\_resources}\NormalTok{(envs)}
\FunctionTok{plot}\NormalTok{(resources, }\AttributeTok{metric =} \StringTok{"utilization"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{bookdownproj_files/figure-latex/unnamed-chunk-481-1.pdf}

It is also possible to have a look at resources' activity during the simulation.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{plot}\NormalTok{(resources, }\AttributeTok{metric =} \StringTok{"usage"}\NormalTok{, }\FunctionTok{c}\NormalTok{(}\StringTok{"nurse"}\NormalTok{, }\StringTok{"doctor"}\NormalTok{, }\StringTok{"administration"}\NormalTok{), }\AttributeTok{items =} \StringTok{"server"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{bookdownproj_files/figure-latex/unnamed-chunk-482-1.pdf}

Next we can have a look at the evolution of the arrivals' flow time during the simulation. In the plot below, each individual line represents a replication. A smooth line is drawn over them. All arrivals that didn't finish their entire trajectory are excluded from the plot.

Similarly one can have a look at the evolution of the activity times with \texttt{metric\ =\ "activity\_time"} and waiting times with \texttt{metric\ =\ "waiting\_time"}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{arrivals }\OtherTok{\textless{}{-}} \FunctionTok{get\_mon\_arrivals}\NormalTok{(envs)}
\FunctionTok{plot}\NormalTok{(arrivals, }\AttributeTok{metric =} \StringTok{"waiting\_time"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## `geom_smooth()` using method = 'gam' and formula 'y ~ s(x, bs = "cs")'
\end{verbatim}

\includegraphics{bookdownproj_files/figure-latex/unnamed-chunk-483-1.pdf}

Simulation trajectories may grow considerably, and they are not always easy to inspect to ensure their compliance with the model that we are trying to build. In this example we are going to expose a simple one:

\includegraphics{bookdownproj_files/figure-latex/unnamed-chunk-484-1.pdf}

Now that we know a bit about the \texttt{simmer} tool we are going to make some changes in the system to try to improve its efficiency. From what we have seen in the examples, it seems that the nurses are overworked. We will first try to ``hire'' a new nurse to improve the system.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{envs2 }\OtherTok{\textless{}{-}} \FunctionTok{lapply}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{100}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(i) \{}
  \FunctionTok{simmer}\NormalTok{(}\StringTok{"outpatient clinic"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{add\_resource}\NormalTok{(}\StringTok{"nurse"}\NormalTok{, }\DecValTok{3}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{add\_resource}\NormalTok{(}\StringTok{"doctor"}\NormalTok{, }\DecValTok{3}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{add\_resource}\NormalTok{(}\StringTok{"administration"}\NormalTok{, }\DecValTok{2}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{add\_generator}\NormalTok{(}\StringTok{"patient"}\NormalTok{, patient, }\ControlFlowTok{function}\NormalTok{() }\FunctionTok{rnorm}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{5}\NormalTok{,}\FloatTok{0.5}\NormalTok{)) }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{run}\NormalTok{(}\DecValTok{540}\NormalTok{)}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

Let's see how the system works with a new nurse through the plots:

\includegraphics{bookdownproj_files/figure-latex/unnamed-chunk-486-1.pdf}

\includegraphics{bookdownproj_files/figure-latex/unnamed-chunk-487-1.pdf}

\begin{verbatim}
## `geom_smooth()` using method = 'gam' and formula 'y ~ s(x, bs = "cs")'
\end{verbatim}

\includegraphics{bookdownproj_files/figure-latex/unnamed-chunk-488-1.pdf}

We can see that both doctors and nurses are now working at 100\% capacity. Now the problem seems to be coming from the administration. We are going to ``fire'' one of the workers in this area to try to improve the system.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{envs3 }\OtherTok{\textless{}{-}} \FunctionTok{lapply}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{100}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(i) \{}
  \FunctionTok{simmer}\NormalTok{(}\StringTok{"outpatient clinic"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{add\_resource}\NormalTok{(}\StringTok{"nurse"}\NormalTok{, }\DecValTok{3}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{add\_resource}\NormalTok{(}\StringTok{"doctor"}\NormalTok{, }\DecValTok{3}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{add\_resource}\NormalTok{(}\StringTok{"administration"}\NormalTok{, }\DecValTok{1}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{add\_generator}\NormalTok{(}\StringTok{"patient"}\NormalTok{, patient, }\ControlFlowTok{function}\NormalTok{() }\FunctionTok{rnorm}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{5}\NormalTok{,}\FloatTok{0.5}\NormalTok{)) }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{run}\NormalTok{(}\DecValTok{540}\NormalTok{)}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

Let's see how the system works without a administration worker through the plots:

\includegraphics{bookdownproj_files/figure-latex/unnamed-chunk-490-1.pdf}

\includegraphics{bookdownproj_files/figure-latex/unnamed-chunk-491-1.pdf}

\begin{verbatim}
## `geom_smooth()` using method = 'gam' and formula 'y ~ s(x, bs = "cs")'
\end{verbatim}

\includegraphics{bookdownproj_files/figure-latex/unnamed-chunk-492-1.pdf}

Great! We've found the perfect balance for our little hospital.

  \bibliography{book.bib,packages.bib}

\end{document}
