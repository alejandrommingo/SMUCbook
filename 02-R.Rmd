# R programming

R is a programming language most commonly used within the statistical and machine learning community. This chapter will review some of the elements of R programming that will be used in later chapters. Do not expect this chapter to be exhaustive or self-contained. It is intended to give a quick refresh of R for users that have at least some experience with this programming language. There are many topics and concepts which are fundamental but will not be reviewed in this chapter. However, you should aim to master the topics included in this chapter since they will appear again later on in these notes. There are many other resources if you want to have a more in-depth look into R programming.

 - The books of Hadley Wickham are surely a great starting point and are all available [here](http://hadley.nz/). 
 
 - If you are unsure on how to do something with R, Google it!!! The community of R users is so wide that surely someone else has already asked your same question.
 
 - The R help is extremely useful and comprehensive. If you want to know more about a function, suppose it is called function, you can type `?function`.

## Why R?

As mentioned in the previous chapter, simulation is very often applied in many areas, for instance management science and engineering. Often a simulation is carried out using an Excel spreadsheet or using a specialised software whose only purpose is creating simulations. Historically, R has not been at the forefront of the implementation of simulation models, in particular of discrete-event simulations. Only recently, R packages implementing discrete-event simulation have appeared, most importantly the `simmer` R package that you will learn using in later chapters.

These notes are intended to provide a unique view of simulation with specific implementation in the R programming language. Some of the strenght of R are:

 - it is free, open-source and available in all major operating systems;
 
 - the community of R users is huge, with many forums, sites and resources that give you practical support in developing your own code;
 
 - a massive set of add-on packages to increase the capabilities of the basic R environment;
 
 - functions to perform state-of-the-art statistical and machine-learning methods. Researchers sometimes create an associated R package to any article they publish so for others to use their methods;
 
 - the integrated development environment RStudio provides a user-friendly environment to make the R programming experience more pleasing;
 
 - powerful communication tools to create documents and presentations embedding R code and R output. As a matter of fact this very book is created in R!!!!
 
## Section Bibliography

* Crawley, M. J. (2012). The R book. John Wiley & Sons.
 
## R basics

So let's get started with R programming!

### Introduction to R

**R** is an *Open Source*, powerful, flexible and extensible statistical language. It is used by many companies (Google, Microsoft, Facebook, BBVA, etc...) and universities by Statisticians and Data Scientists in software development. Unlike traditional spreadsheets, in R programming sentences are written instead of the classic formulas. It is necessary to know the structure of the data. Prototypes can be made with a few lines of code.

### R History

R is an implementation of the statistical language S (combined with the programming language Scheme). S was developed in the AT&T labs by John Chambers in the late 1970s. The two main implementations of S are:

  - R
  - S+ (S-PLUS)

There are usually several releases a year (usually the most important in April):

  - 3.1.0 (Spring Dance) 10/04/2014
  - 3.2.0 (Full of Ingredients) 16/04/2015
  - 3.5.0 (Joy in Playing) 23/04/2018
  - 4.0.0 (Bunny-Wunnies Freak Out) 24/04/2020
  - 4.1.0 (Camp Pontanezen) 18/05/2021

### R Advantages

R is a great software for solving data analysis problems. There are many packages for data processing, statistical modelling, data mining and graphics. There is a community of users creating packages called [the R project](https://www.r-project.org). 

R is very useful for making graphs, analyzing data and obtaining statistical models with data that fit in the RAM memory of the PC. There are limitations, from a memory point of view, with large volumes of data. It is very common to use another resources to prepare the data:

+ Small or medium volumes: Python, Julia, Perl...
+ Large Volumes: Spark, Hadoop, Pig, Hive...

### What do we mean by R?

By R we usually mean:

+ The programming language.
+ The interpreter who executes the code written in R.
+ The graphics generation system of R.
+ The R programming IDE, or also known as RStudio (includes the R interpreter, graphics system, package manager and user interface).

### Console Mode

To open the **R console**, run from the command line (Terminal in Mac):

`$>R`

The console opens, which allows you to write commands interactively. Each of these commands is called **expressions**. The **R interpreter** reads these expressions and responds with the result or an error message. The command interface will store the steps followed when analyzing the data.

The `history()` command displays the history of commands entered during the **R session**. Names of variables, packages, directories, etc. are auto-completed using **tabulator**. If the name of a function is written in the console, its code is displayed. For example: `history`

```{r}
history
```

### Getting help in R

The simplest way to get help in R is to click on the Help button on the toolbar of the RGui window (this stands for R’s Graphic User Interface).

However, if you know the name of the function you want help with, you just type a question mark `?` at the command line prompt followed by the name of the function. So to get help on `read.table`, just type:

```{r}
?read.table
```

Sometimes you cannot remember the precise name of the function, but you know the subject on which you want help (e.g. data input in this case). Use the help.search function (without a question mark) with your query in double quotes like this:

```{r}
help.search("read tables")
```

Other useful functions are `find` and `apropos`. The `find` function tells you what package something is in:

```{r}
find("mean")
```

while `apropos` returns a character vector giving the names of all objects in the search list that match your (potentially partial) enquiry:

```{r}
apropos("lm")
```

To see a worked example just type the function name (e.g. linear models, `lm`) and you will see the printed and graphical output produced by the `lm` function:

```{r}
example(lm)
```

Demonstrations of R functions can be useful for seeing the range of things that R can do. Here are some for you to try:

```{r}
#demo(persp)
#demo(graphics)
#demo(Hershey)
#demo(plotmath)
```

### Packages in R

Finding your way around the contributed packages can be tricky, simply because there are so many of them, and the name of the package is not always as indicative of its function as you might hope. There is no comprehensive cross-referenced index, but there is a very helpful feature called ‘Task Views’ on CRAN, which explains the packages available under a limited number of usefully descriptive headings.

[Click here to see the 'Task Views'](https://cran.r-project.org/)

### Built-in R libraries

To use one of the built-in libraries, simply type the library function with the name of the library in brackets. Thus, to load the `dplyr` library type:

```{r}
library(dplyr)
```

### Contents of Packages

It is easy to use the `help` function to discover the contents of library packages. Here is how you find out about the contents of the `dplyr` library:

```{r}
library(help=dplyr)
```

Then, to find out how to use, say, mutate (`mutate`), just type:

```{r}
?mutate
```

### Installing Packages

The base package does not contain some of the libraries referred to in this course, but downloading these is very simple. Before you start, you should check whether you need to “Run as administrator” before you can install packages (right click on the R icon to find this). 

Run the R program, then from the command line use the install.packages function to download the libraries you want. For example, to install the `ggplot2` package type this:

```{r}
#install.packages("ggplot2")
```

### Command line versus scripts

When writing functions and other multi-line sections of input you will find it useful to use a text editor rather than execute everything directly at the command line.

Currently, most users prefer to use an IDE rather than executable text files. The most famous IDE for using R is [Rstudio](https://rstudio.com/).

### RStudio

Programming IDE to develop projects in R: https://www.rstudio.com/

There are two versions:

+ RStudio Desktop
+ RStudio Server (RStudio Desktop interface in web version)

Both versions have open source (free) and commercial (with support included) versions.

Allows the complete management of a software project:

+ Console R
+ File management
+ Help
+ Package management (installation, update, etc.)
+ Review of command history

<p align="center">
  <img src="./images/R-programming/r-studio.png" width="1050">
</p> 

### Working Directory

As we have mentioned, R is a programming language that allows us to perform certain actions through an IDE installed in our computer. 

In many cases we will need to store data or code sets to use them later. We may also need to read a data set from an external format or even write it. To do all these things, we need to know where we are on the computer, in other words, which folder we are currently in.

We will call this location the working directory. We are going to place there all the resources we need to work with R.

We will use the function setwd() to indicate our location to the R session we are working at.

Example:

```
setwd("C://User/Desktop/My_Working_Directory")
```

### Exercise: Set up your Working Directory

You have 10 minutes to start getting familiar with Rstudio and to set your working directory in a folder that is suitable for the rest of the course. 

Remember, within this folder you can create sub-folders for each session in which you can include all the necessary material.

To carry out this exercise you have a designated room with the rest of your work group. Try to solve the doubts together, and in case you don't find a solution you can call me to assist you during the exercise time.

## Expressions, Objects and Symbols

The R code is composed by expressions. Some examples of expressions:
  
- Assignments
- Conditional sentences
- Arithmetic operations
- ...

Expressions are made up of objects and functions. Each expression is separated from another by a new line or semicolon (;).

The R code manipulates objects. Some examples of objects:

* Vectors
* Lists
* Functions
* ...

Formally the variable names in R are called symbols. Thus, we assign the object to a symbol of the current environment. The environment is formed by the set of symbols in a certain context.

### Some examples to start with

We can use R for many things, but there are certain basics that need to be learned. When we enter a code in the R console, this code will provide us with an output. Let's look at an example: If we enter a number or a word, R will return the same number or word.

```{r}
23
"Baby Yoda"
```

Each of these codes we have generated is interpreted by R, sent to our computer in a low level language, and returned in an understandable format for us. 

Each code can be understood as an object (not stored) that R is interpreting for us. If we want to store that objects in our computer RAM to use them later in the same R session we need to create an assignment (we assign something to a symbol). Example:

```{r}
my_number = 23
my_character = "Baby Yoda"
```

So we can use them later. For example, let's just print them:

```{r}
print(my_number)
print(my_character)
```

Notice that to assign something to a symbol we can use `=` or `<-`:

```{r}
my_number = 23
my_character = "Baby Yoda"
```

```{r}
print(my_number)
print(my_character)
```

## R as a Calculator

The screen prompt `>` is an invitation to put R to work. You can use the Rstudio command line as a calculator, like this:

```{r}
log(42/7.3)
```

Each line can have at most 8192 characters, but if you want to see a lengthy instruction or a complicated expression on the screen, you can continue it on one or more further lines simply by ending the line at a place where the line is obviously incomplete (e.g. with a trailing comma, operator, or with more left parentheses than right parentheses, implying that more right parentheses will follow). 

When continuation is expected, the prompt changes from > to +:

```{r}
5+6+3+6+4+2+4+8+
3+2+7
```

Note that the + continuation prompt does not carry out arithmetic plus. If you have made a mistake, and you want to get rid of the + prompt and return to the > prompt, then press the Esc key and use the Up arrow to edit the last (incomplete) line.

Two or more expressions can be placed on a single line so long as they are separated by semi-colons:

```{r}
2+3; 5*7; 3-7
```

For very big numbers or very small numbers R uses the following scheme (called exponents):

* `1.2e3`: means 1200 because the e3 means ‘move the decimal point 3 places to the right’
* `1.2e-2`: means 0.012 because the e-2 means ‘move the decimal point 2 places to the left’
* `3.9+4.5i`: is a complex number with real (3.9) and imaginary (4.5) parts, and i is the square root of –1.

### Complex numbers in R

Complex numbers consist of a real part and an imaginary part, which is identified by lower-case i like this:

```{r}
z = 3.5-8i
```

The elementary trigonometric, logarithmic, exponential, square root and hyperbolic functions are all
implemented for complex values. The following are the special R functions that you can use with com-
plex numbers:

* Determine the real part:

```{r}
Re(z)
```

* Determine the imaginary part:

```{r}
Im(z)
```

* Calculate the modulus (if x is the real part and y is the imaginary part, then the modulus is $\sqrt(x^2 + y^2)$):

```{r}
Mod(z)
```

* Calculate the argument (`Arg(x+ yi)= atan(y/x)`):

```{r}
Arg(z)
```

* Work out the complex conjugate (change the sign of the imaginary part):

```{r}
Conj(z)
```

* Check if the object is a complex number:

```{r}
is.complex(z)
```

* Coerce a number into a complex number:

```{r}
as.complex(3.8)
```

### Rounding

Various sorts of rounding (rounding up, rounding down, rounding to the nearest integer) can be done easily. Take the number `5.7` as an example. The ‘greatest integer less than’ function is `floor`:

```{r}
floor(5.7)
```

The ‘next integer’ function is ceiling:

```{r}
ceiling(5.7)
```

You can round to the nearest integer by adding 0.5 to the number, then using floor. There is a built-in function for this, but we can easily write one of our own to introduce the notion of function writing. Call it `rounded`, then define it as a function like this:

```{r}
rounded = function(x){floor(x+0.5)}
```

Now we can use the new function:

```{r}
rounded(5.7)
```

```{r}
rounded(5.4)
```

There is an R function called round that you can use by specifying 0 decimal places in the second
argument:

```{r}
round(5.7,0)
```

```{r}
round(5.4,0)
```

```{r}
round(-5.7,0)
```

### Arithmetics

The screen prompt in R is a fully functional calculator. You can add and subtract using the obvious `+` and `-` symbols, while division is achieved with a forward slash `/` and multiplication is done by using an asterisk `*` like this:

```{r}
7 + 3 - 5 * 2
```

Notice from this example that multiplication `(5 × 2)` is done *before* the additions and subtractions. 

Powers (like squared or cube root) use the caret symbol `ˆ` and are done before multiplication or division, as you can see from this example:

```{r}
3^2 / 2
```

All the mathematical functions you could ever want are here (see Table 2.1).

<p align="center">
  <img src="./images/R-programming/2.1table.png" width="1050">
</p> 

The `log` function gives logs to the base e (e = 2.718 282), for which the antilog function is `exp`:

```{r}
log(10)
```

```{r}
exp(1)
```

Logs to other bases are possible by providing the `log` function with a second argument which is the base of the logs you want to take. Suppose you want log to base 3 of 9:

```{r}
log(9,3)
```

The trigonometric functions in R measure angles in radians. A circle is $2\pi$ radians, and this is $360^\circ$ , so a right angle ($90^\circ$) is $\pi / 2$ radians. R knows the value of $\pi$ as `pi`:

```{r}
pi
```

```{r}
sin(pi/2)
```

```{r}
cos(pi/2)
```

Notice that the cosine of a right angle does not come out as exactly zero, even though the sine came out as exactly 1. The `e-017` means ‘times $10^{–17}$ ’. While this is a very small number, it is clearly not exactly zero.

### Modulo and integer quotients

Integer quotients and remainders are obtained using the notation `%/%` (percent, divide, percent) and `%%` (percent, percent) respectively. Suppose we want to know the integer part of a division: say, how many 13s are there in 119:

```{r}
119 %/% 13
```

Now suppose we wanted to know the remainder (what is left over when 119 is divided by 13): in maths this is known as **modulo**:

```{r}
119 %% 13
```

Modulo is very useful for testing whether numbers are odd or even: odd numbers have modulo 2 value 1 and even numbers have modulo 2 value 0:

```{r}
9 %% 2
```

```{r}
8 %% 2
```

Likewise, you use modulo to test if one number is an exact multiple of some other number. For instance, to find out whether 15 421 is a multiple of 7 (which it is), then ask:

```{r}
15421 %% 7
```

### Operators

R uses the following operator tokens:

* `+ - * / %/% %% ˆ`: arithmetic (plus, minus, times, divide, integer quotient, modulo, power)
* `>= < <= == !=`: relational (greater than, greater than or equals, less than, less than or equals, equals, not equals)
* `! & |`: logical (not, and, or)
* `~`: model formulae (‘is modelled as a function of’)
* `= ->`: assignment (gets)
* `$`: list indexing (the ‘element name’ operator)
* `:`: create a sequence

Several of these operators have different meaning inside model formulae. Thus * indicates the main effects plus interaction (rather than multiplication), : indicates the interaction between two variables (rather than generate a sequence) and ˆ means all interactions up to the indicated power (rather than raise to the power). You will learn more about these ideas in further sessions.


## R Basic Data types

In the previous examples we worked with numbers, but variables could be assigned other types of information. There are four basic types:
 
  - *Integers*: integer numbers. If you type an integer in R, as before 3 or 4, it will usually be stored as a double unless explicitly defined;
 
 - *Doubles*: real numbers;
 
 - *Logicals* or *Booleans*: corresponding to `TRUE` and `FALSE`, also abbreviated as `T` and `F` respectively;
 
 - *Characters*: strings of text surrounded by `"` (for example `"hi"`) or by `'` (for example 'by');
 
 - *Dates*: date-time expressions in R.
 
### Integers

Integer vectors exist so that data can be passed to C or Fortran code which expects them, and so that small integer data can be represented exactly and compactly. The range of integers is from −2 000 000 000 to + 2 000 000 000 (`-2*10ˆ9 to +2*10ˆ9`, which R could portray as `-2e+09` to `2e+09`).

Be careful. Do not try to change the class of a vector by using the `integer` function. Here is a numeric vector of whole numbers that you want to convert into a vector of integers:

```{r}
x = c(5,3,7,8)
is.integer(x)
```

```{r}
is.numeric(x)
```

To coerce a numeric vector to be an integers vector we have to use the `as.integer` function like this:

```{r}
x = c(5,3,7,8)
x = as.integer(x)
is.integer(x)
```

The integer function works as trunc when applied to real numbers, and removes the imaginary part when
applied to complex numbers:

```{r}
as.integer(5.7)
```

```{r}
as.integer(5.7 -3i)
```

### Integer vs. Double

The two most common numeric classes used in R are integer and double (for double precision floating point numbers). R automatically converts between these two classes when needed for mathematical purposes. As a result, it’s feasible to use R and perform analyses for years without specifying these differences.

By default, when you create a numeric vector using the `c()` function it will produce a vector of double precision numeric values. To create a vector of integers using `c()` you must specify explicity by placing an L directly after each number.

```{r}
dbl_var = c(1, 2.5, 4.5)
dbl_var
```

```{r}
int_var = c(1L, 6L, 10L)
int_var
```

To check whether a vector is made up of integer or double values:

```{r}
typeof(dbl_var)
```

```{r}
typeof(int_var)
```

By default, if you read in data that has no decimal points or you create numeric values using the `x = 1:10` method the numeric values will be coded as integer. If you want to change a double to an integer or vice versa you can specify one of the following:

```{r}
# integers to doubles
as.double(int_var)
```

```{r}
# doubles to integers
as.integer(dbl_var)
```

### Logical operators

A crucial part of computing involves asking questions about things. Is one thing bigger than other? Are two things the same size? Questions can be joined together using words like ‘and’ ‘or’, ‘not’. Questions in R typically evaluate to `TRUE` or `FALSE` but there is the option of a ‘maybe’ (when the answer is not available, `NA`). In R, < means ‘less than’, > means ‘greater than’, and ! means ‘not’ (see Table 2.2).

<p align="center">
  <img src="./images/R-programming/2.2table.png" width="1050">
</p> 

You can use `T` for TRUE and `F` for FALSE, but you should be aware that `T` and `F` might have been allocated
as variables. So this is obvious:

```{r}
TRUE == FALSE
```

```{r}
T == F
```

This, however, is not so obviours:

```{r}
T = 0
T == FALSE
```

```{r}
F = 1
TRUE == F
```

But now, of course, `T` is not equal to `F`:

```{r}
T != F
```

To be sure, always write TRUE and FALSE in full, and never use T or F as variable names.

Maybe you noticed in the last code chunk that, in R, TRUE is coded as `1` and FALSE as `0`:

```{r}
TRUE == 1
```

```{r}
FALSE == 0
```

Let's remove the T and F variables to avoid future errors:

```{r}
rm(list = c(T,F))
```

### Real numbers equality

You need to be careful in programming when you want to test whether or not two computed numbers are equal. R will assume that you mean ‘exactly equal’, and what that means depends upon machine precision. Most numbers are rounded to an accuracy of 53 binary digits. 

Typically therefore, two floating point numbers will not reliably be equal unless they were computed by the same algorithm, and not always even then. You can see this by squaring the square root of 2: surely these values are the same?

```{r}
x = sqrt(2)
x * x == 2
```

In fact, they are not the same. We can see by how much the two values differ by subtraction:

```{r}
x * x - 2
```

So how do we test for equality of real numbers? The best advice is not to do it. Try instead to use the alternatives ‘less than’ with ‘greater than or equal to’, or conversely ‘greater than’ with ‘less than or equal to’. Then you will not go wrong. Sometimes, however, you really do want to test for equality. In those circumstances, do not use double equals to test for equality, but employ the `all.equal` function instead.

```{r}
x = 0.3 - 0.2
y = 0.1
x == y
```

```{r}
all.equal(x,y)
```

WARNING: Do not use `all.equal` directly in `if` expressions. Either use `isTRUE(all.equal( ....))`

### Logical arithmetic

Arithmetic involving logical expressions is very useful in programming and in selection of variables. The key thing to understand is that logical expressions evaluate to either true or false (represented in R by `TRUE` or `FALSE`), and that R can coerce `TRUE` or `FALSE` into numerical values: 1 for `TRUE` and 0 for `FALSE`. Suppose that x is a sequence from 0 to 6 like this:

```{r}
x = 0:6
```

Now we can ask questions about the contents of the vector called x. Is x less than 4?

```{r}
x < 4
```

The answer is yes for the first four values (0, 1, 2 and 3) and no for the last three (4, 5 and 6). 

Two important logical functions are `all` and `any`. They check an entire vector but return a single logical value: `TRUE` or `FALSE`. Are all the x values bigger than 0?

```{r}
all(x>0)
```

No. The first x value is a zero. Are any of the x values negative?

```{r}
any(x<0)
```

No. The smallest x value is a zero.

We can use the answers of logical functions in arithmetic. We can count the true values of (`x<4`), using `sum`:

```{r}
sum(x<4)
```

We can multiply (x<4) by other vectors:

```{r}
(x<4) * runif(7)
```

### Characters

In R, character strings are defined by double quotation marks:

```{r}
a = "abc"
b = "123"
```

Numbers can be coerced to characters (as in b above), but non-numeric characters cannot be coerced to
numbers:

```{r}
as.numeric(a)
```

```{r}
as.numeric(b)
```

One of the initially confusing things about character strings is the distinction between the length of a character object (a vector), and the numbers of characters (nchar) in the strings that comprise that object. 
An example should make the distinction clear:

```{r}
pets = c("cat","dog","gerbil","terrapin")
```

Here, `pets` is a vector comprising four character strings:

```{r}
length(pets)
```

and the individual character strings have 3, 3, 6 and 8 characters, respectively:

```{r}
nchar(pets)
```

When first defined, character strings are not factors:

```{r}
class(pets)
```

```{r}
is.factor(pets)
```

We have to coerce this variable to convert it into a factor

```{r}
pets = as.factor(pets)
is.factor(pets)
```

### Characters: letters vectors

There are built-in vectors in R that contain the 26 letters of the alphabet in lower case (letters) and in upper
case (LETTERS):

```{r}
letters
```

```{r}
LETTERS
```

To discover which number in the alphabet the letter `n` is, you can use the `which` function like this:

```{r}
which(letters == "n")
```

For the purposes of printing you might want to suppress the quotes that appear around character strings by default. The function to do this is called noquote:

```{r}
noquote(letters)
```

### Characters: Pasting strings together

You can amalgamate individual strings into vectors of character information:

```{r}
c(a,b)
```

This shows that the concatenation produces a vector of two strings. It does not convert two 3-character strings into one 6-character string. The R function to do that is `paste`:

```{r}
paste(a,b,sep = "")
```

The third argument, `sep=""`, means that the two character strings are to be pasted together without any separator between them: the default for `paste` is to insert a single blank space, like this:

```{r}
paste(a,b)
```

Notice that you do not lose blanks that are within character strings when you use the `sep=""` option in
`paste`.

```{r}
paste(a,b," a longer phrase containing blanks",sep="")
```

If one of the arguments to `paste` is a vector, each of the elements of the vector is pasted to the specified character string to produce an object of the same length as the vector:

```{r}
d = c(a,b,"new")
e = paste(d, "a longer phrase containing blanks")
e
```

### Characters: Extracting parts of strings

We being by defining a phrase:

```{r}
phrase = "the quick brown fox jumps over the lazy dog"
```

The function called `substr` is used to extract substrings of a specified number of characters from within a character string. In the next example we are extracting the first 20 characters from `phrase` object:

```{r}
substr(phrase, 1, 20)
```

The second argument in `substr` is the number of the character at which extraction is to begin (in this case the first), and the third argument is the number of the character at which extraction is to end (in this case, the 20th).

### Characters: Counting things within strings

Counting the total number of characters in a string could not be simpler; just use the `nchar` function directly, like this:

```{r}
nchar(phrase)
```

So there are 43 characters including the blanks between the words. To count the numbers of separate individual characters (including blanks) you need to split up the character string into individual characters (43 of them), using `strsplit` like this:

```{r}
strsplit(phrase, split = "")
```

The `split = ""` argument is for determine the character we are going to use to split the entire object. If we use a blank space instead we can separate the string in all the different words:

```{r}
strsplit(phrase, split = " ")
```

The table function can then be used for counting the number of occurrences of each of the characters:

```{r}
table(strsplit(phrase, split = ""))
```

This demonstrates that all of the letters of the alphabet were used at least once within our phrase, and that there were eight blanks within the string called phrase. This suggests a way of counting the number of words in a phrase, given that this will always be one more than the number of blanks (so long as there are no leading or trailing blanks in the string):

```{r}
nwords = 1+table(strsplit(phrase, split = ""))[1]
nwords
```

Another solution is to `sum` all the elements in the table splitting the phrase with a blank space:

```{r}
sum(table(strsplit(phrase, split = " ")))
```

### Characters: Upper- and lower-case text

It is easy to switch between upper and lower cases using the `toupper` and `tolower` functions:

```{r}
toupper(phrase)
```

```{r}
tolower(toupper(phrase))
```

### Dates and times

The measurement of time is highly idiosyncratic. Successive years start on different days of the week. There are months with different numbers of days. Leap years have an extra day in February. Americans and Britons put the day and the month in different places: 3/4/2006 is March 4 for the former and April 3 for the latter. 

All these things mean that working with dates and times is extremely complicated. Fortunately, R has a robust system for dealing with this complexity. 

To see how R handles dates and times, have a look at Sys.time():

```{r}
Sys.time()
```

This description of date and time is strictly hierarchical from left to right: the longest time scale (years) comes first, then month, then day, separated by hyphens, then there is a blank space, followed by the time, with hours first (using the 24-hour clock), then minutes, then seconds, separated by colons. Finally, there is a character string explaining the time zone (CET stands for Central Europe Time)

This representation of the date and time as a character string is user-friendly and familiar, but it is no good for calculations. For that, we need a single numeric representation of the combined date and time. The convention in R is to base this on seconds (the smallest time scale that is accommodated in Sys.time)

The baseline for expressing today’s date and time in seconds is 1 January 1970:

```{r}
as.numeric(Sys.time())
```

This is fine for plotting time series graphs, but it is not much good for computing monthly means (e.g. is the mean for June significantly different from the July mean?) or daily means (e.g. is the Monday mean significantly different from the Friday mean?). 

To answer questions like these we have to be able to access a broad set of categorical variables associated with the date: the year, the month, the day of the week, and so forth. To accommodate this, R uses the POSIX system for representing times and dates:

```{r}
class(Sys.time())
```

You can think of the class `POSIXct`, with suffix ‘ct’, as continuous time (i.e. a number of seconds), and
`POSIXlt`, with suffix ‘lt’, as list time (i.e. a list of all the various categorical descriptions of the time,
including day of the week and so forth). It is hard to remember these acronyms, but it is well worth making
the effort. Naturally, you can easily convert to one representation to the other:

```{r}
time.list = as.POSIXlt(Sys.time())
unlist(time.list)
```

Here you see the nine components of the list. The time is represented by the number of seconds (`sec`), minutes (`min`) and hours (on the 24-hour clock). Next comes the day of the month (`mday`, starting from 1), then the month of the year (mon, starting at January = 0), then the year (starting at 0 = 1900). The day of the week (`wday`) is coded from Sunday = 0 to Saturday = 6. The day within the year (`yday`) is coded from 0 = January 1. Finally, there is a logical variable `isdst` which asks whether daylight saving time is in operation (0 = FALSE in this case). The ones you are most likely to use include `year` (to get yearly mean values), `mon` (to get monthly means) and `wday` (to get means for the different days of the week).

### Dates and times: Reading time data from files

It is most likely that your data files contain dates in Excel format, for example 03/09/2014 (a character string showing month/day/year separated by slashes).

```{r}
df = read.csv(file = "Data/boulder-precip.csv")
attach(df)
head(df)
```

To convert a factor or a character string into a POSIXlt object, we employ an important function called ‘strip time’, written `strptime`.

### Dates and times: The `strptime` function

To convert a factor or a character string into dates using the strptime function, we provide a format statement enclosed in double quotes to tell R exactly what to expect, in what order, and separated by what kind of symbol. For our present example we have day (as two digits), then slash, then month (as two digits), then slash, then year (without the century, making two digits).

```{r}
Rdate = strptime(DATE, "%m/%d/%y")
class(Rdate)
```

It is always a good idea at this stage to add the R-formatted date to your dataframe:

```{r}
df = data.frame(df, Rdate)
head(df)
```

Now, at last, we can do things with the date information. We might want the mean value of `PRECIP` for each day of the week. The name of this object is Rdate$wday:

```{r}
tapply(PRECIP,Rdate$wday,mean)
```

It is hard to remember all the format codes for strip time, but they are roughly mnemonic and they are always preceded by a percent symbol. Here is the full list of format components:

+ `%a`: Abbreviated weekday name
+ `%A`: Full weekday name
+ `%b`: Abbreviated month name
+ `%B`: Full month name
+ `%c`: Date and time, locale-specific
+ `%d`: Day of the month as decimal number (01–31)
+ `%H`: Hours as decimal number (00–23) on the 24-hour clock
+ `%I`: Hours as decimal number (01–12) on the 12-hour clock
+ `%j`: Day of year as decimal number (0–366)
+ `%m`: Month as decimal number (0–11)
+ `%M`: Minute as decimal number (00–59)
+ `%p`: AM/PM indicator in the locale
+ `%S`: Second as decimal number (00–61, allowing for two ‘leap seconds’)
+ `%U`: Week of the year (00–53) using the first Sunday as day 1 of week 1
+ `%w`: Weekday as decimal number (0–6, Sunday is 0)
+ `%W`: Week of the year (00–53) using the first Monday as day 1 of week 1
+ `%x`: Date, locale-specific
+ `%X`: Time, locale-specific
+ `%Y`: Year with century
+ `%y`: Year without century
+ `%Z`: Time zone as a character string (output only)

There is a useful function called weekdays (note the plural) for turning the day number into the appropriate name:

```{r}
y = strptime("01/02/2020", format="%d/%m/%Y")
weekdays(y)
```

which is converted from:

```{r}
y$wday
```

because the days of the week are numbered from Sunday = 0.

Here is another kind of date, with years in two-digit form (`%y`), and the months as abbreviated names (`%b`) using no separators:

```{r}
other.dates = c("1jan99", "2jan05", "31mar04", "30jul05")
strptime(other.dates, "%d%b%y")
```

Here is yet another possibility with year, then month in full, then week of the year, then day of the week abbreviated, all separated by a single blank space:

```{r}
yet.another.date = c("2016 January 2 Mon","2017 February 6 Fri","2018 March 10 Tue")
strptime(yet.another.date,"%Y %B %W %a")
```

### Dates and times: Summary

The key thing to understand is the difference between the two representations of dates and times in R. They have unfortunately non-memorable names.

+ POSIXlt gives a list containing separate vectors for the year, month, day of the week, day within the year, and suchlike. It is very useful as a categorical explanatory variable (e.g. to get monthly means from data gathered over many years using date$mon).
+ POSIXct gives a vector containing the date and time expressed as a continuous variable that you can use in regression models (it is the number of seconds since the beginning of 1970).


### Testing and coercing

The concepts of membership and coercion may be unfamiliar. Membership relates to the class of an object in R. Coercion changes the class of an object. For instance, a logical variable has class `logical` and mode logical. This is how we create the variable:

```{r}
lv = c(TRUE,FALSE,TRUE)
```

We can assess its membership by asking if it is a logical variable using the `is.logical` function:

```{r}
is.logical(lv)
```

It is not a factor, and so it does not have levels:

```{r}
levels(lv)
```

But we can coerce it be a two-level factor like this:

```{r}
fv = as.factor(lv)
fv
```

We can coerce a logical variable to be numeric: `TRUE` evaluates to 1 and `FALSE` evaluates to zero, like this:

```{r}
nv = as.numeric(lv)
nv
```

In general, the expression `as(object, value)` is the way to coerce an object to a particular class. Membership functions ask `is.something` and coercion functions say `as.something`.

Objects have a type, and you can test the type of an object using an is.type function (Table 2.3). For instance, mathematical functions expect numeric input and text-processing functions expect character input. Some types of objects can be coerced into other types. A familiar type of coercion occurs when we interpret the TRUE and FALSE of logical variables as numeric 1 and 0, respectively. Factor levels can be coerced to numbers. Numbers can be coerced into characters, but non-numeric characters cannot be coerced into numbers.

<p align="center">
  <img src="./images/R-programming/2.3table.png" width="1050">
</p> 

### Missing values, infinity and things that are not numbers

Calculations can lead to answers that are plus infinity, represented in R by `Inf`, or minus infinity, which is represented as `-Inf`:

```{r}
3/0
```

```{r}
-12/0
```

Calculations involving infinity can be evaluated: for instance,

```{r}
exp(-Inf)
0/Inf
```

Other calculations, however, lead to quantities that are not numbers. These are represented in R by NaN (‘not a number’). Here are some of the classic cases:

```{r}
0/0
Inf-Inf
Inf/Inf
```

You need to understand clearly the distinction between `NaN` and `NA` (this stands for ‘not available’ and is the missing-value symbol in R). 

The function `is.nan` is provided to check specifically for `NaN`, and `is.na` also returns `TRUE` for `NaN`. Coercing `NaN` to logical or integer type gives an `NA` of the appropriate type. There are built-in tests to check whether a number is finite or infinite:

Missing values in dataframes are a real source of irritation, because they affect the way that model-fitting functions operate and they can greatly reduce the power of the modelling that we would like to do. 

You may want to discover which values in a vector are missing. Here is a simple case:

```{r}
y = c(4,NA,7)
```

The missing value question should evaluate to `FALSE TRUE FALSE`. There are two ways of looking for missing values that you might think should work, but do not. These involve treating `NA` as if it was a piece of text and using double equals (==) to test for it. So this does not work:

```{r}
y == NA
```

because it turns all the values into `NA` (definitively not what you intended). This does not work either:

```{r}
y == "NA"
```

It correctly reports that the numbers are not character strings, but it returns `NA` for the missing value itself, rather than `TRUE` as required. This is how you do it properly:

```{r}
is.na(y)
```

To produce a vector with the `NA` stripped out, use subscripts with the not `!` operator like this:

```{r}
y[! is.na(y)]
```

Some functions do not work with their default settings when there are missing values in the data, and `mean` is a classic example of this:

```{r}
x = c(1:8, NA)
mean(x)
```

In order to calculate the mean of the non-missing values, you need to specify that the NA are to be removed, using the `na.rm=TRUE` argument:

```{r}
mean(x, na.rm = T)
```


## R Basic Data Structures

### Vectors

A vector is a variable with one or more values of the same type (atomic one dimensional arrays). For instance, the numbers of peas in six pods were 4, 7, 6, 5, 6 and 7. The vector called peas is one object of `length = 6`. In this case, the class of the object is numeric. The easiest way to create a vector in R is to concatenate (link together) the six values using the concatenate function, `c`, like this:

```{r}
peas = c(4, 7, 6, 5, 6, 7)
```

We can ask all sorts of questions about the vector called peas. For instance, what type of vector is it?

```{r}
class(peas)
```

How big is the vector?

```{r}
length(peas)
```

The great advantage of a vector-based language is that it is very simple to ask quite involved questions that involve all of the values in the vector. These vector functions are often self-explanatory:

```{r}
mean(peas)
```
```{r}
max(peas)
```
```{r}
min(peas)
```

Another way to create a vector is to input data from the keyboard using the function called `scan`:

```{r}
#peas = scan()
```

The prompt appears `1:` which means type in the first number of peas (4) then press the return key, then the prompt `2:` appears (you type in 7) and so on. When you have typed in all six values, and the prompt `7:` has appeared, you just press the return key to tell R that the vector is now complete. R replies by telling you how many items it has read:

```
Read 6 items
```

As we explained, vectors are single-dimensional arrays. The array indexes range from 1 to the vector length, `length(v)`. Vectors are also known as atomic vectors.

All elements of the vector are of the same basic type:

+ logical
+ integer
+ double
+ character
+ complex

It has a fixed size that is fixed in its creation. The simplest way to create a vector is by using the combination function `c(v1, v2,...)`. To name the elements of a vector we use the function `names(v)`. Here you have some different ways to create vectors in R:

+ Using the `vector` function

```{r}
# Logical Vector
v1 = vector(mode = 'logical', length = 4)
v1
```

```{r}
# Integer vector
v2 = vector(mode = 'integer', length = 4)
v2
```

+ Using the "type" function

```{r}
# Numeric vector
v3 = numeric(4)
v3
```

```{r}
# Character vector
v4 = character(4)
v4
```

### Sequences

An important way of creating vectors is to generate a sequence of numbers. The simplest sequences are in steps of 1, and the colon operator is the simplest way of generating such sequences. All you do is specify the first and last values separated by a colon. Here is a sequence from 0 up to 10:

```{r}
0:10
```
Here is a sequence from 15 down to 5:

```{r}
15:5
```

To generate a sequence in steps other than 1, you use the seq function. There are various forms of this, of which the simplest has three arguments: `from`, `to`, `by` (the initial value, the final value and the increment). If the initial value is smaller than the final value, the increment should be positive, like this:

```{r}
seq(0, 1.5, 0.1)
```

If the initial value is larger than the final value, the increment should be negative, like this:

```{r}
seq(6, 4, -0.2)
```

In many cases, you want to generate a sequence to match an existing vector in length. Rather than having to figure out the increment that will get from the initial to the final value and produce a vector of exactly the appropriate length, R provides the `along` and `length` options. Suppose you have a vector of population sizes:

```{r}
N = c(55,76,92,103,84,88,121,91,65,77,99)
```

You need to plot this against a sequence that starts at 0.04 in steps of 0.01:

```{r}
seq(from=0.04,by=0.01,length=11)
```

But this requires you to figure out the length of `N`. A simpler method is to use the `along` argument and specify the vector, `N`, whose length has to be matched:

```{r}
seq(0.04,by=0.01,along=N)
```

Alternatively, you can get R to work out the increment (0.01 in this example), by specifying the start and the end values (`from` and `to`), and the name of the vector (`N`) whose length has to be matched:

```{r}
seq(from=0.04,to=0.14,along=N)
```

If you want a vector made up of sequences of unequal lengths, then use the sequence function. Suppose that most of the five sequences you want to string together are from 1 to 4, but the second one is 1 to 3 and the last one is 1 to 5, then:

```{r}
sequence(nvec = c(4,3,4,4,4,5), from = 1, by = 1)
```

#### Generating repeats

You will often want to generate repeats of numbers or characters, for which the function is `rep`. The object that is named in the first argument is repeated a number of times as specified in the second argument. At its simplest, we would generate five 9s like this:

```{r}
rep(9,5)
```
You can see the issues involved by a comparison of these three increasingly complicated uses of the `rep` function:

```{r}
rep(1:4, times = 2)
```
In the simplest case, the entire first argument is repeated (i.e. the sequence 1 to 4 appears twice).

```{r}
rep(1:4, each=2)
```
You often want each element of the sequence to be repeated, and this is accomplished with the each argument.

```{r}
rep(1:4, each = 2, times = 3)
```
Finally, you might want each number repeated and the whole series repeated a certain number of times (here three times).

When each element of the series is to be repeated a different number of times, then the second argument must be a vector of the same length as the vector comprising the first argument (length 4 in this example). So if we want one 1, two 2s, three 3s and four 4s we would write:

```{r}
rep(1:4, 1:4)
```

In a more complicated case, there is a different but irregular repeat of each of the elements of the first argument. Suppose that we need four 1s, one 2, four 3s and two 4s. Then we use the concatenation function `c` to create a vector of length 4 `c(4,1,4,2)` which will act as the second argument to the `rep` function:

```{r}
rep(1:4, c(4,1,4,2))
```

Here is the most complex case with character data rather than numbers: each element of the series is repeated an irregular number of times:

```{r}
rep(c("cat", "dog", "gerbil", "goldfish", "rat"), c(2,3,2,1,3))
```

This is the most general, and also the most useful form of the `rep` function.

#### Generating Factor Levels

The function gl (‘generate levels’) is useful when you want to encode long vectors of factor levels. The syntax for the three arguments is: ‘up to’, ‘with repeats of’, ‘to total length’. Here is the simplest case where we want factor levels up to 4 with repeats of 3 repeated only once (i.e. to total length 12):

```{r}
gl(4,3)
```

Here is the function when we want that whole pattern repeated twice:

```{r}
gl(4,3,24)
```

If you want text for the factor levels, rather than numbers, use labels like this:

```{r}
Temp = gl(2, 2, 24, labels = c("Low", "High"))
Soft = gl(3, 8, 24, labels = c("Hard","Medium","Soft"))
M.user = gl(2, 4, 24, labels = c("N", "Y"))
Brand = gl(2, 1, 24, labels = c("X", "M"))
data.frame(Temp,Soft,M.user,Brand)
```

### Vector and Subscripts

You will often want to use some but not all of the contents of a vector. To do this, you need to master the use of subscripts (or indices as they are also known). In R, subscripts involve the use of square brackets `[]`. Our vector called `peas` shows the numbers of peas in six pods:

```{r}
peas = c(4, 7, 6, 5, 6, 7)
```

The first element of `peas` is 4, the second 7, and so on. The elements are indexed left to right, 1 to 6. It could not be more straightforward. If we want to extract the fourth element of peas (which you can see is a 5) then this is what we do:

```{r}
peas[4]
```

If we want to extract several values (say the 2nd, 3rd and 6th) we use a vector to specify the pods we want as subscripts, either in two stages like this:

```{r}
pods = c(2,3,6)
peas[pods]
```
or in a single step, like this:

```{r}
peas[c(2,3,6)]
```

You can drop values from a vector by using negative subscripts. Here are all but the first values of peas:

```{r}
peas[-1]
```

Here are all but the last (note the use of the `length` function to decide what is last):

```{r}
peas[-length(peas)]
```

We can use sequences of numbers to extract values from a vector. Here are the first three values of `peas`:

```{r}
peas[1:3]
```
Here are the even-numbered values of `peas`:

```{r}
peas[seq(2,length(peas), 2)]
```
or alternatively:

```{r}
peas[1:length(peas) %% 2 == 0]
```

Using the modulo function %% on the sequence 1 to 6 to extract the even numbers 2, 4 and 6. Finally, we can assign some value to the elements between some specific indices

```{r}
peas[4:5] = 0
peas
```

#### Classes of vector

The vector called `peas` contained numbers: in the jargon, it is of class numeric. R allows vectors of six types, so long as all of the elements in one vector belong to the same class. The classes are logical, integer, real, complex, string (or character) or raw. You will use numeric, logical and character variables all the time. Engineers and mathematicians will use complex numbers. But you could go a whole career without ever needing to use integer or raw.

#### Naming elements within vectors

It is often useful to have the values in a vector labelled in some way. For instance, if our data are counts of 0, 1, 2, . . . occurrences in a vector called `counts`,

```{r}
counts = c(25,12,7,4,6,2,1,0,2)
```

so that there were 25 zeros, 12 ones and so on, it would be useful to name each of the counts with the relevant number 0 to 8:

```{r}
names(counts) = 0:8
```

Now when we inspect the vector called counts we see both the names and the frequencies:

```{r}
counts
```

Or even access to some element using its name:

```{r}
counts["0"]
```

#### Working with logical subscripts

Take the example of a vector containing the 11 numbers 0 to 10:

```{r}
x = 0:10
```

There are two quite different kinds of things we might want to do with this. We might want to add up the values of the elements:

```{r}
sum(x)
```
Alternatively, we might want to count the elements that passed some logical criterion. Suppose we wanted to know how many of the values were less than 5:

```{r}
sum(x<5)
```

You see the distinction. We use the vector function `sum` in both cases. But `sum(x)` adds up the values of the x's and `sum(x<5)` counts up the number of cases that pass the logical condition ‘x is less than 5’. This works because of coercion. Logical `TRUE` has been coerced to numeric 1 and logical `FALSE` has been coerced to numeric 0.

How do you add up the values of just some of the elements of x? We specify a logical condition, but we do not want to count the number of cases that pass the condition, we want to add up all the values of the cases that pass.

Note that when we counted the number of cases, the counting was applied to the entire vector, using `sum(x<5)`. To find the sum of the values of x that are less than 5, we write:

```{r}
sum(x[x<5])
```

Let us look at this in more detail. The logical condition `x<5` is either true or false:

```{r}
x<5
```
You can imagine false as being numeric 0 and true as being numeric 1. Then the vector of subscripts `[x<5]` is five 1s followed by six 0s:

```{r}
as.numeric(x<5)
```

Now imagine multiplying the values of x by the values of the logical vector

```{r}
x*(x<5)
```

When the function `sum` is applied, it gives us the answer we want: the sum of the values of the numbers 0 + 1 + 2 + 3 + 4 = 10.

```{r}
sum(x*(x<5))
```

This produces the same answer as `sum(x[x<5])`, but is rather less elegant. There are many other ways of indexing elements of a vector using logical operators. We have a vector with values between 0 and 100:

```{r}
v = 0:100
```

We can select all the elements over 30:

```{r}
v[v>30]
```
even, all those over 30 and under or equal 50:

```{r}
v[v > 30 & v <= 50]
```

Finally, we can use a specific set of elements to select those from the vector:

```{r}
v[ v %in% c(10, 20, 30)]
```

### Vector Operations

When arithmetic operations are performed between two vectors, R returns another vector with the results of the element by element operation. Boolean operations are also possible. Most functions and operations are "vectorized".

```{r}
avector = c(1,2,3)
bvector = c(4,5,6)
```

If we sum up the two vectors the result will be a new vector with the sum of the elements with the same index:

```{r}
avector + bvector
```
If the vectors are not the same size, R repeats the smallest of them as many times as necessary.

```{r}
avector + 1
```

Vectors multiplication will follow the same rule, as the multiplication by an scalar:

```{r}
avector * bvector
```
```{r}
avector*2
```

If we want to multiplicate vectors as one-dimensional matrices (dot product) we need to use a different sintax:

```{r}
avector %*% bvector
```
In this case we obtained an scalar because the inner product was computed, but we can transpose one of the vectors to obtain the outer product using the `t()` function:

```{r}
avector %*% t(bvector)
```

### Vector Functions

One of R’s great strengths is its ability to evaluate functions over entire vectors, thereby avoiding the need for loops and subscripts. The most important vector functions are listed in Table 2.4. 

<p align="center">
  <img src="./images/R-programming/table2.4.png" width="1050">
</p> 

Here is a numeric vector:

```{r}
y = c(8,3,5,7,6,6,8,9,2,3,9,4,10,4,11)
```

Some vector functions produce a single number:

```{r}
mean(y)
```

Others produce two numbers:

```{r}
range(y)
```

here showing that the minimum was 2 and the maximum was 11. Other functions produce several numbers:

```{r}
fivenum(y)
```

This is Tukey’s famous five-number summary: the minimum, the lower hinge, the median, the upper hinge and the maximum.

Perhaps the single most useful vector function in R is `table`. You need to see it in action to appreciate just how good it is. Here is a huge vector called `counts` containing 10 000 random integers between 0 and 10 from a uniform distribution

```{r}
counts = sample(1:10, size = 10000, replace = TRUE)
```

Here is a look at the first 30 values in counts:

```{r}
counts[1:30]
```

The question is this: how many zeros are there in the whole vector of 10 000 numbers, how many 1s, and so on right up to the largest value within counts? A formidable task for you or me, but for R it is just:

```{r}
table(counts)
```

#### `tapply` function

One of the most important functions in all of R is tapply. It does not sound like much from the name, but you will use it time and again for calculating means, variances, sample sizes, minima and maxima. With weather data, for instance, we might want the 12 monthly mean temperatures rather than the whole-year average. We have a response variable, temperature, and a categorical explanatory variable, month:

```{r}
temperature = read.csv("./Data/city_temperature.csv")
attach(temperature)
names(temperature)
```

```{r}
tapply(AvgTemperature, Month, mean)
```

It is easy to apply other functions in the same way: here are the monthly variances

```{r}
tapply(AvgTemperature,Month,var)
```

and the monthly max

```{r}
tapply(AvgTemperature,Month,max)
```

If R does not have a built in function to do what you want, then you can easily write your own. Here, for instance, is a function to calculate the standard error of each mean (these are called anonymous functions in R, because they are unnamed):

```{r}
tapply(AvgTemperature, Month,  function(x) sqrt(var(x)/length(x)))
```

The `tapply` function is very flexible. It can produce multi-dimensional tables simply by replacing the one categorical variable (`Month`) by a `list` of categorical variables. Here are the monthly means calculated separately for each year, as specified by `list(Year,Month)`. The variable you name first in the list (`Year`) will appear as the row of the results table and the second will appear as the columns (`Month`):

```{r}
tapply(AvgTemperature,list(Year,Month),mean)[,1:6]
```

The subscripts [,1:6] simply restrict the output to the first six months.

There is just one thing about `tapply` that might confuse you. If you try to apply a function that has built-in protection against missing values, then `tapply` may not do what you want, producing `NA` instead of the numerical answer. This is most likely to happen with the mean function because its default is to produce NA when there are one or more missing values. The remedy is to provide an extra argument to `tapply`, specifying that you want to see the average of the non-missing values. Use `na.rm=TRUE` to remove the missing values like this:

```{r}
tapply(AvgTemperature,Year,mean,na.rm=TRUE)
```

You might want to trim some of the extreme values before calculating the mean (the arithmetic mean is famously sensitive to outliers). The `trim` option allows you to specify the fraction of the data (between 0 and 0.5) that you want to be omitted from the left- and right-hand tails of the sorted vector of values before computing the mean of the central values:

```{r}
tapply(AvgTemperature,Year,mean,trim=0.2)
```

#### `aggregate` function

Suppose that we have two response variables (`y` and `z`) and two explanatory variables (`x` and `w`) that we might want to use to summarize functions like mean or variance of `y` and/or `z`. The `aggregate` function has a formula method which allows elegant summaries of four kinds:

* one to one: `aggregate(y ~ x, mean)`
* one to many: `aggregate(y ~ x + w, mean)`
* many to one: `aggregate(cbind(y,z) ~ x, mean)`
* many to many: `aggregate(cbind(y,z) ~ x + w, mean)`

Here is an example using a dataframe with many categorical and continuous variables:

```{r}
df = read.csv("./Data/bank.csv", sep = ";", stringsAsFactors = TRUE)
head(df)
```

Here is one-to-one use of `aggregate` to find mean the `cons.price.idx` in the different `marital` samples:

```{r}
aggregate(cons.price.idx ~ marital, df, mean)
```

Here is a one-to-many use to look at the interaction between `marital` and `contact`:

```{r}
aggregate(cons.price.idx ~ marital + contact, df, mean)
```

Finally, here is a many-to-many use to find mean `euribor3m` as well as mean `cons.price.idx` for the interaction between `marital` and `contact`:

```{r}
aggregate(cbind(cons.price.idx, euribor3m) ~ marital + contact, df, mean)
```

#### Parallel minima and maxima

Here are three vectors of the same length, `x`, `y` and `z`. The parallel minimum function, `pmin`, finds the minimum from any one of the three variables for each subscript, and produces a vector as its result (of length equal to the longest of `x`, `y`, or `z`):

```{r}
x = runif(6)
x
```

```{r}
y = runif(6)
y
```


```{r}
z = runif(6)
z
```


```{r}
pmin(x,y,z)
```

#### Summary by groups with `tapply`

The vector function `tapply` is one of the most important and useful vector functions to master. The ‘t’ stands for ‘table’ and the idea is to apply a function to produce a table from the values in the vector, based on one or more grouping variables (often the grouping is by factor levels). This sounds much more complicated than it really is:


```{r}
daphnia = read.table("./Data/daphnia.txt", header = TRUE)
attach(daphnia)
names(daphnia)
```
The response variable is `Growth.rate` and the other three variables are factors. Suppose we want the mean growth rate for each detergent:

```{r}
tapply(Growth.rate, Detergent, mean)
```
This produces a table with four entries, one for each level of the factor called `Detergent`.

To produce a two-dimensional table we put the two grouping variables in a list. Here we calculate the median growth rate for water type and daphnia clone:

```{r}
tapply(Growth.rate,list(Water,Daphnia),median)
```
The first variable in the list creates the rows of the table and the second the columns.

#### Addresses within vectors

There is an important function called `which` for finding addresses within vectors. The vector y looks like this:

```{r}
y = c(8,3,5,7,6,6,8,9,2,3,9,4,10,4,11)
```

Suppose we wanted to know which elements of `y` contained values bigger than 5. We type:

```{r}
which(y>5)
```
Notice that the answer to this enquiry is a set of subscripts. We do not use subscripts inside the `which` function itself. The function is applied to the whole array. To see the values of y that are larger than 5, we just type:

```{r}
y[y>5]
```

#### Finding closest values

Finding the value in a vector that is closest to a specified value is straightforward using which. The vector `x` contains 1000 random numbers from a normal distribution with mean = 100 and standard deviation = 10:

```{r}
set.seed(2020)
x = rnorm(1000, 100, 10)
```

Here, we want to find the value of `x` that is closest to 108.0. The logic is to work out the difference between 108 and each of the 1000 random numbers, then find which of these differences is the smallest. This is what the R code looks like:

```{r}
which(abs(x-108) == min(abs(x-108)))
```

The closest value to 108.0 is in location 626 within `x`. But just how close to 108.0 is this 626 value? We use 626 as a subscript on `x` to find this out:

```{r}
x[626]
```

#### Sorting, Ranking and Ordering

These three related concepts are important, and one of them (order) is difficult to understand at the beginning. Let us take a simple example:

```{r}
set.seed(2020)
houses_prices = runif(10, 150, 500)
houses_prices
```

We apply the three different functions to the vector called `houses_price`:

```{r}
ranks = rank(houses_prices)
ranks
```
```{r}
sorted = sort(houses_prices)
sorted
```

```{r}
ordered = order(houses_prices)
ordered
```

Let's create a data frame to observe the data easily:

```{r}
view = data.frame(houses_prices, ranks, sorted, ordered)
view
```

**RANK**: The prices themselves are in no particular sequence. The `ranks` column contains the value that is the rank of the particular data point (value of `Price`), where 1 is assigned to the lowest data point and `length(Price)` – here 10 – is assigned to the highest data point.

**SORT**: The sorted vector is very straightforward. It contains the values of `Price` sorted into ascending order. If you want to sort into descending order, use the reverse order function `rev` like this:

```{r}
rev(sort(houses_prices))
```

**ORDER**: This is the most important of the three functions, and the hardest to understand. The numbers in this column are subscripts between 1 and 10. The order function returns an integer vector containing the permutation that will sort the input into ascending order.

Using `order` with subscripts is a much safer option than using `sort`, because with `sort` the values of the response variable and the explanatory variables could be uncoupled with potentially disastrous results if this is not realized at the time that modelling was carried out.

Imagine we have another variable that is the location of the house represented by a letter:

```{r}
set.seed(2020)
location = sample(LETTERS, 10)
location
```

We can use the `order` function to organize the location of the houses like this:

```{r}
location[order(houses_prices)]
```

#### `unique` and `duplicated` functions

The difference is best seen with a simple example. Here is a vector of names:

```{r}
names = c("Williams","Jones","Smith","Williams","Jones","Williams")
```

We can see how many times each name appears using table:We can see how many times each name appears using `table`:

```{r}
table(names)
```
It is clear that the vector contains just three different names. The function called `unique` extracts these three unique names, creating a vector of length 3, unsorted, in the order in which the names are encountered in the vector:

```{r}
unique(names)
```

In contrast, the function called `duplicated` produces a vector, of the same length as the vector of names, containing the logical values either `FALSE` or `TRUE`, depending upon whether or not that name has appeared already (reading from the left). You need to see this in action to understand what is happening, and why it might be useful:

```{r}
duplicated(names)
```
The first three names are not duplicated (`FALSE`), but the last three are all duplicated (`TRUE`). We can mimic the `unique` function by using this vector as subscripts like this:

```{r}
names[!duplicated(names)]
```
There you have it: if you want a shortened vector, containing only the unique values in names, then use `unique`, but if you want a vector of the same length as names then use `duplicated`.

### Sets

There are three essential functions for manipulating sets. The principles are easy to see if we work with an example of two sets:

```{r}
setA = c("a", "b", "c", "d", "e")
setB = c("d", "e", "f", "g")
```

The **union** of two sets is everything in the two sets taken together, but counting elements only once that are common to both sets:

```{r}
union(setA, setB)
```

The **intersection** of two sets is the material that they have in common:

```{r}
intersect(setA, setB)
```
Note, however, that the **difference** between two sets is order-dependent. It is the material that is in the first named set, that is not in the second named set. Thus `setdiff(A,B)` gives a different answer than `setdiff(B,A)`. For our example:

```{r}
setdiff(setA, setB)
```

```{r}
setdiff(setB, setA)
```

There is also a built-in function `setequal` for testing if two sets are equal:

```{r}
setequal(setA, setB)
```

You can use `%in%` for comparing sets. The result is a logical vector whose length matches the vector on the left:

```{r}
setA %in% setB
```
```{r}
setB %in% setA
```

### Factors

Conceptually, factors are variables in R which take on a limited number of different values; such variables are often refered to as categorical variables. One of the most important uses of factors is in statistical modeling; since categorical variables enter into statistical models differently than continuous variables, storing data as factors ensures that the modeling functions will treat such data correctly.

Factors in R are stored as a vector of integer values with a corresponding set of character values to use when the factor is displayed. The `factor` function is used to create a factor. The only required argument to `factor` is a vector of values which will be returned as a vector of factor values. Both numeric and character variables can be made into factors, but the factor levels will always be character values. You can see the possible levels for a factor through the `levels` command.

To change the order in which the levels will be displayed from their default sorted order, the `levels=` argument can be given a vector of all the possible values of the variable in the order you desire. If the ordering should also be used when performing comparisons, use the optional `ordered=TRUE` argument. In this case, the factor is known as an ordered factor.

*Reminder:*

+ **Categorical variable**: one that can take a limited number of possible values (categories). Examples of categorical variables: gender of a person, nationality...
    
    + Categorical nominal variable: one that does not have a pre-established order.
    + Categorical ordinal variable: that which has an established order.

+ **Continuous variable**: one that can take an infinite number of possible values. Examples of continuous variables: weight of a person, height of a person...

The different values that the variable can take are called levels, **factor levels**.

Why use factors?

+ They allow to establish a different order than the alphabetical one.
+ Many R models/packages use them

Factors are categorical variables that have a fixed number of levels. A simple example of a factor might be a variable called gender with two levels: ‘female’ and ‘male’. If you had three females and two males, you could create the factor like this:

```{r}
gender = factor(c("female", "male", "female", "male", "female"))
class(gender)
```

```{r}
mode(gender)
```

More often, you will create a dataframe by reading your data from a file using read.table. When we did this in the previous version of R (R3), the strings in our data table were automatically converted into factors. This was useful as long as our data table was well structured and clean, but it could cause problems in some cases. Let's see an example of a well-structured data table:

```{r}
data = read.table(file = "./Data/GenderPurchase.csv", header = TRUE, sep = ",")
is.factor(data$Gender)
```

As we can see, in this version of R (R4), the strings are coded as default character type. We can solve this by adding a parameter to our command as seen below:

```{r}
data = read.table(file = "./Data/GenderPurchase.csv", header = TRUE, sep = ",", stringsAsFactors = TRUE)
is.factor(data$Gender)
```

Let's see what happens with a data table that is not well structured in case of reading the strings as factors:

```{r}
data = read.table(file = "./Data/titanic3.csv", header = TRUE, sep = ",", stringsAsFactors = TRUE)
str(data)
```

We can find ourselves with variables that are completely useless and very difficult to manage, with as many levels of the factors as cases we have in the data table. 

In these cases it is much more comfortable to read the strings as characters and work on those variables to extract useful information from them as we will see later.

We will use the daphnia dataset to perform some examples with factors:

```{r}
daphnia = read.table("./Data/daphnia.txt", header = TRUE, stringsAsFactors = TRUE)
attach(daphnia)
```

There are some important functions for dealing with factors. You will often want to check that a variable is a factor (especially if the factor levels are numbers rather than characters):

```{r}
is.factor(Water)
```

To discover the names of the factor levels, we use the levels function:

```{r}
levels(Detergent)
```

To discover the number of levels of a factor, we use the nlevels function:

```{r}
nlevels(Detergent)
```

The same result is achieved by applying the length function to the levels of a factor:

```{r}
length(levels(Detergent))
```

By default, factor levels are treated in alphabetical order. If you want to change this (as you might, for instance, in ordering the bars of a bar chart) then this is straightforward: just type the factor levels in the order that you want them to be used, and provide this vector as the second argument to the factor function. 

Suppose we have an experiment with three factor levels in a variable called treatment, and we want them to appear in this order: ‘nothing’, ‘single’ dose and ‘double’ dose. We shall need to override R’s natural tendency to order them ‘double’, ‘nothing’, ‘single’:

```{r}
set.seed(2020)
treatment = as.factor(sample(c("double", "nothing", "single"), 100, replace = TRUE))
response = sample(c(0,1), 100, replace = TRUE)
tapply(response, treatment, mean)
```

This is achieved using the factor function like this:

```{r}
treatment = factor(treatment,levels=c("nothing","single","double"))
```

Now we get the order we want:

```{r}
tapply(response,treatment,mean)
```

Only == and != can be used for factors. Note, also, that a factor can only be compared to another factor with
an identical set of levels (not necessarily in the same ordering) or to a character vector. For example, you
cannot ask quantitative questions about factor levels, like > or <=, even if these levels are numeric.

To turn factor levels into numbers (integers) use the unclass function like this:

```{r}
as.vector(unclass(treatment))
```

### Matrices and Arrays

An array is a multi-dimensional object. The dimensions of an array are specified by its `dim` attribute, which gives the maximal indices in each dimension. So for a three-dimensional array consisting of 24 numbers in a sequence 1:24, with dimensions 2 × 4 × 3, we write:

```{r}
y = 1:24
dim(y) = c(2,4,3)
y
```

This produces three two-dimensional tables, because the third dimension is 3. This is what happens when you change the dimensions:

```{r}
dim(y) = c(3,2,4)
y
```

Now we have four two-dimensional tables, each of three rows and two columns.

A matrix is a two-dimensional array containing numbers. A dataframe is a two-dimensional list containing (potentially a mix of) numbers, text or logical variables in different columns. 

When there are two subscripts [5,3] to an object like a matrix or a dataframe, the first subscript refers to the row number (5 in this example; the rows are defined as margin number 1) and the second subscript refers to the column number (3 in this example; the columns are margin number 2). 

There is an important and powerful convention in R, such that when a subscript appears as a blank it is understood to mean ‘all of’. Thus:

+ [,4] means all rows in column 4 of an object;
+ [2,] means all columns in row 2 of an object.

### Matrices

There are several ways of making a matrix. You can create one directly like this:

```{r}
X = matrix(c(1,0,0,0,1,0,0,0,1),nrow=3)
X
```
where, by default, the numbers are entered column-wise.

The class and attributes of `X` indicate that it is a matrix of three rows and three columns (these are its `dim` attributes):

```{r}
class(X)
```
```{r}
attributes(X)
```

In the next example, the data in the vector appear row-wise, so we indicate this with `byrow=T`:

```{r}
vector = c(1,2,3,4,4,3,2,1)
V = matrix(vector,byrow=T,nrow=2)
V
```

Another way to convert a vector into a matrix is by providing the vector object with two dimensions (rows and columns) using the dim function like this:

```{r}
dim(vector) = c(4,2)
is.matrix(vector)
```

We need to be careful, however, because we have made no allowance at this stage for the fact that the data were entered row-wise into vector:

```{r}
vector
```

The matrix we want is the transpose, `t`, of this matrix:

```{r}
t(vector)
```

#### Naming the rows and columns of matrices

At first, matrices have numbers naming their rows and columns (see above). Here is a 4 × 5 matrix of random integers from a Poisson distribution with mean 1.5:

```{r}
X = matrix(rpois(20,1.5),nrow=4)
X
```

Suppose that the rows refer to four different trials and we want to label the rows ‘Trial.1’ etc. We employ the function `rownames` to do this. We could use the `paste` function but here we take advantage of the `prefix` option:

```{r}
rownames(X) = rownames(X,do.NULL=FALSE,prefix="Trial.")
X
```

For the columns we want to supply a vector of different names for the five drugs involved in the trial, and use this to specify the `colnames(X)`:

```{r}
drug.names = c("aspirin", "paracetamol", "nurofen", "hedex", "placebo")
colnames(X) = drug.names
X
```

#### Matrices Functions

Using R, we can operate with matrices easily, since by default this type of data structures are designed for matrix algebra.

Let's create a matrix to see some examples:

```{r}
M1 = matrix(1:9, byrow = T, nrow = 3)
M1
```
 
We can know the size of the matrix using the `dim` function:

```{r}
dim(M1)
```

We can also create diagonal matrices using the `diag` function:

```{r}
diag(5)
```

Or even create a diagonal matrix using a defined vector:

```{r}
diag(c(1,2,3))
```

We can calculate a matrix transpose:

```{r}
t(M1)
```

And the trace of a matrix easily:

```{r}
sum(diag(M1))
```

To calculate the determinant we just need to use the `det` function:

```{r}
det(M1)
```

In case the determinant is not 0 we can calculate the inverse of that matrix using the `solve` function. Let's see what happens in this case:

```{r}
#solve(M1)
```

```
Error in solve.default(M1) : system is computationally singular: reciprocal condition number = 2.59052e-18
```

We can create a random matrix to check this function:

```{r}
set.seed(2020)
M2 = matrix(sample(1:100, size = 9), byrow = T, nrow = 3)
det(M2)
```

And now apply the `solve` function:

```{r}
solve(M2)
```

Finally, we can perform a matrix decomposition using the `eigen` function in R, obtaining the eigenvectors and the eigenvalues of that decomposition,

```{r}
eigen(M1)
```

or even a Singular Value Decomposition using the `svd` function:

```{r}
s = svd(M1)
s
```

We can check that R makes a successful decomposition:

```{r}
s$u %*% diag(s$d) %*% t(s$v)
```

#### Matrices Operations

We can perform arithmetic operations with matrices (additions, subtractions, multiplications...) in a similar way as we have done with vectors.

```{r}
M1 = matrix(1:9, byrow = TRUE, nrow = 3)
M2 = matrix(11:19, byrow = TRUE, nrow = 3)

M3 = M1 + M2
M3
```

```{r}
M1 + 2
```

In the case of matrices multiplication we must remember that two matrices can be multiplied only when the number of columns in the first equals the number of rows in the second


```{r}
M1 = matrix(1:6, byrow = TRUE, nrow = 3, ncol = 2)
M1
```

```{r}
M2 = matrix(10:15, byrow = TRUE, nrow = 2, ncol = 3)
M2
```


```{r}
M3 = M1 %*% M2
M3
```

```{r}
M4 = M2 %*% M1
M4
```

We can also apply some other R built-in functions to a matrix. For example: 

+ `rowSums` will sum up all the elements for each row
+ `colSums` will do the same by columns
+ `rowMeans` will calculate the mean of each row (is the same for columns with `colMeans`)
+ `summary` will show some statistics about the matrix by columns

```{r}
summary(M4)
```

#### Matrices Manipulation

To add columns to a matrix you use the function `cbind(m1, m2, ...)`, which joins matrices and/or vectors per column.

```{r}
M5 = cbind(M1, M3)
M5
```

We can add just a new column:

```{r}
M5 = cbind(M5, c(1,2,3))
M5
```

To add rows to a matrix you use the `rbind(m1, m2, ...)` function, which joins arrays and/or vectors per row.

```{r}
M5 = rbind(M2, M3)
M5
```

And we can add an extra row using the same function:

```{r}
M5 = rbind(M5, c(1,2,3))
M5
```

#### Indexing Matrices

As with vectors, we will use the square brackets `[ ]` to index matrices. In the particular case of matrices we will use two integers: one for the row and one for the column `[row, column]`.

To select all the elements of a row or a column, it is enough not to include any number before or after the comma, respectively. For example: `matrix[row, ]`; `matrix[, col]`.

```{r}
M1 = matrix(1:9, byrow = T, nrow = 3)
M1
```

Let's see some examples:

```{r}
# We select the first two rows
M1[1:2,]
```
```{r}
# We select the last column
M1[, ncol(M1)]
```

As we did with vectors, we can use vectors to perform selections inside a matrix,

```{r}
# Select the first and last columns
M1[, c(1,ncol(M1))]
```

and assign values to a specific position

```{r}
M1[1,1] = 0
M1
```

Finally, we can use logical expressions to select elements inside a matrix:

```{r}
M1[M1 < 4]
```
```{r}
M1[M1 > 3 & M1 < 8]
```

### Lists

Lists are extremely important objects in R. You will have heard of the problems of ‘comparing apples and oranges’ or how two things are ‘as different as chalk and cheese’. You can think of lists as a way of getting around these problems. Here are four completely different objects: a numeric vector, a logical vector, a vector of character strings and a vector of complex numbers:

```{r}
apples = c(4,4.5,4.2,5.1,3.9)
oranges = c(TRUE, TRUE, FALSE)
chalk = c("limestone", "marl","oolite", "CaC03")
cheese = c(3.2-4.5i,12.8+2.2i)
```

We cannot bundle them together into a dataframe, because the vectors are of different lengths. However, despite their differences, however, we can bundle them together in a single list called items:

```{r}
items = list(apples,oranges,chalk,cheese)
items
```

Subscripts on vectors, matrices, arrays and dataframes have one set of square brackets [6], [3,4] or [2,3,2,1], but subscripts on lists have double square brackets [[2]] or [[i,j]]. If we want to extract the chalk from the list, we use subscript [[3]]:

```{r}
items[[3]]
```

If we want to extract the third element within chalk (oolite) then we use single subscripts after the double subscripts like this:

```{r}
items[[3]][3]
```

There is another indexing convention in R which is used to extract named components from lists using the element names operator $. This is known as ‘indexing tagged lists’. For this to work, the elements of the list must have names. At the moment our list called `items` has no names:

```{r}
names(items)
```

You can give names to the elements of a list in the function that creates the list by using the equals sign like this:

```{r}
items = list(first=apples,second=oranges,third=chalk,fourth=cheese)
```

Now you can extract elements of the list by name

```{r}
items$fourth
```

#### `lapply` function

We can ask a variety of questions about our new list object:

```{r}
class(items)
```
```{r}
is.numeric(items)
```

```{r}
is.list(items)
```

```{r}
length(items)
```

Note that the length of a list is the number of items in the list, not the lengths of the individual vectors within the list.

The function lapply applies a specified function to each of the elements of a list in turn (without the need for specifying a loop, and not requiring us to know how many elements there are in the list). A useful function to apply to lists is the length function; this asks how many elements comprise each component of the list. Technically we want to know the length of each of the vectors making up the list:

```{r}
lapply(items, length)
```

This shows that items consists of four vectors, and shows that there were 5 elements in the first vector, 3 in the second 4 in the third and 2 in the fourth. But 5 of what, and 3 of what? To find out, we apply the function class to the list:

```{r}
lapply(items, class)
```

So the answer is there were 5 numbers in the first vector, 3 logical variables in the second, 4 character strings in the third vector and 2 complex numbers in the fourth.

Applying numeric functions to lists will only work for objects of class `numeric` or `complex`, or objects (like logical values) that can be coerced into numbers. Here is what happens when we use `lapply` to apply the function `mean` to `items`:

```{r}
lapply(items, mean)
```

Finally, the most useful overview of the contents of a list is obtained with str, the structure function:

```{r}
str(items)
```














### Vectors 

In all previous examples the variables included one element only. More generally we can define sequences of elements or so-called *vectors*. They can be defined with the command `c`, which stands for combine. 
```{r}
vec <- c(1,3,5,7)
vec
```

So `vec` includes the sequence of numbers 1, 3, 5, 7. Notice that a vector can only include one data type. Consider the following:

```{r}
vec <- c(1, "hello", TRUE)
vec
```

We created a variable `vec` where the first entry is a number, then a character string, then a Boolean. When we print `vec`, we get that its elements are `"1"`, `"hello"` and `"TRUE"`: it has transformed the number `1` into the string `"1"` and the Boolean `TRUE` into `"TRUE"`.

### Matrices

Matrices are tables of elements that are organized in rows and columns. You can think of them as an arrangement of vectors into a table. Matrices must have the same data type in all its entries, as for vectors. Matrices can be constructed in multiple ways. One way is by stacking vectors into a matrix row-by-row with the command `rbind`. Consider the following example.
```{r}
row1 <- c(1,2,3)
row2 <- c(4,5,6)
row3 <- c(7,8,9)
mat <- rbind(row1,row2,row3)
mat
```

So first we created vectors `row1 = (1,2,3)`, `row2 = (4,5,6)` and `row3 = (7,8,9)` and then organizing them together into the matrix `mat`. 

The following code follows the same procedure but now organizes vectors by columns instead using the command `cbind`.
```{r}
col1 <- c(1,2,3)
col2 <- c(4,5,6)
col3 <- c(7,8,9)
mat <- cbind(col1,col2,col3)
mat
```

Last, there is also a command called `matrix` to create a matrix. It takes a vector, defined using the command `c` and stores its entries into a matrix of `nrow` rows and `ncol` columns. Consider the following example.

```{r}
vec <- c(1,2,3,4,5,6,7,8,9)
mat <- matrix(vec, nrow = 3, ncol = 3)
mat
```

So first we created a vector `vec` with numbers from 1 to 9 and then stored them in a matrix with 3 rows and 3 columns. Number are stored by column: the first element of `vec` is in entry (1,1), the second element of `vec` is in entry (2,1), and so on.

### Dataframes

Dataframes are very similar as matrices, they are tables organized in rows and columns. However, different to matrices they can have columns with different data types. They can be created with the command `data.frame`.

```{r}
data <- data.frame(X1 = c(1,2,3), X2 = c(TRUE,FALSE,FALSE),
                   X3 = c("male","male","female"))
data
```

The dataframe `data` includes three columns: the first column `X1` of numbers, the second column `X2` of Boolean and the third column `X3` of characters. Dataframes are the objects that are most commonly used in real world data analysis.

### `NULL` and `NA`

The expression `NA` is used in R to denote a missing value. Consider the following example.

```{r}
vec <- c(3, NA, 5)
vec
```
Although the second element of `vec` is the expression `NA`, R recognizes that it is used for missing value and therefore the elements 3 and 5 are still considered numbers: indeed they are not printed as `"3"` and `"5"`.

`NULL` is an additional datatype. This can have various uses. For instance, it is associated to a vector with no entries.

```{r}
c()
```

## Accessing and manipulating variables 

Now that we have described the main objects we will work with in R, we can discuss how to access specific information.

### Accessing a single element

Given a vector `vec` we can access its i-th entry with `vec[i]`.

```{r}
vec <- c(1,3,5)
vec[2]
```

For a matrix or a dataframe we need to specify the associated row and column. If we have a matrix `mat` we can access the element in entry (i,j) with `mat[i,j]`.

```{r}
mat <- matrix(c(1,2,3,4,5,6,7,8,9), ncol=3, nrow =3)
mat[1,3]
```



### Acessing multiple entries

To access multiple entries we can on the other hand define a vector of indexes of the elements we want to access. Consider the following examples:

```{r}
vec <- c(1,3,5)
vec[c(1,2)]
```

The above code accesses the first two entries of the vector `vec`. To do this we had to define a vector using `c(1,2)` stating the entries we wanted to look at. For matrices consider:

```{r}
mat <- matrix(c(1,2,3,4,5,6,7,8,9), ncol=3, nrow =3)
mat[c(1,2),c(2,3)]
```

The syntax is very similar as before. We defined to index vectors, one for the rows and one for columns. The two statements `c(1,2)` and `c(2,3)` are separated by a comma to denote that the first selects the first and second row, whilst the second selects the second and third column.

If one wants to access full rows or full columns, the argument associated to rows or columns is left blank. Consider the following examples.

```{r}
mat <- matrix(c(1,2,3,4,5,6,7,8,9), ncol=3, nrow =3)
mat[1,]
mat[,c(1,2)]
```

The code `mat[1,]` selects the first full row of `mat`. The code `mat[,c(1,2)]` selects the first and second column of `mat`. Notice that the comma has always to be included!

To access multiple entries it is often useful to define sequences of number quickly. The following command defines the sequence of integer numbers from 1 to 9.

```{r}
1:9
```

More generally, one can define sequences of numbers using `seq` (see `?seq`).

### Accessing entries with logical operators

If we want to access elements of an object based on a condition it is often easier to use logical operators. This means comparing entries using the comparisons you would usually use in mathematical reasoning, for instance being equal to, or being larger to. The syntax is as follows:

 - `==` to check equality (notice the two equal signs)
 
 - `!=` to check non-equality

 - `>` bigger to 
  
 - `>=` bigger or equal to
 
 - `<` less to
 
 - `<=` less or equal to
 
Let's see some examples.

```{r}
vec <- c(2,3,4,5,6)
vec > 4
```

We constructed a vector `vec` and check which entries were larger than 4. The output is a Boolean vector with the same number of entries as `vec` where only the last two entries are `TRUE`. Similarly,

```{r}
vec <- c(2,3,4,5,6)
vec == 4
```

has a `TRUE` in the third entry only.

So if we were to be interested in returning the elements of `vec` that are larger than 4 we could use the code

```{r}
vec <- c(2,3,4,5,6)
vec[vec > 4]
```

So we have a vector with only elements 5 and 6.

### Manipulating dataframes

We have seen in the previous section that dataframes are special types of matrices where columns can include a different data type. For this reason they have special way to manipulate and access their entries.

First, specific columns of a dataframe can be accessed using its name and the `$` sign as follows.

```{r}
data <- data.frame(X1 = c(1,2,3), X2 = c(TRUE,FALSE,FALSE),
                   X3 = c("male","male","female"))
data$X1
data$X3
```
So using the name of the dataframe `data` followed by `$` and then the name of the column, for instance `X1`, we access that specific column of the dataframe.

Second, we can use the `$` sign to add new columns to a dataframe. Consider the following code.

```{r}
data <- data.frame(X1 = c(1,2,3), X2 = c(TRUE,FALSE,FALSE),
                   X3 = c("male","male","female"))
data$X4 <- c("yes","no","no")
data
```

`data` now includes a fourth column called `X4` coinciding to the vector `c("yes","no","no")`.

Third, we can select specific rows of a dataframe using the command `subset`. Consider the following example.

```{r}
data <- data.frame(X1 = c(1,2,3), X2 = c(TRUE,FALSE,FALSE),
                   X3 = c("male","male","female"))
subset(data, X1 <= 2)
```

The above code returns the rows of `data` such that `X1` is less or equal to 2. More complex rules to subset a dataframe can be combined using the and operator `&` and the or operator `|`. Let's see an example.

```{r}
data <- data.frame(X1 = c(1,2,3), X2 = c(TRUE,FALSE,FALSE),
                   X3 = c("male","male","female"))
subset(data, X1 <= 2 & X2 == TRUE)
```

So the above code selects the rows such that `X1` is less or equal to 2 and `X2` is `TRUE`. This is the case only for the first row of `data`.

### Information about objects

Here is a list of functions which are often useful to get information about objects in R.

 - `length` returns the number of entries in a vector.
 
 - `dim` returns the number of rows and columns of a matrix or a dataframe
 
 - `unique` returns the unique elements of a vector or the unique rows of a matrix or a dataframe.
 
 - `head` returns the first entries of a vector or the first rows of a matrix or a dataframe
 
 - `order` returns a re-ordering of a vector or a data.frame in ascending order.
 
Let's see some examples.

```{r}
vec <- c(4,2,7,5,5)
length(vec)
unique(vec)
order(vec)
```

`length` gives the number of elements of `vec`, `unique` returns the different values in `vec` (so 5 is not repeated), `order` returns in entry i the ordering of the i-th entry of `vec`. So the first entry of `order(vec)`  is 2 since 4 is the second-smallest entry of `vec`.

```{r}
data <- data.frame(X1 = c(1,2,3,4), X2 = c(TRUE,FALSE,FALSE,FALSE),
                   X3 = c("male","male","female","female"))
dim(data)
```

So `dim` tells us that `data` has four rows and three columns.


## Loops and conditions

This section reviews two of the most basic elements of any programming language: `if` statements and `cycles` or `loops`. 

### `if` statements

The basic form of an `if` statement in R is as follows:

```{r, eval = FALSE}
if(condition){true_action}
```

Condition must return a Boolean, either `TRUE` or `FALSE`. If `TRUE` then the code follows the code within the curly brackets and performs the `true_action`. If `condition` is `FALSE` the code does nothing. 

It is more customary to also give a chunk of code for the case `condition`  is `FALSE`. This can be achieved with `else`.

```{r, eval = FALSE}
if(condition){true_action} else {false_action}
```

Let's see an example.

```{r}
a <- 5
if (a < 2){"hello"} else {"goodbye"}
```

The variable `a` is assigned the number 5. Then we impose a condition: if `a` is less than 2, we print the text `"hello"`, otherwise `"goodbye"` is printed. Since `a <- 5` the code prints correctly `"goodbye"`. On the other hand if `a` were assigned `1`.


```{r}
a <- 1
if (a < 2){"hello"} else {"goodbye"}
```

### `ifelse`

`if` works when checking a single element and the condition returns either `TRUE` or `FALSE`. The command `ifelse` can be used to quickly check a condition over all elements of a vector. Consider the following example.

```{r}
vec <- c(1, 3, 5, 7, 9)
ifelse(vec > 5, "bigger", "smaller")
```

`vec` contains the values 1, 3, 5, 7, 9 and the `condition` is if an elemenent of `vec` is larger than 5. If `TRUE` the code returns the string `bigger` and otherwise returns `smaller`. The code above returns therefore a vector of the same length of `vec` including either the string `bigger` or the string `smaller`.

### Loops

`for` loops are used to iterate over items in a vector. They have the following skeleton:

```{r, eval = FALSE}
for(item in vector) {perform_action}
```

For each `item` in `vector`, `perform_action` is performed once and the value of `item` is updated each time.

Here is an example.

```{r}
for (i in c(1,2,3)){
  print(i)
}
```

Item is the variable `i` (it is costumary to use just a letter) and at each step `i` is set equal to a value in the vector `c(1,2,3)`. At each of these iterations, the command `print(i)`, which simply returns the value that `i` takes is called. Indeed we see that the output is the sequence of numbers 1, 2, 3. 

## Functions

Functions are chunks of code that are given a name so that they can be easily used multiple times. Perhaps without realising it, you have used functions already many times!

### Defining your own function

A function is composed of the following elements:

 - a name: in R functions are objects just like vectors or matrices and they are given a name.
 
 - arguments: these are objects that will be used within the function.
 
 - body: a chunk of code which is run within the function.
 
 - output: an object that the function returns.


Let's consider an example.

```{r}
my.function <- function(x,y){
  z <- x + y
  return(z)
}
```

The above function computes the sum of two numbers `x` and `y`. Let's call it.

```{r}
my.function(2,3)
```

The sum between 2 and 3 is indeed 5.

Let's look at the code line by line. In the first line, we assigned a function using the command `function` to an object called `my.function`. `my.function` has two arguments called `x` and `y`.  Then there is an opening curly bracket `{`. The last line of code has a closing curly bracket `}`: whatever is in between the two brackets is a chunk of code which is run when the function is run. The second line computes a new variable called `z` which stores the sum of `x` and `y`. The third line of code tells us that the function should return `z` as output.

Let's consider a slightly more complicated function.

```{r}
new.function <- function(x,y){
  z1 <- x^2
  z2 <- z1 + y
  return(z2)
}
```

The `new.function` returns the sum between the square of the first input `x` and the second input `y`. Let's call the function.

```{r}
new.function(2,3)
new.function(3,2)
```

Notice that `new.function(2,3)` is different from `new.function(3,2)`: indeed in the fist case the sum between 2^2 and 3 is computed, whilst in the second the sum between 3^2 and 2 is computed. Furthermore, that the variable `z1` exists only within the function: when you call the function the output does not create a variable `z1`. The output does not create either a variable `z2` it simply returns the value that is stored in `z2`, which can the be assigned as in the following example.

```{r}
value <- new.function(2,3)
value
```

We stored in `value` the output of `new.function(2,3)`.

An equivalent way to write `new.function` is as follows:

```{r}
new.function <- function(x,y){
  x^2 + y
}
new.function(2,3)
```

The output is the same. We did not create any variable within the function and we did not explicitly use the `return` command. R understands that the last line of code is what the function should return.


### Calling functions

In R functions can be called in various ways. Before we have seen function calls as

```{r, eval = FALSE}
new.function(2,3)
```

How did it work?

 - The function `new.function` has a first argument `x` and a second argument `y`.
 
 - R matched the first argument in `new.function(2,3)` to `x`, that is `x=2`, and the second argument to `y`, that is `y=3`.
 
We could have also been more explicit and state what `x` and `y` were.

```{r}
new.function(x=2, y=3)
```

So now explicitly we state that the input `x` of `new.function` is 2 and that the input `y` is 3. Notice that the two ways of specifying inputs give the exact same results.


### Mathematical and statistical functions

The number of functions available in R is massive and it would be impossible to mention them all. Here I just give you a list of mathematical and statistical functions that we may use in the following.

 - `exp` computes the exponential of the entries of an object
 
 - `log` computes the logarithm of the entries of an object 
 
 - `sqrt` computes the square root of the entries of an
 
 - `sum` computes the sum of the entries of an object
 
 - `abs` computes the absolute value of the entries of an object
 
 - `mean` computes the mean of the entries of an object
 
 - `sd` computes the standard deviation of the entries of an object
 
 - `var` computes the variance of the entries of an object


## The `apply` family of functions

One of the biggest limitation of R is that it is slow in performing cycles. For this reason, one should aim at avoiding as much as possible to use of loops.

There are various functions which are designed to help you in avoiding these loops and they are in the family of so called `apply` functions. There are many of these but we will only see two here.

### The function `apply`

Consider the following code.

```{r}
x <- matrix(c(1:9), ncol=3 , nrow = 3)
y <- c()
for (i in 1:3){
  y[i] <- sum(x[i,])
}
y
```

The code first defines a matrix `x` and an empty vector `y` (recall that this is bad practice, but for this example it does not matter). Then there is a `for` cycle which assigns to the i-th entry of `y` the sum of the entries of the i-th row of `x`. So the vector `y` includes the row-totals.

For this simple example the `for` cycle is extremely quick, but this is just to illustrate how we can replace it using the `apply` function.

```{r}
apply(x, 1, sum)
```

Let's look at the above code. The first input of `apply` is the object we want to operate upon, in this case the matrix `x`. The second input specifies if the operation has to act over the rows of the matrix (input equal to 1) or over the columns (input equal to 2). The third input is the operation we want to use, in this case `sum`. 

Beside being faster, the above code is also a lot more compact than using a for loop. 

The following example computes the mean of each column of `x`.

```{r}
apply(x, 2, mean)
```

### The function `sapply`

Consider again our function `new.function` which computes the sum of the squared of a number `x` with another number `y`.

```{r}
new.function <- function(x,y){ x^2 + y}
```

Suppose that we want to compute such a sum for all numbers `x` from 1 to 10. Suppose that `y` is chosen as 2. We can achieve this with a `for` cycle as follows.

```{r}
x <- 1:10
z <- c()
for (i in 1:10){
  z[i] <- new.function(x[i],2)
}
z
```

The function `sapply` can be used for this specific purpose.

```{r}
x <- 1:10
sapply(x,new.function, y=2)
```

The first argument of `sapply` is a vector of values we want to use as input of a function. The second argument is the function we want to apply multiple times. If the function has more than one input we can then specify what their value is, in this specific case `y=2`. 

Notice that a function can also be defined within `sapply`.

```{r}
x <- 1:10
sapply(x, function(i) i^2 + 2)
```

So we defined the vector `x` and we want to apply the function defined within `sapply` multiple times: once for each entry in the vector `x`.


## The pipe operator

In practice we often have to call functions in a sequence. Suppose for example you have a vector of numbers. Of those numbers you would like to first compute the absolute value. Then you would like to compute the logarithm of those absolute values. Last you would like to compute the mean of those numbers. In standard R we can write this as

```{r}
x <- -5:-1
mean(log(abs(x)))
```

Such nested code where we apply multiple functions over the same line of code becomes cluttered and difficult to read. 

For this reason the package `magrittr` introduces the so-called pipe operator `%>%` which makes the above code much more readable. Consider the same example using the pipe operator.

```{r warning = FALSE}
library(magrittr)
x <- -5:-1
x %>% abs() %>% log() %>% mean()
```

The above code can be seen as follows: consider the vector `x` and apply the function `abs` over its entries. Then apply the function `log` over the resulting vector and last apply the function `mean`.

The code is equivalent to standard R but it is simpler to read. So sometimes it is preferrable to code using pipes instead of standard R syntax.


## Plotting

R has great plotting capabilities. Details about plotting functions and a discussion of when different representations are most appropriate are beyond the scope of these notes. This is just to provide you with a list of functions:

 - `barplot` creates a barplot: notice that you first need to construct a so-called contingency table using the function `table`.
 
 - `hist` creates an histogram;
 
 - `boxplot` creates a boxplot;
 
 - `plot` creates a scatterplot;
 
There are many functions to customize such plots, and again details can be found in the references given. A package which is often used to create nice data visualization is `ggplot2`.



